   1               		.file	"stk500boot.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__RAMPZ__ = 0x3b
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
  10               		.cfi_sections	.debug_frame
  12               	sendchar:
  13               	.LFB13:
  14               		.file 1 "stk500boot.c"
   1:stk500boot.c  **** /*****************************************************************************
   2:stk500boot.c  **** Title:     STK500v2 compatible bootloader
   3:stk500boot.c  ****            Modified for Wiring board ATMega128-16MHz
   4:stk500boot.c  **** Author:    Peter Fleury <pfleury@gmx.ch>   http://jump.to/fleury
   5:stk500boot.c  **** Compiler:  avr-gcc 3.4.5 or 4.1 / avr-libc 1.4.3
   6:stk500boot.c  **** Hardware:  All AVRs with bootloader support, tested with ATmega8
   7:stk500boot.c  **** License:   GNU General Public License
   8:stk500boot.c  **** 
   9:stk500boot.c  **** Modified:  Worapoht Kornkaewwattanakul <dev@avride.com>   http://www.avride.com
  10:stk500boot.c  **** Date:      17 October 2007
  11:stk500boot.c  **** Update:    1st, 29 Dec 2007 : Enable CMD_SPI_MULTI but ignore unused command by return 0x00 byte re
  12:stk500boot.c  **** Compiler:  WINAVR20060421
  13:stk500boot.c  **** Description: add timeout feature like previous Wiring bootloader
  14:stk500boot.c  **** 
  15:stk500boot.c  **** DESCRIPTION:
  16:stk500boot.c  ****     This program allows an AVR with bootloader capabilities to
  17:stk500boot.c  ****     read/write its own Flash/EEprom. To enter Programming mode
  18:stk500boot.c  ****     an input pin is checked. If this pin is pulled low, programming mode
  19:stk500boot.c  ****     is entered. If not, normal execution is done from $0000
  20:stk500boot.c  ****     "reset" vector in Application area.
  21:stk500boot.c  ****     Size fits into a 1024 word bootloader section
  22:stk500boot.c  **** 	when compiled with avr-gcc 4.1
  23:stk500boot.c  **** 	(direct replace on Wiring Board without fuse setting changed)
  24:stk500boot.c  **** 
  25:stk500boot.c  **** USAGE:
  26:stk500boot.c  ****     - Set AVR MCU type and clock-frequency (F_CPU) in the Makefile.
  27:stk500boot.c  ****     - Set baud rate below (AVRISP only works with 115200 bps)
  28:stk500boot.c  ****     - compile/link the bootloader with the supplied Makefile
  29:stk500boot.c  ****     - program the "Boot Flash section size" (BOOTSZ fuses),
  30:stk500boot.c  ****       for boot-size 1024 words:  program BOOTSZ01
  31:stk500boot.c  ****     - enable the BOOT Reset Vector (program BOOTRST)
  32:stk500boot.c  ****     - Upload the hex file to the AVR using any ISP programmer
  33:stk500boot.c  ****     - Program Boot Lock Mode 3 (program BootLock 11 and BootLock 12 lock bits) // (leave them)
  34:stk500boot.c  ****     - Reset your AVR while keeping PROG_PIN pulled low // (for enter bootloader by switch)
  35:stk500boot.c  ****     - Start AVRISP Programmer (AVRStudio/Tools/Program AVR)
  36:stk500boot.c  ****     - AVRISP will detect the bootloader
  37:stk500boot.c  ****     - Program your application FLASH file and optional EEPROM file using AVRISP
  38:stk500boot.c  **** 
  39:stk500boot.c  **** Note:
  40:stk500boot.c  ****     Erasing the device without flashing, through AVRISP GUI button "Erase Device"
  41:stk500boot.c  ****     is not implemented, due to AVRStudio limitations.
  42:stk500boot.c  ****     Flash is always erased before programming.
  43:stk500boot.c  **** 
  44:stk500boot.c  **** 	AVRdude:
  45:stk500boot.c  **** 	Please uncomment #define REMOVE_CMD_SPI_MULTI when using AVRdude.
  46:stk500boot.c  **** 	Comment #define REMOVE_PROGRAM_LOCK_BIT_SUPPORT to reduce code size
  47:stk500boot.c  **** 	Read Fuse Bits and Read/Write Lock Bits is not supported
  48:stk500boot.c  **** 
  49:stk500boot.c  **** NOTES:
  50:stk500boot.c  ****     Based on Atmel Application Note AVR109 - Self-programming
  51:stk500boot.c  ****     Based on Atmel Application Note AVR068 - STK500v2 Protocol
  52:stk500boot.c  **** 
  53:stk500boot.c  **** LICENSE:
  54:stk500boot.c  ****     Copyright (C) 2006 Peter Fleury
  55:stk500boot.c  **** 
  56:stk500boot.c  ****     This program is free software; you can redistribute it and/or modify
  57:stk500boot.c  ****     it under the terms of the GNU General Public License as published by
  58:stk500boot.c  ****     the Free Software Foundation; either version 2 of the License, or
  59:stk500boot.c  ****     any later version.
  60:stk500boot.c  **** 
  61:stk500boot.c  ****     This program is distributed in the hope that it will be useful,
  62:stk500boot.c  ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  63:stk500boot.c  ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  64:stk500boot.c  ****     GNU General Public License for more details.
  65:stk500boot.c  **** 
  66:stk500boot.c  **** *****************************************************************************/
  67:stk500boot.c  **** 
  68:stk500boot.c  **** //************************************************************************
  69:stk500boot.c  **** //*	Edit History
  70:stk500boot.c  **** //************************************************************************
  71:stk500boot.c  **** //*	Jul  7,	2010	<MLS> = Mark Sproul msproul@skycharoit.com
  72:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Working on mega2560. No Auto-restart
  73:stk500boot.c  **** //*	Jul  7,	2010	<MLS> Switched to 8K bytes (4K words) so that we have room for the monitor
  74:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Found older version of source that had auto restart, put that code back in
  75:stk500boot.c  **** //*	Jul  8,	2010	<MLS> Adding monitor code
  76:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added blinking LED while waiting for download to start
  77:stk500boot.c  **** //*	Jul 11,	2010	<MLS> Added EEPROM test
  78:stk500boot.c  **** //*	Jul 29,	2010	<MLS> Added recchar_timeout for timing out on bootloading
  79:stk500boot.c  **** //*	Aug 23,	2010	<MLS> Added support for atmega2561
  80:stk500boot.c  **** //*	Aug 26,	2010	<MLS> Removed support for BOOT_BY_SWITCH
  81:stk500boot.c  **** //*	Sep  8,	2010	<MLS> Added support for atmega16
  82:stk500boot.c  **** //*	Nov  9,	2010	<MLS> Issue 392:Fixed bug that 3 !!! in code would cause it to jump to monitor
  83:stk500boot.c  **** //*	Jun 24,	2011	<MLS> Removed analogRead (was not used)
  84:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 181: added watch dog timmer support
  85:stk500boot.c  **** //*	Dec 29,	2011	<MLS> Issue 505:  bootloader is comparing the seqNum to 1 or the current sequence
  86:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: CMD_CHIP_ERASE_ISP now returns STATUS_CMD_FAILED instead of STATU
  87:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 543: Write EEPROM now does something (NOT TESTED)
  88:stk500boot.c  **** //*	Jan  1,	2012	<MLS> Issue 544: stk500v2 bootloader doesn't support reading fuses
  89:stk500boot.c  **** //************************************************************************
  90:stk500boot.c  **** 
  91:stk500boot.c  **** //************************************************************************
  92:stk500boot.c  **** //*	these are used to test issues
  93:stk500boot.c  **** //*	http://code.google.com/p/arduino/issues/detail?id=505
  94:stk500boot.c  **** //*	Reported by mark.stubbs, Mar 14, 2011
  95:stk500boot.c  **** //*	The STK500V2 bootloader is comparing the seqNum to 1 or the current sequence
  96:stk500boot.c  **** //*	(IE: Requiring the sequence to be 1 or match seqNum before continuing).
  97:stk500boot.c  **** //*	The correct behavior is for the STK500V2 to accept the PC's sequence number, and echo it back f
  98:stk500boot.c  **** #define	_FIX_ISSUE_505_
  99:stk500boot.c  **** //************************************************************************
 100:stk500boot.c  **** 
 101:stk500boot.c  **** #include	<inttypes.h>
 102:stk500boot.c  **** #include	<avr/io.h>
 103:stk500boot.c  **** #include	<avr/interrupt.h>
 104:stk500boot.c  **** #include	<avr/boot.h>
 105:stk500boot.c  **** #include	<avr/pgmspace.h>
 106:stk500boot.c  **** #include	<util/delay.h>
 107:stk500boot.c  **** #include	<avr/eeprom.h>
 108:stk500boot.c  **** #include	<avr/common.h>
 109:stk500boot.c  **** #include	<stdlib.h>
 110:stk500boot.c  **** #include	"command.h"
 111:stk500boot.c  **** 
 112:stk500boot.c  **** 
 113:stk500boot.c  **** #if defined(_MEGA_BOARD_) || defined(_BOARD_AMBER128_) || defined(__AVR_ATmega1280__) || defined(__
 114:stk500boot.c  **** 	|| defined(__AVR_ATmega2561__) || defined(__AVR_ATmega1284P__) || defined(ENABLE_MONITOR)
 115:stk500boot.c  **** 	#undef		ENABLE_MONITOR
 116:stk500boot.c  **** 	#define		ENABLE_MONITOR
 117:stk500boot.c  **** 	static void	RunMonitor(void);
 118:stk500boot.c  **** #endif
 119:stk500boot.c  **** 
 120:stk500boot.c  **** #ifndef EEWE
 121:stk500boot.c  **** 	#define EEWE    1
 122:stk500boot.c  **** #endif
 123:stk500boot.c  **** #ifndef EEMWE
 124:stk500boot.c  **** 	#define EEMWE   2
 125:stk500boot.c  **** #endif
 126:stk500boot.c  **** 
 127:stk500boot.c  **** //#define	_DEBUG_SERIAL_
 128:stk500boot.c  **** //#define	_DEBUG_WITH_LEDS_
 129:stk500boot.c  **** 
 130:stk500boot.c  **** 
 131:stk500boot.c  **** /*
 132:stk500boot.c  ****  * Uncomment the following lines to save code space
 133:stk500boot.c  ****  */
 134:stk500boot.c  **** //#define	REMOVE_PROGRAM_LOCK_BIT_SUPPORT		// disable program lock bits
 135:stk500boot.c  **** //#define	REMOVE_BOOTLOADER_LED				// no LED to show active bootloader
 136:stk500boot.c  **** //#define	REMOVE_CMD_SPI_MULTI				// disable processing of SPI_MULTI commands, Remark this line for
 137:stk500boot.c  **** //
 138:stk500boot.c  **** 
 139:stk500boot.c  **** 
 140:stk500boot.c  **** 
 141:stk500boot.c  **** //************************************************************************
 142:stk500boot.c  **** //*	LED on pin "PROGLED_PIN" on port "PROGLED_PORT"
 143:stk500boot.c  **** //*	indicates that bootloader is active
 144:stk500boot.c  **** //*	PG2 -> LED on Wiring board
 145:stk500boot.c  **** //************************************************************************
 146:stk500boot.c  **** #define		BLINK_LED_WHILE_WAITING
 147:stk500boot.c  **** 
 148:stk500boot.c  **** #ifdef _MEGA_BOARD_
 149:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 150:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 151:stk500boot.c  **** 	#define PROGLED_PIN		PINB7
 152:stk500boot.c  **** #elif defined( _BOARD_AMBER128_ )
 153:stk500boot.c  **** 	//*	this is for the amber 128 http://www.soc-robotics.com/
 154:stk500boot.c  **** 	//*	onbarod led is PORTE4
 155:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 156:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 157:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 158:stk500boot.c  **** #elif defined( _CEREBOTPLUS_BOARD_ ) || defined( _CEREBOT_II_BOARD_ )
 159:stk500boot.c  **** 	//*	this is for the Cerebot 2560 board and the Cerebot-ii
 160:stk500boot.c  **** 	//*	onbarod leds are on PORTE4-7
 161:stk500boot.c  **** 	#define PROGLED_PORT	PORTE
 162:stk500boot.c  **** 	#define PROGLED_DDR		DDRE
 163:stk500boot.c  **** 	#define PROGLED_PIN		PINE7
 164:stk500boot.c  **** #elif defined( _PENGUINO_ )
 165:stk500boot.c  **** 	//*	this is for the Penguino
 166:stk500boot.c  **** 	//*	onbarod led is PORTE4
 167:stk500boot.c  **** 	#define PROGLED_PORT	PORTC
 168:stk500boot.c  **** 	#define PROGLED_DDR		DDRC
 169:stk500boot.c  **** 	#define PROGLED_PIN		PINC6
 170:stk500boot.c  **** #elif defined( _ANDROID_2561_ ) || defined( __AVR_ATmega2561__ )
 171:stk500boot.c  **** 	//*	this is for the Boston Android 2561
 172:stk500boot.c  **** 	//*	onbarod led is PORTE4
 173:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 174:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 175:stk500boot.c  **** 	#define PROGLED_PIN		PINA3
 176:stk500boot.c  **** #elif defined( _BOARD_MEGA16 )
 177:stk500boot.c  **** 	//*	onbarod led is PORTA7
 178:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 179:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 180:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 181:stk500boot.c  **** 	#define UART_BAUDRATE_DOUBLE_SPEED 0
 182:stk500boot.c  **** 
 183:stk500boot.c  **** #elif defined( _BOARD_BAHBOT_ )
 184:stk500boot.c  **** 	//*	dosent have an onboard LED but this is what will probably be added to this port
 185:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 186:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 187:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 188:stk500boot.c  **** 
 189:stk500boot.c  **** #elif defined( _BOARD_ROBOTX_ )
 190:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 191:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 192:stk500boot.c  **** 	#define PROGLED_PIN		PINB6
 193:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_BLINK_B0_ )
 194:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 195:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 196:stk500boot.c  **** 	#define PROGLED_PIN		PINB0
 197:stk500boot.c  **** #elif defined( _BOARD_CUSTOM1284_ )
 198:stk500boot.c  **** 	#define PROGLED_PORT	PORTD
 199:stk500boot.c  **** 	#define PROGLED_DDR		DDRD
 200:stk500boot.c  **** 	#define PROGLED_PIN		PIND5
 201:stk500boot.c  **** #elif defined( _AVRLIP_ )
 202:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 203:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 204:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 205:stk500boot.c  **** #elif defined( _BOARD_STK500_ )
 206:stk500boot.c  **** 	#define PROGLED_PORT	PORTA
 207:stk500boot.c  **** 	#define PROGLED_DDR		DDRA
 208:stk500boot.c  **** 	#define PROGLED_PIN		PINA7
 209:stk500boot.c  **** #elif defined( _BOARD_STK502_ )
 210:stk500boot.c  **** 	#define PROGLED_PORT	PORTB
 211:stk500boot.c  **** 	#define PROGLED_DDR		DDRB
 212:stk500boot.c  **** 	#define PROGLED_PIN		PINB5
 213:stk500boot.c  **** #elif defined( _BOARD_easyHOME_ )
 214:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 215:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 216:stk500boot.c  **** 	#define PROGLED_PIN		PING5
 217:stk500boot.c  **** #else
 218:stk500boot.c  **** 	#define PROGLED_PORT	PORTG
 219:stk500boot.c  **** 	#define PROGLED_DDR		DDRG
 220:stk500boot.c  **** 	#define PROGLED_PIN		PING2
 221:stk500boot.c  **** #endif
 222:stk500boot.c  **** 
 223:stk500boot.c  **** 
 224:stk500boot.c  **** 
 225:stk500boot.c  **** /*
 226:stk500boot.c  ****  * define CPU frequency in Mhz here if not defined in Makefile
 227:stk500boot.c  ****  */
 228:stk500boot.c  **** #ifndef F_CPU
 229:stk500boot.c  **** 	#define F_CPU 16000000UL
 230:stk500boot.c  **** #endif
 231:stk500boot.c  **** 
 232:stk500boot.c  **** #define	_BLINK_LOOP_COUNT_	(F_CPU / 2250)
 233:stk500boot.c  **** /*
 234:stk500boot.c  ****  * UART Baudrate, AVRStudio AVRISP only accepts 115200 bps
 235:stk500boot.c  ****  */
 236:stk500boot.c  **** 
 237:stk500boot.c  **** #ifndef BAUDRATE
 238:stk500boot.c  **** 	#define BAUDRATE 115200
 239:stk500boot.c  **** #endif
 240:stk500boot.c  **** 
 241:stk500boot.c  **** /*
 242:stk500boot.c  ****  *  Enable (1) or disable (0) USART double speed operation
 243:stk500boot.c  ****  */
 244:stk500boot.c  **** #ifndef UART_BAUDRATE_DOUBLE_SPEED
 245:stk500boot.c  **** 	#if defined (__AVR_ATmega32__)
 246:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 0
 247:stk500boot.c  **** 	#else
 248:stk500boot.c  **** 		#define UART_BAUDRATE_DOUBLE_SPEED 1
 249:stk500boot.c  **** 	#endif
 250:stk500boot.c  **** #endif
 251:stk500boot.c  **** 
 252:stk500boot.c  **** /*
 253:stk500boot.c  ****  * HW and SW version, reported to AVRISP, must match version of AVRStudio
 254:stk500boot.c  ****  */
 255:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_LOW	0
 256:stk500boot.c  **** #define CONFIG_PARAM_BUILD_NUMBER_HIGH	0
 257:stk500boot.c  **** #define CONFIG_PARAM_HW_VER				0x0F
 258:stk500boot.c  **** #define CONFIG_PARAM_SW_MAJOR			2
 259:stk500boot.c  **** #define CONFIG_PARAM_SW_MINOR			0x0A
 260:stk500boot.c  **** 
 261:stk500boot.c  **** /*
 262:stk500boot.c  ****  * Calculate the address where the bootloader starts from FLASHEND and BOOTSIZE
 263:stk500boot.c  ****  * (adjust BOOTSIZE below and BOOTLOADER_ADDRESS in Makefile if you want to change the size of the 
 264:stk500boot.c  ****  */
 265:stk500boot.c  **** //#define BOOTSIZE 1024
 266:stk500boot.c  **** #if FLASHEND > 0x0F000
 267:stk500boot.c  **** 	#define BOOTSIZE 8192
 268:stk500boot.c  **** #else
 269:stk500boot.c  **** 	#define BOOTSIZE 2048
 270:stk500boot.c  **** #endif
 271:stk500boot.c  **** 
 272:stk500boot.c  **** #define APP_END  (FLASHEND -(2*BOOTSIZE) + 1)
 273:stk500boot.c  **** 
 274:stk500boot.c  **** /*
 275:stk500boot.c  ****  * Signature bytes are not available in avr-gcc io_xxx.h
 276:stk500boot.c  ****  */
 277:stk500boot.c  **** #if defined (__AVR_ATmega8__)
 278:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9307
 279:stk500boot.c  **** #elif defined (__AVR_ATmega16__)
 280:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9403
 281:stk500boot.c  **** #elif defined (__AVR_ATmega32__)
 282:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9502
 283:stk500boot.c  **** #elif defined (__AVR_ATmega8515__)
 284:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9306
 285:stk500boot.c  **** #elif defined (__AVR_ATmega8535__)
 286:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9308
 287:stk500boot.c  **** #elif defined (__AVR_ATmega162__)
 288:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9404
 289:stk500boot.c  **** #elif defined (__AVR_ATmega128__)
 290:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9702
 291:stk500boot.c  **** #elif defined (__AVR_ATmega1280__)
 292:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9703
 293:stk500boot.c  **** #elif defined (__AVR_ATmega2560__)
 294:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1E9801
 295:stk500boot.c  **** #elif defined (__AVR_ATmega2561__)
 296:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9802
 297:stk500boot.c  **** #elif defined (__AVR_ATmega1284P__)
 298:stk500boot.c  **** 	#define SIGNATURE_BYTES 0x1e9705
 299:stk500boot.c  **** #elif defined (__AVR_ATmega640__)
 300:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9608
 301:stk500boot.c  **** #elif defined (__AVR_ATmega64__)
 302:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1E9602
 303:stk500boot.c  **** #elif defined (__AVR_ATmega169__)
 304:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9405
 305:stk500boot.c  **** #elif defined (__AVR_AT90USB1287__)
 306:stk500boot.c  **** 	#define SIGNATURE_BYTES  0x1e9782
 307:stk500boot.c  **** #else
 308:stk500boot.c  **** 	#error "no signature definition for MCU available"
 309:stk500boot.c  **** #endif
 310:stk500boot.c  **** 
 311:stk500boot.c  **** 
 312:stk500boot.c  **** #if defined(_BOARD_ROBOTX_) || defined(__AVR_AT90USB1287__) || defined(__AVR_AT90USB1286__)
 313:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR1L
 314:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR1A
 315:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR1B
 316:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN1
 317:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN1
 318:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC1
 319:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC1
 320:stk500boot.c  **** 	#define	UART_DATA_REG				UDR1
 321:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X1
 322:stk500boot.c  **** 
 323:stk500boot.c  **** #elif defined(__AVR_ATmega8__) || defined(__AVR_ATmega16__) || defined(__AVR_ATmega32__) \
 324:stk500boot.c  **** 	|| defined(__AVR_ATmega8515__) || defined(__AVR_ATmega8535__)
 325:stk500boot.c  **** 	/* ATMega8 with one USART */
 326:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 327:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 328:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 329:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 330:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 331:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 332:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 333:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 334:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 335:stk500boot.c  **** 
 336:stk500boot.c  **** #elif defined(__AVR_ATmega64__) || defined(__AVR_ATmega128__) || defined(__AVR_ATmega162__) \
 337:stk500boot.c  **** 	 || defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)
 338:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 339:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 340:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 341:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 342:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 343:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 344:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 345:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 346:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 347:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 348:stk500boot.c  **** #elif defined(UBRR0L) && defined(UCSR0A) && defined(TXEN0)
 349:stk500boot.c  **** 	/* ATMega with two USART, use UART0 */
 350:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRR0L
 351:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSR0A
 352:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSR0B
 353:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN0
 354:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN0
 355:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC0
 356:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC0
 357:stk500boot.c  **** 	#define	UART_DATA_REG				UDR0
 358:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X0
 359:stk500boot.c  **** #elif defined(UBRRL) && defined(UCSRA) && defined(UCSRB) && defined(TXEN) && defined(RXEN)
 360:stk500boot.c  **** 	//* catch all
 361:stk500boot.c  **** 	#define	UART_BAUD_RATE_LOW			UBRRL
 362:stk500boot.c  **** 	#define	UART_STATUS_REG				UCSRA
 363:stk500boot.c  **** 	#define	UART_CONTROL_REG			UCSRB
 364:stk500boot.c  **** 	#define	UART_ENABLE_TRANSMITTER		TXEN
 365:stk500boot.c  **** 	#define	UART_ENABLE_RECEIVER		RXEN
 366:stk500boot.c  **** 	#define	UART_TRANSMIT_COMPLETE		TXC
 367:stk500boot.c  **** 	#define	UART_RECEIVE_COMPLETE		RXC
 368:stk500boot.c  **** 	#define	UART_DATA_REG				UDR
 369:stk500boot.c  **** 	#define	UART_DOUBLE_SPEED			U2X
 370:stk500boot.c  **** #else
 371:stk500boot.c  **** 	#error "no UART definition for MCU available"
 372:stk500boot.c  **** #endif
 373:stk500boot.c  **** 
 374:stk500boot.c  **** 
 375:stk500boot.c  **** 
 376:stk500boot.c  **** /*
 377:stk500boot.c  ****  * Macro to calculate UBBR from XTAL and baudrate
 378:stk500boot.c  ****  */
 379:stk500boot.c  **** #if defined(__AVR_ATmega32__) && UART_BAUDRATE_DOUBLE_SPEED
 380:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 4 / baudRate - 1) / 2)
 381:stk500boot.c  **** #elif defined(__AVR_ATmega32__)
 382:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) ((xtalCpu / 8 / baudRate - 1) / 2)
 383:stk500boot.c  **** #elif UART_BAUDRATE_DOUBLE_SPEED
 384:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*8.0)-1.0+0.5)
 385:stk500boot.c  **** #else
 386:stk500boot.c  **** 	#define UART_BAUD_SELECT(baudRate,xtalCpu) (((float)(xtalCpu))/(((float)(baudRate))*16.0)-1.0+0.5)
 387:stk500boot.c  **** #endif
 388:stk500boot.c  **** 
 389:stk500boot.c  **** 
 390:stk500boot.c  **** /*
 391:stk500boot.c  ****  * States used in the receive state machine
 392:stk500boot.c  ****  */
 393:stk500boot.c  **** #define	ST_START		0
 394:stk500boot.c  **** #define	ST_GET_SEQ_NUM	1
 395:stk500boot.c  **** #define ST_MSG_SIZE_1	2
 396:stk500boot.c  **** #define ST_MSG_SIZE_2	3
 397:stk500boot.c  **** #define ST_GET_TOKEN	4
 398:stk500boot.c  **** #define ST_GET_DATA		5
 399:stk500boot.c  **** #define	ST_GET_CHECK	6
 400:stk500boot.c  **** #define	ST_PROCESS		7
 401:stk500boot.c  **** 
 402:stk500boot.c  **** /*
 403:stk500boot.c  ****  * use 16bit address variable for ATmegas with <= 64K flash
 404:stk500boot.c  ****  */
 405:stk500boot.c  **** #if defined(RAMPZ)
 406:stk500boot.c  **** 	typedef uint32_t address_t;
 407:stk500boot.c  **** #else
 408:stk500boot.c  **** 	typedef uint16_t address_t;
 409:stk500boot.c  **** #endif
 410:stk500boot.c  **** 
 411:stk500boot.c  **** /*
 412:stk500boot.c  ****  * function prototypes
 413:stk500boot.c  ****  */
 414:stk500boot.c  **** static void sendchar(char c);
 415:stk500boot.c  **** static unsigned char recchar(void);
 416:stk500boot.c  **** 
 417:stk500boot.c  **** /*
 418:stk500boot.c  ****  * since this bootloader is not linked against the avr-gcc crt1 functions,
 419:stk500boot.c  ****  * to reduce the code size, we need to provide our own initialization
 420:stk500boot.c  ****  */
 421:stk500boot.c  **** void __jumpMain	(void) __attribute__ ((naked)) __attribute__ ((section (".init9")));
 422:stk500boot.c  **** #include <avr/sfr_defs.h>
 423:stk500boot.c  **** 
 424:stk500boot.c  **** //#define	SPH_REG	0x3E
 425:stk500boot.c  **** //#define	SPL_REG	0x3D
 426:stk500boot.c  **** 
 427:stk500boot.c  **** //*****************************************************************************
 428:stk500boot.c  **** void __jumpMain(void)
 429:stk500boot.c  **** {
 430:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
 431:stk500boot.c  **** //*	the first line did not do the job on the ATmega128
 432:stk500boot.c  **** 
 433:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 434:stk500boot.c  **** 
 435:stk500boot.c  **** //*	set stack pointer to top of RAM
 436:stk500boot.c  **** 
 437:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 438:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 439:stk500boot.c  **** 
 440:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 441:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 442:stk500boot.c  **** 
 443:stk500boot.c  **** 	asm volatile ( "clr __zero_reg__" );									// GCC depends on register r1 set to 0
 444:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
 445:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
 446:stk500boot.c  **** }
 447:stk500boot.c  **** 
 448:stk500boot.c  **** 
 449:stk500boot.c  **** //*****************************************************************************
 450:stk500boot.c  **** void delay_ms(unsigned int timedelay)
 451:stk500boot.c  **** {
 452:stk500boot.c  **** 	unsigned int i;
 453:stk500boot.c  **** 	for (i=0;i<timedelay;i++)
 454:stk500boot.c  **** 	{
 455:stk500boot.c  **** 		_delay_ms(0.5);
 456:stk500boot.c  **** 	}
 457:stk500boot.c  **** }
 458:stk500boot.c  **** 
 459:stk500boot.c  **** 
 460:stk500boot.c  **** //*****************************************************************************
 461:stk500boot.c  **** /*
 462:stk500boot.c  ****  * send single byte to USART, wait until transmission is completed
 463:stk500boot.c  ****  */
 464:stk500boot.c  **** static void sendchar(char c)
 465:stk500boot.c  **** {
  15               		.loc 1 465 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
 466:stk500boot.c  **** 	UART_DATA_REG	=	c;										// prepare transmission
  22               		.loc 1 466 0
  23 0000 8093 C600 		sts 198,r24
  24               	.LVL1:
  25               	.L2:
 467:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_TRANSMIT_COMPLETE)));	// wait until byte sent
  26               		.loc 1 467 0 discriminator 1
  27 0004 8091 C000 		lds r24,192
  28 0008 86FF      		sbrs r24,6
  29 000a 00C0      		rjmp .L2
 468:stk500boot.c  **** 	UART_STATUS_REG |= (1 << UART_TRANSMIT_COMPLETE);			// delete TXCflag
  30               		.loc 1 468 0
  31 000c 8091 C000 		lds r24,192
  32 0010 8064      		ori r24,lo8(64)
  33 0012 8093 C000 		sts 192,r24
  34               	.LVL2:
  35 0016 0895      		ret
  36               		.cfi_endproc
  37               	.LFE13:
  39               		.section	.text.unlikely,"ax",@progbits
  41               	recchar:
  42               	.LFB15:
 469:stk500boot.c  **** }
 470:stk500boot.c  **** 
 471:stk500boot.c  **** 
 472:stk500boot.c  **** //************************************************************************
 473:stk500boot.c  **** static int	Serial_Available(void)
 474:stk500boot.c  **** {
 475:stk500boot.c  **** 	return(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE));	// wait for data
 476:stk500boot.c  **** }
 477:stk500boot.c  **** 
 478:stk500boot.c  **** 
 479:stk500boot.c  **** //*****************************************************************************
 480:stk500boot.c  **** /*
 481:stk500boot.c  ****  * Read single byte from USART, block if no data available
 482:stk500boot.c  ****  */
 483:stk500boot.c  **** static unsigned char recchar(void)
 484:stk500boot.c  **** {
  43               		.loc 1 484 0
  44               		.cfi_startproc
  45               	/* prologue: function */
  46               	/* frame size = 0 */
  47               	/* stack size = 0 */
  48               	.L__stack_usage = 0
  49               	.L7:
 485:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
  50               		.loc 1 485 0 discriminator 1
  51 0000 8091 C000 		lds r24,192
  52 0004 87FF      		sbrs r24,7
  53 0006 00C0      		rjmp .L7
 486:stk500boot.c  **** 	{
 487:stk500boot.c  **** 		// wait for data
 488:stk500boot.c  **** 	}
 489:stk500boot.c  **** 	return UART_DATA_REG;
  54               		.loc 1 489 0
  55 0008 8091 C600 		lds r24,198
 490:stk500boot.c  **** }
  56               		.loc 1 490 0
  57 000c 0895      		ret
  58               		.cfi_endproc
  59               	.LFE15:
  61               		.section	.init9,"ax",@progbits
  62               	.global	__jumpMain
  64               	__jumpMain:
  65               	.LFB11:
 429:stk500boot.c  **** //*	July 17, 2010	<MLS> Added stack pointer initialzation
  66               		.loc 1 429 0
  67               		.cfi_startproc
  68               	/* prologue: naked */
  69               	/* frame size = 0 */
  70               	/* stack size = 0 */
  71               	.L__stack_usage = 0
 433:stk500boot.c  **** 
  72               		.loc 1 433 0
  73               	/* #APP */
  74               	 ;  433 "stk500boot.c" 1
  75               		.set __stack, 8703
  76               	 ;  0 "" 2
 437:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
  77               		.loc 1 437 0
  78               	 ;  437 "stk500boot.c" 1
  79 0000 01E2      		ldi	16, 33
  80               	 ;  0 "" 2
 438:stk500boot.c  **** 
  81               		.loc 1 438 0
  82               	 ;  438 "stk500boot.c" 1
  83 0002 0EBF      		out 62,16
  84               	 ;  0 "" 2
 440:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
  85               		.loc 1 440 0
  86               	 ;  440 "stk500boot.c" 1
  87 0004 0FEF      		ldi	16, 255
  88               	 ;  0 "" 2
 441:stk500boot.c  **** 
  89               		.loc 1 441 0
  90               	 ;  441 "stk500boot.c" 1
  91 0006 0DBF      		out 61,16
  92               	 ;  0 "" 2
 443:stk500boot.c  **** 	asm volatile ( "out %0, __zero_reg__" :: "I" (_SFR_IO_ADDR(SREG)) );	// set SREG to 0
  93               		.loc 1 443 0
  94               	 ;  443 "stk500boot.c" 1
  95 0008 1124      		clr __zero_reg__
  96               	 ;  0 "" 2
 444:stk500boot.c  **** 	asm volatile ( "jmp main");												// jump to main()
  97               		.loc 1 444 0
  98               	 ;  444 "stk500boot.c" 1
  99 000a 1FBE      		out 63, __zero_reg__
 100               	 ;  0 "" 2
 445:stk500boot.c  **** }
 101               		.loc 1 445 0
 102               	 ;  445 "stk500boot.c" 1
 103 000c 0C94 0000 		jmp main
 104               	 ;  0 "" 2
 105               	/* epilogue start */
 446:stk500boot.c  **** 
 106               		.loc 1 446 0
 107               	/* #NOAPP */
 108               		.cfi_endproc
 109               	.LFE11:
 111               		.text
 112               	.global	delay_ms
 114               	delay_ms:
 115               	.LFB12:
 451:stk500boot.c  **** 	unsigned int i;
 116               		.loc 1 451 0
 117               		.cfi_startproc
 118               	.LVL3:
 119               	/* prologue: function */
 120               	/* frame size = 0 */
 121               	/* stack size = 0 */
 122               	.L__stack_usage = 0
 453:stk500boot.c  **** 	{
 123               		.loc 1 453 0
 124 0018 20E0      		ldi r18,0
 125 001a 30E0      		ldi r19,0
 126               	.LVL4:
 127               	.L11:
 453:stk500boot.c  **** 	{
 128               		.loc 1 453 0 is_stmt 0 discriminator 1
 129 001c 2817      		cp r18,r24
 130 001e 3907      		cpc r19,r25
 131 0020 01F0      		breq .L13
 132               	.LVL5:
 133               	.LBB51:
 134               	.LBB52:
 135               		.file 2 "/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h"
   1:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    All rights reserved.
   5:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
   6:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
   9:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  12:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****      distribution.
  16:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  17:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  21:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  33:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /* $Id$ */
  34:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  35:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  38:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #  endif
  42:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  44:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #include <inttypes.h>
  45:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #include <math.h>
  47:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  48:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /** \file */
  49:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     \code
  51:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     \endcode
  55:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  56:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     used.
  60:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  61:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  70:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     routines linked into the application.
  78:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  79:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  83:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** */
  84:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  85:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #endif
  89:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  90:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #ifndef F_CPU
  91:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     \def F_CPU
  95:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
  97:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 103:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****     integer value.
 107:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****  */
 108:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #endif
 110:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 111:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #endif
 114:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 115:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #  include <math.h>
 119:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #endif
 120:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 121:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** /**
 122:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    \ingroup util_delay
 123:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 124:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 126:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 129:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 131:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 137:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 142:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    microseconds of delay.
 146:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 147:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    respectively.
 151:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 152:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    \note
 153:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 154:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****    not available to the compiler then.
 163:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 164:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****  */
 165:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** void
 166:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** {
 168:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	double __tmp ;
 169:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 176:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 179:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 182:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	#else
 183:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 		//round up by default
 184:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	#endif
 186:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 
 187:/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 136               		.loc 2 187 0 is_stmt 1
 137 0022 EFEC      		ldi r30,lo8(1999)
 138 0024 F7E0      		ldi r31,hi8(1999)
 139 0026 3197      	1:	sbiw r30,1
 140 0028 01F4      		brne 1b
 141 002a 00C0      		rjmp .
 142 002c 0000      		nop
 143               	.LBE52:
 144               	.LBE51:
 453:stk500boot.c  **** 	{
 145               		.loc 1 453 0
 146 002e 2F5F      		subi r18,-1
 147 0030 3F4F      		sbci r19,-1
 148               	.LVL6:
 149 0032 00C0      		rjmp .L11
 150               	.LVL7:
 151               	.L13:
 152               	/* epilogue start */
 457:stk500boot.c  **** 
 153               		.loc 1 457 0
 154 0034 0895      		ret
 155               		.cfi_endproc
 156               	.LFE12:
 158               	.global	PrintFromPROGMEM
 160               	PrintFromPROGMEM:
 161               	.LFB18:
 491:stk500boot.c  **** 
 492:stk500boot.c  **** #define	MAX_TIME_COUNT	(F_CPU >> 1)
 493:stk500boot.c  **** //*****************************************************************************
 494:stk500boot.c  **** static unsigned char recchar_timeout(void)
 495:stk500boot.c  **** {
 496:stk500boot.c  **** uint32_t count = 0;
 497:stk500boot.c  **** 
 498:stk500boot.c  **** 	while (!(UART_STATUS_REG & (1 << UART_RECEIVE_COMPLETE)))
 499:stk500boot.c  **** 	{
 500:stk500boot.c  **** 		// wait for data
 501:stk500boot.c  **** 		count++;
 502:stk500boot.c  **** 		if (count > MAX_TIME_COUNT)
 503:stk500boot.c  **** 		{
 504:stk500boot.c  **** 		unsigned int	data;
 505:stk500boot.c  **** 		#if (FLASHEND > 0x10000)
 506:stk500boot.c  **** 			data	=	pgm_read_word_far(0);	//*	get the first word of the user program
 507:stk500boot.c  **** 		#else
 508:stk500boot.c  **** 			data	=	pgm_read_word_near(0);	//*	get the first word of the user program
 509:stk500boot.c  **** 		#endif
 510:stk500boot.c  **** 			if (data != 0xffff)					//*	make sure its valid before jumping to it.
 511:stk500boot.c  **** 			{
 512:stk500boot.c  **** 				asm volatile(
 513:stk500boot.c  **** 						"clr	r30		\n\t"
 514:stk500boot.c  **** 						"clr	r31		\n\t"
 515:stk500boot.c  **** 						"ijmp	\n\t"
 516:stk500boot.c  **** 						);
 517:stk500boot.c  **** 			}
 518:stk500boot.c  **** 			count	=	0;
 519:stk500boot.c  **** 		}
 520:stk500boot.c  **** 	}
 521:stk500boot.c  **** 	return UART_DATA_REG;
 522:stk500boot.c  **** }
 523:stk500boot.c  **** 
 524:stk500boot.c  **** 
 525:stk500boot.c  **** //*****************************************************************************
 526:stk500boot.c  **** int main(void)
 527:stk500boot.c  **** {
 528:stk500boot.c  **** 	address_t		address			=	0;
 529:stk500boot.c  **** 	address_t		eraseAddress	=	0;
 530:stk500boot.c  **** 	unsigned char	msgParseState;
 531:stk500boot.c  **** 	unsigned int	ii				=	0;
 532:stk500boot.c  **** 	unsigned char	checksum		=	0;
 533:stk500boot.c  **** 	unsigned char	seqNum			=	0;
 534:stk500boot.c  **** 	unsigned int	msgLength		=	0;
 535:stk500boot.c  **** 	unsigned char	msgBuffer[285];
 536:stk500boot.c  **** 	unsigned char	c, *p;
 537:stk500boot.c  **** 	unsigned char   isLeave = 0;
 538:stk500boot.c  **** 
 539:stk500boot.c  **** 	unsigned long	boot_timeout;
 540:stk500boot.c  **** 	unsigned long	boot_timer;
 541:stk500boot.c  **** 	unsigned int	boot_state;
 542:stk500boot.c  **** #ifdef ENABLE_MONITOR
 543:stk500boot.c  **** 	unsigned int	exPointCntr		=	0;
 544:stk500boot.c  **** 	unsigned int	rcvdCharCntr	=	0;
 545:stk500boot.c  **** #endif
 546:stk500boot.c  **** 
 547:stk500boot.c  **** 	//*	some chips dont set the stack properly
 548:stk500boot.c  **** 	asm volatile ( ".set __stack, %0" :: "i" (RAMEND) );
 549:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 550:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 551:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 552:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 553:stk500boot.c  **** 
 554:stk500boot.c  **** 	// easyHome watchdog timer support
 555:stk500boot.c  **** 	__asm__ __volatile__ ("wdr");
 556:stk500boot.c  **** 	uint8_t mcuStatusReg = MCUSR;
 557:stk500boot.c  **** 	if (mcuStatusReg & (1<<WDRF))
 558:stk500boot.c  **** 	{
 559:stk500boot.c  **** 		asm volatile(
 560:stk500boot.c  **** 		"clr	r30		\n\t"
 561:stk500boot.c  **** 		"clr	r31		\n\t"
 562:stk500boot.c  **** 		"ijmp	\n\t"
 563:stk500boot.c  **** 		);
 564:stk500boot.c  **** 	}
 565:stk500boot.c  **** 
 566:stk500boot.c  **** 
 567:stk500boot.c  **** 	boot_timer	=	0;
 568:stk500boot.c  **** 	boot_state	=	0;
 569:stk500boot.c  **** 
 570:stk500boot.c  **** #ifdef BLINK_LED_WHILE_WAITING
 571:stk500boot.c  **** //	boot_timeout	=	 90000;		//*	should be about 4 seconds
 572:stk500boot.c  **** //	boot_timeout	=	170000;
 573:stk500boot.c  **** 	boot_timeout	=	 20000;		//*	should be about 1 second
 574:stk500boot.c  **** #else
 575:stk500boot.c  **** 	boot_timeout	=	3500000; // 7 seconds , approx 2us per step when optimize "s"
 576:stk500boot.c  **** #endif
 577:stk500boot.c  **** 	/*
 578:stk500boot.c  **** 	 * Branch to bootloader or application code ?
 579:stk500boot.c  **** 	 */
 580:stk500boot.c  **** 
 581:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
 582:stk500boot.c  **** 	/* PROG_PIN pulled low, indicate with LED that bootloader is active */
 583:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
 584:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 585:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 586:stk500boot.c  **** 
 587:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
 588:stk500boot.c  **** 	for (ii=0; ii<3; ii++)
 589:stk500boot.c  **** 	{
 590:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
 591:stk500boot.c  **** 		delay_ms(100);
 592:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 593:stk500boot.c  **** 		delay_ms(100);
 594:stk500boot.c  **** 	}
 595:stk500boot.c  **** #endif
 596:stk500boot.c  **** 
 597:stk500boot.c  **** #endif
 598:stk500boot.c  **** 	/*
 599:stk500boot.c  **** 	 * Init UART
 600:stk500boot.c  **** 	 * set baudrate and enable USART receiver and transmiter without interrupts
 601:stk500boot.c  **** 	 */
 602:stk500boot.c  **** #if UART_BAUDRATE_DOUBLE_SPEED
 603:stk500boot.c  **** 	UART_STATUS_REG		|=	(1 <<UART_DOUBLE_SPEED);
 604:stk500boot.c  **** #endif
 605:stk500boot.c  **** 	UART_BAUD_RATE_LOW	=	UART_BAUD_SELECT(BAUDRATE,F_CPU);
 606:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 607:stk500boot.c  **** 
 608:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
 609:stk500boot.c  **** 
 610:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
 611:stk500boot.c  **** //	delay_ms(500);
 612:stk500boot.c  **** 
 613:stk500boot.c  **** 	sendchar('s');
 614:stk500boot.c  **** 	sendchar('t');
 615:stk500boot.c  **** 	sendchar('k');
 616:stk500boot.c  **** //	sendchar('5');
 617:stk500boot.c  **** //	sendchar('0');
 618:stk500boot.c  **** //	sendchar('0');
 619:stk500boot.c  **** 	sendchar('v');
 620:stk500boot.c  **** 	sendchar('2');
 621:stk500boot.c  **** 	sendchar(0x0d);
 622:stk500boot.c  **** 	sendchar(0x0a);
 623:stk500boot.c  **** 
 624:stk500boot.c  **** 	delay_ms(100);
 625:stk500boot.c  **** #endif
 626:stk500boot.c  **** 
 627:stk500boot.c  **** 	while (boot_state==0)
 628:stk500boot.c  **** 	{
 629:stk500boot.c  **** 		while ((!(Serial_Available())) && (boot_state == 0))		// wait for data
 630:stk500boot.c  **** 		{
 631:stk500boot.c  **** 			_delay_ms(0.001);
 632:stk500boot.c  **** 			boot_timer++;
 633:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 634:stk500boot.c  **** 			{
 635:stk500boot.c  **** 				boot_state	=	1; // (after ++ -> boot_state=2 bootloader timeout, jump to main 0x00000 )
 636:stk500boot.c  **** 			}
 637:stk500boot.c  **** 		#ifdef BLINK_LED_WHILE_WAITING
 638:stk500boot.c  **** 			if ((boot_timer % _BLINK_LOOP_COUNT_) == 0)
 639:stk500boot.c  **** 			{
 640:stk500boot.c  **** 				//*	toggle the LED
 641:stk500boot.c  **** 				PROGLED_PORT	^=	(1<<PROGLED_PIN);	// turn LED ON
 642:stk500boot.c  **** 			}
 643:stk500boot.c  **** 		#endif
 644:stk500boot.c  **** 		}
 645:stk500boot.c  **** 		boot_state++; // ( if boot_state=1 bootloader received byte from UART, enter bootloader mode)
 646:stk500boot.c  **** 	}
 647:stk500boot.c  **** 
 648:stk500boot.c  **** 
 649:stk500boot.c  **** 	if (boot_state==1)
 650:stk500boot.c  **** 	{
 651:stk500boot.c  **** 		//*	main loop
 652:stk500boot.c  **** 		while (!isLeave)
 653:stk500boot.c  **** 		{
 654:stk500boot.c  **** 			/*
 655:stk500boot.c  **** 			 * Collect received bytes to a complete message
 656:stk500boot.c  **** 			 */
 657:stk500boot.c  **** 			msgParseState	=	ST_START;
 658:stk500boot.c  **** 			while ( msgParseState != ST_PROCESS )
 659:stk500boot.c  **** 			{
 660:stk500boot.c  **** 				if (boot_state==1)
 661:stk500boot.c  **** 				{
 662:stk500boot.c  **** 					boot_state	=	0;
 663:stk500boot.c  **** 					c			=	UART_DATA_REG;
 664:stk500boot.c  **** 				}
 665:stk500boot.c  **** 				else
 666:stk500boot.c  **** 				{
 667:stk500boot.c  **** 				//	c	=	recchar();
 668:stk500boot.c  **** 					c	=	recchar_timeout();
 669:stk500boot.c  **** 
 670:stk500boot.c  **** 				}
 671:stk500boot.c  **** 
 672:stk500boot.c  **** 			#ifdef ENABLE_MONITOR
 673:stk500boot.c  **** 				rcvdCharCntr++;
 674:stk500boot.c  **** 
 675:stk500boot.c  **** 				if ((c == '!')  && (rcvdCharCntr < 10))
 676:stk500boot.c  **** 				{
 677:stk500boot.c  **** 					exPointCntr++;
 678:stk500boot.c  **** 					if (exPointCntr == 3)
 679:stk500boot.c  **** 					{
 680:stk500boot.c  **** 						RunMonitor();
 681:stk500boot.c  **** 						exPointCntr		=	0;	//	reset back to zero so we dont get in an endless loop
 682:stk500boot.c  **** 						isLeave			=	1;
 683:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 684:stk500boot.c  **** 						break;
 685:stk500boot.c  **** 					}
 686:stk500boot.c  **** 				}
 687:stk500boot.c  **** 				else
 688:stk500boot.c  **** 				{
 689:stk500boot.c  **** 					exPointCntr	=	0;
 690:stk500boot.c  **** 				}
 691:stk500boot.c  **** 			#endif
 692:stk500boot.c  **** 
 693:stk500boot.c  **** 				switch (msgParseState)
 694:stk500boot.c  **** 				{
 695:stk500boot.c  **** 					case ST_START:
 696:stk500boot.c  **** 						if ( c == MESSAGE_START )
 697:stk500boot.c  **** 						{
 698:stk500boot.c  **** 							msgParseState	=	ST_GET_SEQ_NUM;
 699:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 700:stk500boot.c  **** 						}
 701:stk500boot.c  **** 						break;
 702:stk500boot.c  **** 
 703:stk500boot.c  **** 					case ST_GET_SEQ_NUM:
 704:stk500boot.c  **** 					#ifdef _FIX_ISSUE_505_
 705:stk500boot.c  **** 						seqNum			=	c;
 706:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_1;
 707:stk500boot.c  **** 						checksum		^=	c;
 708:stk500boot.c  **** 					#else
 709:stk500boot.c  **** 						if ( (c == 1) || (c == seqNum) )
 710:stk500boot.c  **** 						{
 711:stk500boot.c  **** 							seqNum			=	c;
 712:stk500boot.c  **** 							msgParseState	=	ST_MSG_SIZE_1;
 713:stk500boot.c  **** 							checksum		^=	c;
 714:stk500boot.c  **** 						}
 715:stk500boot.c  **** 						else
 716:stk500boot.c  **** 						{
 717:stk500boot.c  **** 							msgParseState	=	ST_START;
 718:stk500boot.c  **** 						}
 719:stk500boot.c  **** 					#endif
 720:stk500boot.c  **** 						break;
 721:stk500boot.c  **** 
 722:stk500boot.c  **** 					case ST_MSG_SIZE_1:
 723:stk500boot.c  **** 						msgLength		=	c<<8;
 724:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 725:stk500boot.c  **** 						checksum		^=	c;
 726:stk500boot.c  **** 						break;
 727:stk500boot.c  **** 
 728:stk500boot.c  **** 					case ST_MSG_SIZE_2:
 729:stk500boot.c  **** 						msgLength		|=	c;
 730:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 731:stk500boot.c  **** 						checksum		^=	c;
 732:stk500boot.c  **** 						break;
 733:stk500boot.c  **** 
 734:stk500boot.c  **** 					case ST_GET_TOKEN:
 735:stk500boot.c  **** 						if ( c == TOKEN )
 736:stk500boot.c  **** 						{
 737:stk500boot.c  **** 							msgParseState	=	ST_GET_DATA;
 738:stk500boot.c  **** 							checksum		^=	c;
 739:stk500boot.c  **** 							ii				=	0;
 740:stk500boot.c  **** 						}
 741:stk500boot.c  **** 						else
 742:stk500boot.c  **** 						{
 743:stk500boot.c  **** 							msgParseState	=	ST_START;
 744:stk500boot.c  **** 						}
 745:stk500boot.c  **** 						break;
 746:stk500boot.c  **** 
 747:stk500boot.c  **** 					case ST_GET_DATA:
 748:stk500boot.c  **** 						msgBuffer[ii++]	=	c;
 749:stk500boot.c  **** 						checksum		^=	c;
 750:stk500boot.c  **** 						if (ii == msgLength )
 751:stk500boot.c  **** 						{
 752:stk500boot.c  **** 							msgParseState	=	ST_GET_CHECK;
 753:stk500boot.c  **** 						}
 754:stk500boot.c  **** 						break;
 755:stk500boot.c  **** 
 756:stk500boot.c  **** 					case ST_GET_CHECK:
 757:stk500boot.c  **** 						if ( c == checksum )
 758:stk500boot.c  **** 						{
 759:stk500boot.c  **** 							msgParseState	=	ST_PROCESS;
 760:stk500boot.c  **** 						}
 761:stk500boot.c  **** 						else
 762:stk500boot.c  **** 						{
 763:stk500boot.c  **** 							msgParseState	=	ST_START;
 764:stk500boot.c  **** 						}
 765:stk500boot.c  **** 						break;
 766:stk500boot.c  **** 				}	//	switch
 767:stk500boot.c  **** 			}	//	while(msgParseState)
 768:stk500boot.c  **** 
 769:stk500boot.c  **** 			/*
 770:stk500boot.c  **** 			 * Now process the STK500 commands, see Atmel Appnote AVR068
 771:stk500boot.c  **** 			 */
 772:stk500boot.c  **** 
 773:stk500boot.c  **** 			switch (msgBuffer[0])
 774:stk500boot.c  **** 			{
 775:stk500boot.c  **** 	#ifndef REMOVE_CMD_SPI_MULTI
 776:stk500boot.c  **** 				case CMD_SPI_MULTI:
 777:stk500boot.c  **** 					{
 778:stk500boot.c  **** 						unsigned char answerByte;
 779:stk500boot.c  **** 						unsigned char flag=0;
 780:stk500boot.c  **** 
 781:stk500boot.c  **** 						if ( msgBuffer[4]== 0x30 )
 782:stk500boot.c  **** 						{
 783:stk500boot.c  **** 							unsigned char signatureIndex	=	msgBuffer[6];
 784:stk500boot.c  **** 
 785:stk500boot.c  **** 							if ( signatureIndex == 0 )
 786:stk500boot.c  **** 							{
 787:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 16) & 0x000000FF;
 788:stk500boot.c  **** 							}
 789:stk500boot.c  **** 							else if ( signatureIndex == 1 )
 790:stk500boot.c  **** 							{
 791:stk500boot.c  **** 								answerByte	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 792:stk500boot.c  **** 							}
 793:stk500boot.c  **** 							else
 794:stk500boot.c  **** 							{
 795:stk500boot.c  **** 								answerByte	=	SIGNATURE_BYTES & 0x000000FF;
 796:stk500boot.c  **** 							}
 797:stk500boot.c  **** 						}
 798:stk500boot.c  **** 						else if ( msgBuffer[4] & 0x50 )
 799:stk500boot.c  **** 						{
 800:stk500boot.c  **** 						//*	Issue 544: 	stk500v2 bootloader doesn't support reading fuses
 801:stk500boot.c  **** 						//*	I cant find the docs that say what these are supposed to be but this was figured out by t
 802:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 803:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 804:stk500boot.c  **** 						//	answerByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 805:stk500boot.c  **** 							if (msgBuffer[4] == 0x50)
 806:stk500boot.c  **** 							{
 807:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 808:stk500boot.c  **** 							}
 809:stk500boot.c  **** 							else if (msgBuffer[4] == 0x58)
 810:stk500boot.c  **** 							{
 811:stk500boot.c  **** 								answerByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 812:stk500boot.c  **** 							}
 813:stk500boot.c  **** 							else
 814:stk500boot.c  **** 							{
 815:stk500boot.c  **** 								answerByte	=	0;
 816:stk500boot.c  **** 							}
 817:stk500boot.c  **** 						}
 818:stk500boot.c  **** 						else
 819:stk500boot.c  **** 						{
 820:stk500boot.c  **** 							answerByte	=	0; // for all others command are not implemented, return dummy value for AVRDUD
 821:stk500boot.c  **** 						}
 822:stk500boot.c  **** 						if ( !flag )
 823:stk500boot.c  **** 						{
 824:stk500boot.c  **** 							msgLength		=	7;
 825:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 826:stk500boot.c  **** 							msgBuffer[2]	=	0;
 827:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 828:stk500boot.c  **** 							msgBuffer[4]	=	0;
 829:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 830:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 831:stk500boot.c  **** 						}
 832:stk500boot.c  **** 					}
 833:stk500boot.c  **** 					break;
 834:stk500boot.c  **** 	#endif
 835:stk500boot.c  **** 				case CMD_SIGN_ON:
 836:stk500boot.c  **** 					msgLength		=	11;
 837:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 838:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 839:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 840:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 841:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 842:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 843:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 844:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 845:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 846:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 847:stk500boot.c  **** 					break;
 848:stk500boot.c  **** 
 849:stk500boot.c  **** 				case CMD_GET_PARAMETER:
 850:stk500boot.c  **** 					{
 851:stk500boot.c  **** 						unsigned char value;
 852:stk500boot.c  **** 
 853:stk500boot.c  **** 						switch(msgBuffer[1])
 854:stk500boot.c  **** 						{
 855:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_LOW:
 856:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_LOW;
 857:stk500boot.c  **** 							break;
 858:stk500boot.c  **** 						case PARAM_BUILD_NUMBER_HIGH:
 859:stk500boot.c  **** 							value	=	CONFIG_PARAM_BUILD_NUMBER_HIGH;
 860:stk500boot.c  **** 							break;
 861:stk500boot.c  **** 						case PARAM_HW_VER:
 862:stk500boot.c  **** 							value	=	CONFIG_PARAM_HW_VER;
 863:stk500boot.c  **** 							break;
 864:stk500boot.c  **** 						case PARAM_SW_MAJOR:
 865:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MAJOR;
 866:stk500boot.c  **** 							break;
 867:stk500boot.c  **** 						case PARAM_SW_MINOR:
 868:stk500boot.c  **** 							value	=	CONFIG_PARAM_SW_MINOR;
 869:stk500boot.c  **** 							break;
 870:stk500boot.c  **** 						default:
 871:stk500boot.c  **** 							value	=	0;
 872:stk500boot.c  **** 							break;
 873:stk500boot.c  **** 						}
 874:stk500boot.c  **** 						msgLength		=	3;
 875:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 876:stk500boot.c  **** 						msgBuffer[2]	=	value;
 877:stk500boot.c  **** 					}
 878:stk500boot.c  **** 					break;
 879:stk500boot.c  **** 
 880:stk500boot.c  **** 				case CMD_LEAVE_PROGMODE_ISP:
 881:stk500boot.c  **** 					isLeave	=	1;
 882:stk500boot.c  **** 					//*	fall thru
 883:stk500boot.c  **** 
 884:stk500boot.c  **** 				case CMD_SET_PARAMETER:
 885:stk500boot.c  **** 				case CMD_ENTER_PROGMODE_ISP:
 886:stk500boot.c  **** 					msgLength		=	2;
 887:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 888:stk500boot.c  **** 					break;
 889:stk500boot.c  **** 
 890:stk500boot.c  **** 				case CMD_READ_SIGNATURE_ISP:
 891:stk500boot.c  **** 					{
 892:stk500boot.c  **** 						unsigned char signatureIndex	=	msgBuffer[4];
 893:stk500boot.c  **** 						unsigned char signature;
 894:stk500boot.c  **** 
 895:stk500boot.c  **** 						if ( signatureIndex == 0 )
 896:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 897:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 898:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 899:stk500boot.c  **** 						else
 900:stk500boot.c  **** 							signature	=	SIGNATURE_BYTES & 0x000000FF;
 901:stk500boot.c  **** 
 902:stk500boot.c  **** 						msgLength		=	4;
 903:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 904:stk500boot.c  **** 						msgBuffer[2]	=	signature;
 905:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 906:stk500boot.c  **** 					}
 907:stk500boot.c  **** 					break;
 908:stk500boot.c  **** 
 909:stk500boot.c  **** 				case CMD_READ_LOCK_ISP:
 910:stk500boot.c  **** 					msgLength		=	4;
 911:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 912:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 913:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 914:stk500boot.c  **** 					break;
 915:stk500boot.c  **** 
 916:stk500boot.c  **** 				case CMD_READ_FUSE_ISP:
 917:stk500boot.c  **** 					{
 918:stk500boot.c  **** 						unsigned char fuseBits;
 919:stk500boot.c  **** 
 920:stk500boot.c  **** 						if ( msgBuffer[2] == 0x50 )
 921:stk500boot.c  **** 						{
 922:stk500boot.c  **** 							if ( msgBuffer[3] == 0x08 )
 923:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 924:stk500boot.c  **** 							else
 925:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_LOW_FUSE_BITS );
 926:stk500boot.c  **** 						}
 927:stk500boot.c  **** 						else
 928:stk500boot.c  **** 						{
 929:stk500boot.c  **** 							fuseBits	=	boot_lock_fuse_bits_get( GET_HIGH_FUSE_BITS );
 930:stk500boot.c  **** 						}
 931:stk500boot.c  **** 						msgLength		=	4;
 932:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 933:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 934:stk500boot.c  **** 						msgBuffer[3]	=	STATUS_CMD_OK;
 935:stk500boot.c  **** 					}
 936:stk500boot.c  **** 					break;
 937:stk500boot.c  **** 
 938:stk500boot.c  **** 	#ifndef REMOVE_PROGRAM_LOCK_BIT_SUPPORT
 939:stk500boot.c  **** 				case CMD_PROGRAM_LOCK_ISP:
 940:stk500boot.c  **** 					{
 941:stk500boot.c  **** 						unsigned char lockBits	=	msgBuffer[4];
 942:stk500boot.c  **** 
 943:stk500boot.c  **** 						lockBits	=	(~lockBits) & 0x3C;	// mask BLBxx bits
 944:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 945:stk500boot.c  **** 						boot_spm_busy_wait();
 946:stk500boot.c  **** 
 947:stk500boot.c  **** 						msgLength		=	3;
 948:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 949:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 950:stk500boot.c  **** 					}
 951:stk500boot.c  **** 					break;
 952:stk500boot.c  **** 	#endif
 953:stk500boot.c  **** 				case CMD_CHIP_ERASE_ISP:
 954:stk500boot.c  **** 					eraseAddress	=	0;
 955:stk500boot.c  **** 					msgLength		=	2;
 956:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 957:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;	//*	isue 543, return FAILED instead of OK
 958:stk500boot.c  **** 					break;
 959:stk500boot.c  **** 
 960:stk500boot.c  **** 				case CMD_LOAD_ADDRESS:
 961:stk500boot.c  **** 	#if defined(RAMPZ)
 962:stk500boot.c  **** 					address	=	( ((address_t)(msgBuffer[1])<<24)|((address_t)(msgBuffer[2])<<16)|((address_t)(msgBu
 963:stk500boot.c  **** 	#else
 964:stk500boot.c  **** 					address	=	( ((msgBuffer[3])<<8)|(msgBuffer[4]) )<<1;		//convert word to byte address
 965:stk500boot.c  **** 	#endif
 966:stk500boot.c  **** 					msgLength		=	2;
 967:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 968:stk500boot.c  **** 					break;
 969:stk500boot.c  **** 
 970:stk500boot.c  **** 				case CMD_PROGRAM_FLASH_ISP:
 971:stk500boot.c  **** 				case CMD_PROGRAM_EEPROM_ISP:
 972:stk500boot.c  **** 					{
 973:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
 974:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 975:stk500boot.c  **** 						unsigned int	data;
 976:stk500boot.c  **** 						unsigned char	highByte, lowByte;
 977:stk500boot.c  **** 						address_t		tempaddress	=	address;
 978:stk500boot.c  **** 
 979:stk500boot.c  **** 
 980:stk500boot.c  **** 						if ( msgBuffer[0] == CMD_PROGRAM_FLASH_ISP )
 981:stk500boot.c  **** 						{
 982:stk500boot.c  **** 							// erase only main section (bootloader protection)
 983:stk500boot.c  **** 							if (eraseAddress < APP_END )
 984:stk500boot.c  **** 							{
 985:stk500boot.c  **** 								boot_page_erase(eraseAddress);	// Perform page erase
 986:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 987:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 988:stk500boot.c  **** 							}
 989:stk500boot.c  **** 
 990:stk500boot.c  **** 							/* Write FLASH */
 991:stk500boot.c  **** 							do {
 992:stk500boot.c  **** 								lowByte		=	*p++;
 993:stk500boot.c  **** 								highByte 	=	*p++;
 994:stk500boot.c  **** 
 995:stk500boot.c  **** 								data		=	(highByte << 8) | lowByte;
 996:stk500boot.c  **** 								boot_page_fill(address,data);
 997:stk500boot.c  **** 
 998:stk500boot.c  **** 								address	=	address + 2;	// Select next word in memory
 999:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
1000:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
1001:stk500boot.c  **** 
1002:stk500boot.c  **** 							boot_page_write(tempaddress);
1003:stk500boot.c  **** 							boot_spm_busy_wait();
1004:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
1005:stk500boot.c  **** 						}
1006:stk500boot.c  **** 						else
1007:stk500boot.c  **** 						{
1008:stk500boot.c  **** 							//*	issue 543, this should work, It has not been tested.
1009:stk500boot.c  **** 							uint16_t ii = address >> 1;
1010:stk500boot.c  **** 							/* write EEPROM */
1011:stk500boot.c  **** 							while (size) {
1012:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
1013:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
1014:stk500boot.c  **** 								ii++;
1015:stk500boot.c  **** 								size--;
1016:stk500boot.c  **** 							}
1017:stk500boot.c  **** 						}
1018:stk500boot.c  **** 						msgLength		=	2;
1019:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
1020:stk500boot.c  **** 					}
1021:stk500boot.c  **** 					break;
1022:stk500boot.c  **** 
1023:stk500boot.c  **** 				case CMD_READ_FLASH_ISP:
1024:stk500boot.c  **** 				case CMD_READ_EEPROM_ISP:
1025:stk500boot.c  **** 					{
1026:stk500boot.c  **** 						unsigned int	size	=	((msgBuffer[1])<<8) | msgBuffer[2];
1027:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
1028:stk500boot.c  **** 						msgLength				=	size+3;
1029:stk500boot.c  **** 
1030:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1031:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
1032:stk500boot.c  **** 						{
1033:stk500boot.c  **** 							unsigned int data;
1034:stk500boot.c  **** 
1035:stk500boot.c  **** 							// Read FLASH
1036:stk500boot.c  **** 							do {
1037:stk500boot.c  **** 						//#if defined(RAMPZ)
1038:stk500boot.c  **** 						#if (FLASHEND > 0x10000)
1039:stk500boot.c  **** 								data	=	pgm_read_word_far(address);
1040:stk500boot.c  **** 						#else
1041:stk500boot.c  **** 								data	=	pgm_read_word_near(address);
1042:stk500boot.c  **** 						#endif
1043:stk500boot.c  **** 								*p++	=	(unsigned char)data;		//LSB
1044:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
1045:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
1046:stk500boot.c  **** 								size	-=	2;
1047:stk500boot.c  **** 							}while (size);
1048:stk500boot.c  **** 						}
1049:stk500boot.c  **** 						else
1050:stk500boot.c  **** 						{
1051:stk500boot.c  **** 							/* Read EEPROM */
1052:stk500boot.c  **** 							do {
1053:stk500boot.c  **** 								EEARL	=	address;			// Setup EEPROM address
1054:stk500boot.c  **** 								EEARH	=	((address >> 8));
1055:stk500boot.c  **** 								address++;					// Select next EEPROM byte
1056:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
1057:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
1058:stk500boot.c  **** 								size--;
1059:stk500boot.c  **** 							} while (size);
1060:stk500boot.c  **** 						}
1061:stk500boot.c  **** 						*p++	=	STATUS_CMD_OK;
1062:stk500boot.c  **** 					}
1063:stk500boot.c  **** 					break;
1064:stk500boot.c  **** 
1065:stk500boot.c  **** 				default:
1066:stk500boot.c  **** 					msgLength		=	2;
1067:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
1068:stk500boot.c  **** 					break;
1069:stk500boot.c  **** 			}
1070:stk500boot.c  **** 
1071:stk500boot.c  **** 			/*
1072:stk500boot.c  **** 			 * Now send answer message back
1073:stk500boot.c  **** 			 */
1074:stk500boot.c  **** 			sendchar(MESSAGE_START);
1075:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
1076:stk500boot.c  **** 
1077:stk500boot.c  **** 			sendchar(seqNum);
1078:stk500boot.c  **** 			checksum	^=	seqNum;
1079:stk500boot.c  **** 
1080:stk500boot.c  **** 			c			=	((msgLength>>8)&0xFF);
1081:stk500boot.c  **** 			sendchar(c);
1082:stk500boot.c  **** 			checksum	^=	c;
1083:stk500boot.c  **** 
1084:stk500boot.c  **** 			c			=	msgLength&0x00FF;
1085:stk500boot.c  **** 			sendchar(c);
1086:stk500boot.c  **** 			checksum ^= c;
1087:stk500boot.c  **** 
1088:stk500boot.c  **** 			sendchar(TOKEN);
1089:stk500boot.c  **** 			checksum ^= TOKEN;
1090:stk500boot.c  **** 
1091:stk500boot.c  **** 			p	=	msgBuffer;
1092:stk500boot.c  **** 			while ( msgLength )
1093:stk500boot.c  **** 			{
1094:stk500boot.c  **** 				c	=	*p++;
1095:stk500boot.c  **** 				sendchar(c);
1096:stk500boot.c  **** 				checksum ^=c;
1097:stk500boot.c  **** 				msgLength--;
1098:stk500boot.c  **** 			}
1099:stk500boot.c  **** 			sendchar(checksum);
1100:stk500boot.c  **** 			seqNum++;
1101:stk500boot.c  **** 
1102:stk500boot.c  **** 		#ifndef REMOVE_BOOTLOADER_LED
1103:stk500boot.c  **** 			//*	<MLS>	toggle the LED
1104:stk500boot.c  **** 			PROGLED_PORT	^=	(1<<PROGLED_PIN);	// active high LED ON
1105:stk500boot.c  **** 		#endif
1106:stk500boot.c  **** 
1107:stk500boot.c  **** 		}
1108:stk500boot.c  **** 	}
1109:stk500boot.c  **** 
1110:stk500boot.c  **** #ifdef _DEBUG_WITH_LEDS_
1111:stk500boot.c  **** 	//*	this is for debugging it can be removed
1112:stk500boot.c  **** 	for (ii=0; ii<10; ii++)
1113:stk500boot.c  **** 	{
1114:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1115:stk500boot.c  **** 		delay_ms(200);
1116:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1117:stk500boot.c  **** 		delay_ms(200);
1118:stk500boot.c  **** 	}
1119:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1120:stk500boot.c  **** #endif
1121:stk500boot.c  **** 
1122:stk500boot.c  **** #ifdef _DEBUG_SERIAL_
1123:stk500boot.c  **** 	sendchar('j');
1124:stk500boot.c  **** //	sendchar('u');
1125:stk500boot.c  **** //	sendchar('m');
1126:stk500boot.c  **** //	sendchar('p');
1127:stk500boot.c  **** //	sendchar(' ');
1128:stk500boot.c  **** //	sendchar('u');
1129:stk500boot.c  **** //	sendchar('s');
1130:stk500boot.c  **** //	sendchar('r');
1131:stk500boot.c  **** 	sendchar(0x0d);
1132:stk500boot.c  **** 	sendchar(0x0a);
1133:stk500boot.c  **** 
1134:stk500boot.c  **** 	delay_ms(100);
1135:stk500boot.c  **** #endif
1136:stk500boot.c  **** 
1137:stk500boot.c  **** 
1138:stk500boot.c  **** #ifndef REMOVE_BOOTLOADER_LED
1139:stk500boot.c  **** 	PROGLED_DDR		&=	~(1<<PROGLED_PIN);	// set to default
1140:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
1141:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
1142:stk500boot.c  **** 	delay_ms(100);							// delay after exit
1143:stk500boot.c  **** #endif
1144:stk500boot.c  **** 
1145:stk500boot.c  **** 
1146:stk500boot.c  **** 	asm volatile ("nop");			// wait until port has changed
1147:stk500boot.c  **** 
1148:stk500boot.c  **** 	/*
1149:stk500boot.c  **** 	 * Now leave bootloader
1150:stk500boot.c  **** 	 */
1151:stk500boot.c  **** 
1152:stk500boot.c  **** 	UART_STATUS_REG	&=	0xfd;
1153:stk500boot.c  **** 	boot_rww_enable();				// enable application section
1154:stk500boot.c  **** 
1155:stk500boot.c  **** 
1156:stk500boot.c  **** 	asm volatile(
1157:stk500boot.c  **** 			"clr	r30		\n\t"
1158:stk500boot.c  **** 			"clr	r31		\n\t"
1159:stk500boot.c  **** 			"ijmp	\n\t"
1160:stk500boot.c  **** 			);
1161:stk500boot.c  **** //	asm volatile ( "push r1" "\n\t"		// Jump to Reset vector in Application Section
1162:stk500boot.c  **** //					"push r1" "\n\t"
1163:stk500boot.c  **** //					"ret"	 "\n\t"
1164:stk500boot.c  **** //					::);
1165:stk500boot.c  **** 
1166:stk500boot.c  **** 	 /*
1167:stk500boot.c  **** 	 * Never return to stop GCC to generate exit return code
1168:stk500boot.c  **** 	 * Actually we will never reach this point, but the compiler doesn't
1169:stk500boot.c  **** 	 * understand this
1170:stk500boot.c  **** 	 */
1171:stk500boot.c  **** 	for(;;);
1172:stk500boot.c  **** }
1173:stk500boot.c  **** 
1174:stk500boot.c  **** /*
1175:stk500boot.c  **** base address = f800
1176:stk500boot.c  **** 
1177:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1178:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1179:stk500boot.c  **** avrdude: safemode: hfuse reads as DA
1180:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1181:stk500boot.c  **** avrdude>
1182:stk500boot.c  **** 
1183:stk500boot.c  **** 
1184:stk500boot.c  **** base address = f000
1185:stk500boot.c  **** avrdude: Device signature = 0x1e9703
1186:stk500boot.c  **** avrdude: safemode: lfuse reads as FF
1187:stk500boot.c  **** avrdude: safemode: hfuse reads as D8
1188:stk500boot.c  **** avrdude: safemode: efuse reads as F5
1189:stk500boot.c  **** avrdude>
1190:stk500boot.c  **** */
1191:stk500boot.c  **** 
1192:stk500boot.c  **** //************************************************************************
1193:stk500boot.c  **** #ifdef ENABLE_MONITOR
1194:stk500boot.c  **** #include	<math.h>
1195:stk500boot.c  **** 
1196:stk500boot.c  **** unsigned long	gRamIndex;
1197:stk500boot.c  **** unsigned long	gFlashIndex;
1198:stk500boot.c  **** unsigned long	gEepromIndex;
1199:stk500boot.c  **** 
1200:stk500boot.c  **** 
1201:stk500boot.c  **** #define	true	1
1202:stk500boot.c  **** #define	false	0
1203:stk500boot.c  **** 
1204:stk500boot.c  **** #include	"avr_cpunames.h"
1205:stk500boot.c  **** 
1206:stk500boot.c  **** #ifndef _AVR_CPU_NAME_
1207:stk500boot.c  **** 	#error cpu name not defined
1208:stk500boot.c  **** #endif
1209:stk500boot.c  **** 
1210:stk500boot.c  **** #ifdef _VECTORS_SIZE
1211:stk500boot.c  **** 	#define	kInterruptVectorCount (_VECTORS_SIZE / 4)
1212:stk500boot.c  **** #else
1213:stk500boot.c  **** 	#define	kInterruptVectorCount 23
1214:stk500boot.c  **** #endif
1215:stk500boot.c  **** 
1216:stk500boot.c  **** 
1217:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt);
1218:stk500boot.c  **** 
1219:stk500boot.c  **** #ifdef _AVR_CPU_NAME_
1220:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	_AVR_CPU_NAME_;
1221:stk500boot.c  **** #else
1222:stk500boot.c  **** 	const char	gTextMsg_CPU_Name[]			PROGMEM	=	"UNKNOWN";
1223:stk500boot.c  **** #endif
1224:stk500boot.c  **** 
1225:stk500boot.c  **** 	const char	gTextMsg_Explorer[]			PROGMEM	=	"Arduino explorer stk500V2 by MLS";
1226:stk500boot.c  **** 	const char	gTextMsg_Prompt[]			PROGMEM	=	"Bootloader>";
1227:stk500boot.c  **** 	const char	gTextMsg_HUH[]				PROGMEM	=	"Huh?";
1228:stk500boot.c  **** 	const char	gTextMsg_COMPILED_ON[]		PROGMEM	=	"Compiled on = ";
1229:stk500boot.c  **** 	const char	gTextMsg_CPU_Type[]			PROGMEM	=	"CPU Type    = ";
1230:stk500boot.c  **** 	const char	gTextMsg_AVR_ARCH[]			PROGMEM	=	"__AVR_ARCH__= ";
1231:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC[]			PROGMEM	=	"AVR LibC Ver= ";
1232:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION[]		PROGMEM	=	"GCC Version = ";
1233:stk500boot.c  **** 	const char	gTextMsg_CPU_SIGNATURE[]	PROGMEM	=	"CPU ID      = ";
1234:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOW[]	PROGMEM	=	"Low fuse    = ";
1235:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_HIGH[]	PROGMEM	=	"High fuse   = ";
1236:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_EXT[]	PROGMEM	=	"Ext fuse    = ";
1237:stk500boot.c  **** 	const char	gTextMsg_FUSE_BYTE_LOCK[]	PROGMEM	=	"Lock fuse   = ";
1238:stk500boot.c  **** 	const char	gTextMsg_GCC_DATE_STR[]		PROGMEM	=	__DATE__;
1239:stk500boot.c  **** 	const char	gTextMsg_AVR_LIBC_VER_STR[]	PROGMEM	=	__AVR_LIBC_VERSION_STRING__;
1240:stk500boot.c  **** 	const char	gTextMsg_GCC_VERSION_STR[]	PROGMEM	=	__VERSION__;
1241:stk500boot.c  **** 	const char	gTextMsg_VECTOR_HEADER[]	PROGMEM	=	"V#   ADDR   op code     instruction addr   Interrup
1242:stk500boot.c  **** 	const char	gTextMsg_noVector[]			PROGMEM	=	"no vector";
1243:stk500boot.c  **** 	const char	gTextMsg_rjmp[]				PROGMEM	=	"rjmp  ";
1244:stk500boot.c  **** 	const char	gTextMsg_jmp[]				PROGMEM	=	"jmp ";
1245:stk500boot.c  **** 	const char	gTextMsg_WHAT_PORT[]		PROGMEM	=	"What port:";
1246:stk500boot.c  **** 	const char	gTextMsg_PortNotSupported[]	PROGMEM	=	"Port not supported";
1247:stk500boot.c  **** 	const char	gTextMsg_MustBeLetter[]		PROGMEM	=	"Must be a letter";
1248:stk500boot.c  **** 	const char	gTextMsg_SPACE[]			PROGMEM	=	" ";
1249:stk500boot.c  **** 	const char	gTextMsg_WriteToEEprom[]	PROGMEM	=	"Writting EE";
1250:stk500boot.c  **** 	const char	gTextMsg_ReadingEEprom[]	PROGMEM	=	"Reading EE";
1251:stk500boot.c  **** 	const char	gTextMsg_EEPROMerrorCnt[]	PROGMEM	=	"EE err cnt=";
1252:stk500boot.c  **** 	const char	gTextMsg_PORT[]				PROGMEM	=	"PORT";
1253:stk500boot.c  **** 
1254:stk500boot.c  **** 
1255:stk500boot.c  **** //************************************************************************
1256:stk500boot.c  **** //*	Help messages
1257:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_0[]		PROGMEM	=	"0=Zero addr";
1258:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_QM[]		PROGMEM	=	"?=CPU stats";
1259:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_AT[]		PROGMEM	=	"@=EEPROM test";
1260:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_B[]		PROGMEM	=	"B=Blink LED";
1261:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_E[]		PROGMEM	=	"E=Dump EEPROM";
1262:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_F[]		PROGMEM	=	"F=Dump FLASH";
1263:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_H[]		PROGMEM	=	"H=Help";
1264:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_L[]		PROGMEM	=	"L=List I/O Ports";
1265:stk500boot.c  **** //	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit & jump to user pgm";
1266:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Q[]		PROGMEM	=	"Q=Quit";
1267:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_R[]		PROGMEM	=	"R=Dump RAM";
1268:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_V[]		PROGMEM	=	"V=show interrupt Vectors";
1269:stk500boot.c  **** 	const char	gTextMsg_HELP_MSG_Y[]		PROGMEM	=	"Y=Port blink";
1270:stk500boot.c  **** 
1271:stk500boot.c  **** 	const char	gTextMsg_END[]				PROGMEM	=	"*";
1272:stk500boot.c  **** 
1273:stk500boot.c  **** 
1274:stk500boot.c  **** //************************************************************************
1275:stk500boot.c  **** void	PrintFromPROGMEM(const void *dataPtr, unsigned char offset)
1276:stk500boot.c  **** {
 162               		.loc 1 1276 0
 163               		.cfi_startproc
 164               	.LVL8:
 165 0036 CF93      		push r28
 166               	.LCFI0:
 167               		.cfi_def_cfa_offset 4
 168               		.cfi_offset 28, -3
 169 0038 DF93      		push r29
 170               	.LCFI1:
 171               		.cfi_def_cfa_offset 5
 172               		.cfi_offset 29, -4
 173               	/* prologue: function */
 174               	/* frame size = 0 */
 175               	/* stack size = 2 */
 176               	.L__stack_usage = 2
1277:stk500boot.c  **** char	theChar;
1278:stk500boot.c  **** 
1279:stk500boot.c  **** 	dataPtr		+=	offset;
 177               		.loc 1 1279 0
 178 003a EC01      		movw r28,r24
 179 003c C60F      		add r28,r22
 180 003e D11D      		adc r29,__zero_reg__
 181               	.LVL9:
 182               	.L16:
 183               	.LBB53:
1280:stk500boot.c  **** 
1281:stk500boot.c  **** 	do {
1282:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1283:stk500boot.c  **** 		theChar	=	pgm_read_byte_far((uint16_t)dataPtr++);
 184               		.loc 1 1283 0
 185 0040 AE01      		movw r20,r28
 186 0042 60E0      		ldi r22,0
 187 0044 70E0      		ldi r23,0
 188               	/* #APP */
 189               	 ;  1283 "stk500boot.c" 1
 190 0046 6BBF      		out 59, r22
 191 0048 FA01      		movw r30, r20
 192 004a 8791      		elpm r24, Z+
 193               		
 194               	 ;  0 "" 2
 195               	.LVL10:
 196               	/* #NOAPP */
 197               	.LBE53:
1284:stk500boot.c  **** 	#else
1285:stk500boot.c  **** 		theChar	=	pgm_read_byte_near((uint16_t)dataPtr++);
1286:stk500boot.c  **** 	#endif
1287:stk500boot.c  **** 		if (theChar != 0)
 198               		.loc 1 1287 0
 199 004c 8823      		tst r24
 200 004e 01F0      		breq .L14
 201               	.LVL11:
 202               	.LBB54:
1283:stk500boot.c  **** 	#else
 203               		.loc 1 1283 0
 204 0050 2196      		adiw r28,1
 205               	.LVL12:
 206               	.LBE54:
1288:stk500boot.c  **** 		{
1289:stk500boot.c  **** 			sendchar(theChar);
 207               		.loc 1 1289 0
 208 0052 0E94 0000 		call sendchar
 209               	.LVL13:
 210 0056 00C0      		rjmp .L16
 211               	.LVL14:
 212               	.L14:
 213               	/* epilogue start */
1290:stk500boot.c  **** 		}
1291:stk500boot.c  **** 	} while (theChar != 0);
1292:stk500boot.c  **** }
 214               		.loc 1 1292 0
 215 0058 DF91      		pop r29
 216 005a CF91      		pop r28
 217 005c 0895      		ret
 218               		.cfi_endproc
 219               	.LFE18:
 221               	.global	PrintNewLine
 223               	PrintNewLine:
 224               	.LFB19:
1293:stk500boot.c  **** 
1294:stk500boot.c  **** //************************************************************************
1295:stk500boot.c  **** void	PrintNewLine(void)
1296:stk500boot.c  **** {
 225               		.loc 1 1296 0
 226               		.cfi_startproc
 227               	/* prologue: function */
 228               	/* frame size = 0 */
 229               	/* stack size = 0 */
 230               	.L__stack_usage = 0
1297:stk500boot.c  **** 	sendchar(0x0d);
 231               		.loc 1 1297 0
 232 005e 8DE0      		ldi r24,lo8(13)
 233 0060 0E94 0000 		call sendchar
 234               	.LVL15:
1298:stk500boot.c  **** 	sendchar(0x0a);
 235               		.loc 1 1298 0
 236 0064 8AE0      		ldi r24,lo8(10)
 237 0066 0C94 0000 		jmp sendchar
 238               	.LVL16:
 239               		.cfi_endproc
 240               	.LFE19:
 242               		.section	.text.unlikely
 244               	PrintAvailablePort:
 245               	.LFB29:
1299:stk500boot.c  **** }
1300:stk500boot.c  **** 
1301:stk500boot.c  **** 
1302:stk500boot.c  **** //************************************************************************
1303:stk500boot.c  **** void	PrintFromPROGMEMln(const void *dataPtr, unsigned char offset)
1304:stk500boot.c  **** {
1305:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
1306:stk500boot.c  **** 
1307:stk500boot.c  **** 	PrintNewLine();
1308:stk500boot.c  **** }
1309:stk500boot.c  **** 
1310:stk500boot.c  **** 
1311:stk500boot.c  **** //************************************************************************
1312:stk500boot.c  **** void	PrintString(char *textString)
1313:stk500boot.c  **** {
1314:stk500boot.c  **** char	theChar;
1315:stk500boot.c  **** int		ii;
1316:stk500boot.c  **** 
1317:stk500boot.c  **** 	theChar		=	1;
1318:stk500boot.c  **** 	ii			=	0;
1319:stk500boot.c  **** 	while (theChar != 0)
1320:stk500boot.c  **** 	{
1321:stk500boot.c  **** 		theChar	=	textString[ii];
1322:stk500boot.c  **** 		if (theChar != 0)
1323:stk500boot.c  **** 		{
1324:stk500boot.c  **** 			sendchar(theChar);
1325:stk500boot.c  **** 		}
1326:stk500boot.c  **** 		ii++;
1327:stk500boot.c  **** 	}
1328:stk500boot.c  **** }
1329:stk500boot.c  **** 
1330:stk500boot.c  **** //************************************************************************
1331:stk500boot.c  **** void	PrintHexByte(unsigned char theByte)
1332:stk500boot.c  **** {
1333:stk500boot.c  **** char	theChar;
1334:stk500boot.c  **** 
1335:stk500boot.c  **** 	theChar	=	0x30 + ((theByte >> 4) & 0x0f);
1336:stk500boot.c  **** 	if (theChar > 0x39)
1337:stk500boot.c  **** 	{
1338:stk500boot.c  **** 		theChar	+=	7;
1339:stk500boot.c  **** 	}
1340:stk500boot.c  **** 	sendchar(theChar );
1341:stk500boot.c  **** 
1342:stk500boot.c  **** 	theChar	=	0x30 + (theByte & 0x0f);
1343:stk500boot.c  **** 	if (theChar > 0x39)
1344:stk500boot.c  **** 	{
1345:stk500boot.c  **** 		theChar	+=	7;
1346:stk500boot.c  **** 	}
1347:stk500boot.c  **** 	sendchar(theChar );
1348:stk500boot.c  **** }
1349:stk500boot.c  **** 
1350:stk500boot.c  **** //************************************************************************
1351:stk500boot.c  **** void	PrintDecInt(int theNumber, int digitCnt)
1352:stk500boot.c  **** {
1353:stk500boot.c  **** int	theChar;
1354:stk500boot.c  **** int	myNumber;
1355:stk500boot.c  **** 
1356:stk500boot.c  **** 	myNumber	=	theNumber;
1357:stk500boot.c  **** 
1358:stk500boot.c  **** 	if ((myNumber > 100) || (digitCnt >= 3))
1359:stk500boot.c  **** 	{
1360:stk500boot.c  **** 		theChar		=	0x30 + myNumber / 100;
1361:stk500boot.c  **** 		sendchar(theChar );
1362:stk500boot.c  **** 	}
1363:stk500boot.c  **** 
1364:stk500boot.c  **** 	if ((myNumber > 10) || (digitCnt >= 2))
1365:stk500boot.c  **** 	{
1366:stk500boot.c  **** 		theChar	=	0x30  + ((myNumber % 100) / 10 );
1367:stk500boot.c  **** 		sendchar(theChar );
1368:stk500boot.c  **** 	}
1369:stk500boot.c  **** 	theChar	=	0x30 + (myNumber % 10);
1370:stk500boot.c  **** 	sendchar(theChar );
1371:stk500boot.c  **** }
1372:stk500boot.c  **** 
1373:stk500boot.c  **** 
1374:stk500boot.c  **** 
1375:stk500boot.c  **** 
1376:stk500boot.c  **** //************************************************************************
1377:stk500boot.c  **** static void	PrintCPUstats(void)
1378:stk500boot.c  **** {
1379:stk500boot.c  **** unsigned char fuseByte;
1380:stk500boot.c  **** 
1381:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
1382:stk500boot.c  **** 
1383:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_COMPILED_ON, 0);
1384:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
1385:stk500boot.c  **** 
1386:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_Type, 0);
1387:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1388:stk500boot.c  **** 
1389:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_ARCH, 0);
1390:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
1391:stk500boot.c  **** 	PrintNewLine();
1392:stk500boot.c  **** 
1393:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_GCC_VERSION, 0);
1394:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
1395:stk500boot.c  **** 
1396:stk500boot.c  **** 	//*	these can be found in avr/version.h
1397:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_AVR_LIBC, 0);
1398:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
1399:stk500boot.c  **** 
1400:stk500boot.c  **** #if defined(SIGNATURE_0)
1401:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_CPU_SIGNATURE, 0);
1402:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
1403:stk500boot.c  **** 	PrintHexByte(SIGNATURE_0);
1404:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
1405:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
1406:stk500boot.c  **** 	PrintNewLine();
1407:stk500boot.c  **** #endif
1408:stk500boot.c  **** 
1409:stk500boot.c  **** 
1410:stk500boot.c  **** #if defined(GET_LOW_FUSE_BITS)
1411:stk500boot.c  **** 	//*	fuse settings
1412:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOW, 0);
1413:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
1414:stk500boot.c  **** 	PrintHexByte(fuseByte);
1415:stk500boot.c  **** 	PrintNewLine();
1416:stk500boot.c  **** 
1417:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_HIGH, 0);
1418:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
1419:stk500boot.c  **** 	PrintHexByte(fuseByte);
1420:stk500boot.c  **** 	PrintNewLine();
1421:stk500boot.c  **** 
1422:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_EXT, 0);
1423:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
1424:stk500boot.c  **** 	PrintHexByte(fuseByte);
1425:stk500boot.c  **** 	PrintNewLine();
1426:stk500boot.c  **** 
1427:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_FUSE_BYTE_LOCK, 0);
1428:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
1429:stk500boot.c  **** 	PrintHexByte(fuseByte);
1430:stk500boot.c  **** 	PrintNewLine();
1431:stk500boot.c  **** 
1432:stk500boot.c  **** #endif
1433:stk500boot.c  **** 
1434:stk500boot.c  **** }
1435:stk500boot.c  **** 
1436:stk500boot.c  **** 
1437:stk500boot.c  **** //************************************************************************
1438:stk500boot.c  **** static void BlinkLED(void)
1439:stk500boot.c  **** {
1440:stk500boot.c  **** 	PROGLED_DDR		|=	(1<<PROGLED_PIN);
1441:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
1442:stk500boot.c  **** 
1443:stk500boot.c  **** 	while (!Serial_Available())
1444:stk500boot.c  **** 	{
1445:stk500boot.c  **** 		PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// turn LED off
1446:stk500boot.c  **** 		delay_ms(100);
1447:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
1448:stk500boot.c  **** 		delay_ms(100);
1449:stk500boot.c  **** 	}
1450:stk500boot.c  **** 	recchar();	//	get the char out of the buffer
1451:stk500boot.c  **** }
1452:stk500boot.c  **** 
1453:stk500boot.c  **** enum
1454:stk500boot.c  **** {
1455:stk500boot.c  **** 	kDUMP_FLASH	=	0,
1456:stk500boot.c  **** 	kDUMP_EEPROM,
1457:stk500boot.c  **** 	kDUMP_RAM
1458:stk500boot.c  **** };
1459:stk500boot.c  **** 
1460:stk500boot.c  **** //************************************************************************
1461:stk500boot.c  **** static void	DumpHex(unsigned char dumpWhat, unsigned long startAddress, unsigned char numRows)
1462:stk500boot.c  **** {
1463:stk500boot.c  **** unsigned long	myAddressPointer;
1464:stk500boot.c  **** uint8_t			ii;
1465:stk500boot.c  **** unsigned char	theValue;
1466:stk500boot.c  **** char			asciiDump[18];
1467:stk500boot.c  **** unsigned char	*ramPtr;
1468:stk500boot.c  **** 
1469:stk500boot.c  **** 
1470:stk500boot.c  **** 	ramPtr				=	0;
1471:stk500boot.c  **** 	theValue			=	0;
1472:stk500boot.c  **** 	myAddressPointer	=	startAddress;
1473:stk500boot.c  **** 	while (numRows > 0)
1474:stk500boot.c  **** 	{
1475:stk500boot.c  **** 		if (myAddressPointer > 0x10000)
1476:stk500boot.c  **** 		{
1477:stk500boot.c  **** 			PrintHexByte((myAddressPointer >> 16) & 0x00ff);
1478:stk500boot.c  **** 		}
1479:stk500boot.c  **** 		PrintHexByte((myAddressPointer >> 8) & 0x00ff);
1480:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
1481:stk500boot.c  **** 		sendchar(0x20);
1482:stk500boot.c  **** 		sendchar('-');
1483:stk500boot.c  **** 		sendchar(0x20);
1484:stk500boot.c  **** 
1485:stk500boot.c  **** 		asciiDump[0]		=	0;
1486:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
1487:stk500boot.c  **** 		{
1488:stk500boot.c  **** 			switch(dumpWhat)
1489:stk500boot.c  **** 			{
1490:stk500boot.c  **** 				case kDUMP_FLASH:
1491:stk500boot.c  **** 				#if (FLASHEND > 0x10000)
1492:stk500boot.c  **** 					theValue	=	pgm_read_byte_far(myAddressPointer);
1493:stk500boot.c  **** 				#else
1494:stk500boot.c  **** 					theValue	=	pgm_read_byte_near(myAddressPointer);
1495:stk500boot.c  **** 				#endif
1496:stk500boot.c  **** 					break;
1497:stk500boot.c  **** 
1498:stk500boot.c  **** 				case kDUMP_EEPROM:
1499:stk500boot.c  **** 					theValue	=	eeprom_read_byte((uint8_t *)(uint16_t)myAddressPointer);
1500:stk500boot.c  **** 					break;
1501:stk500boot.c  **** 
1502:stk500boot.c  **** 				case kDUMP_RAM:
1503:stk500boot.c  **** 					theValue	=	ramPtr[myAddressPointer];
1504:stk500boot.c  **** 					break;
1505:stk500boot.c  **** 
1506:stk500boot.c  **** 			}
1507:stk500boot.c  **** 			PrintHexByte(theValue);
1508:stk500boot.c  **** 			sendchar(0x20);
1509:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
1510:stk500boot.c  **** 			{
1511:stk500boot.c  **** 				asciiDump[ii % 16]	=	theValue;
1512:stk500boot.c  **** 			}
1513:stk500boot.c  **** 			else
1514:stk500boot.c  **** 			{
1515:stk500boot.c  **** 				asciiDump[ii % 16]	=	'.';
1516:stk500boot.c  **** 			}
1517:stk500boot.c  **** 
1518:stk500boot.c  **** 			myAddressPointer++;
1519:stk500boot.c  **** 		}
1520:stk500boot.c  **** 		asciiDump[16]	=	0;
1521:stk500boot.c  **** 		PrintString(asciiDump);
1522:stk500boot.c  **** 		PrintNewLine();
1523:stk500boot.c  **** 
1524:stk500boot.c  **** 		numRows--;
1525:stk500boot.c  **** 	}
1526:stk500boot.c  **** }
1527:stk500boot.c  **** 
1528:stk500boot.c  **** 
1529:stk500boot.c  **** 
1530:stk500boot.c  **** //************************************************************************
1531:stk500boot.c  **** //*	returns amount of extended memory
1532:stk500boot.c  **** static void	EEPROMtest(void)
1533:stk500boot.c  **** {
1534:stk500boot.c  **** int		ii;
1535:stk500boot.c  **** char	theChar;
1536:stk500boot.c  **** char	theEEPROMchar;
1537:stk500boot.c  **** int		errorCount;
1538:stk500boot.c  **** 
1539:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_WriteToEEprom, 0);
1540:stk500boot.c  **** 	PrintNewLine();
1541:stk500boot.c  **** 	ii			=	0;
1542:stk500boot.c  **** #if (FLASHEND > 0x10000)
1543:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1544:stk500boot.c  **** #else
1545:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near(((uint16_t)gTextMsg_Explorer) + ii)) != '*') && (ii < 512))
1546:stk500boot.c  **** #endif
1547:stk500boot.c  **** 	{
1548:stk500boot.c  **** 		eeprom_write_byte((uint8_t *)ii, theChar);
1549:stk500boot.c  **** 		if (theChar == 0)
1550:stk500boot.c  **** 		{
1551:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1552:stk500boot.c  **** 		}
1553:stk500boot.c  **** 		else
1554:stk500boot.c  **** 		{
1555:stk500boot.c  **** 			sendchar(theChar);
1556:stk500boot.c  **** 		}
1557:stk500boot.c  **** 		ii++;
1558:stk500boot.c  **** 	}
1559:stk500boot.c  **** 
1560:stk500boot.c  **** 	//*	no go back through and test
1561:stk500boot.c  **** 	PrintNewLine();
1562:stk500boot.c  **** 	PrintNewLine();
1563:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
1564:stk500boot.c  **** 	PrintNewLine();
1565:stk500boot.c  **** 	errorCount	=	0;
1566:stk500boot.c  **** 	ii			=	0;
1567:stk500boot.c  **** #if (FLASHEND > 0x10000)
1568:stk500boot.c  **** 	while (((theChar = pgm_read_byte_far((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1569:stk500boot.c  **** #else
1570:stk500boot.c  **** 	while (((theChar = pgm_read_byte_near((uint16_t)gTextMsg_Explorer + ii)) != '*') && (ii < 512))
1571:stk500boot.c  **** #endif
1572:stk500boot.c  **** 	{
1573:stk500boot.c  **** 		theEEPROMchar	=	eeprom_read_byte((uint8_t *)ii);
1574:stk500boot.c  **** 		if (theEEPROMchar == 0)
1575:stk500boot.c  **** 		{
1576:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_SPACE, 0);
1577:stk500boot.c  **** 		}
1578:stk500boot.c  **** 		else
1579:stk500boot.c  **** 		{
1580:stk500boot.c  **** 			sendchar(theEEPROMchar);
1581:stk500boot.c  **** 		}
1582:stk500boot.c  **** 		if (theEEPROMchar != theChar)
1583:stk500boot.c  **** 		{
1584:stk500boot.c  **** 			errorCount++;
1585:stk500boot.c  **** 		}
1586:stk500boot.c  **** 		ii++;
1587:stk500boot.c  **** 	}
1588:stk500boot.c  **** 	PrintNewLine();
1589:stk500boot.c  **** 	PrintNewLine();
1590:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
1591:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
1592:stk500boot.c  **** 	PrintNewLine();
1593:stk500boot.c  **** 	PrintNewLine();
1594:stk500boot.c  **** 
1595:stk500boot.c  **** 	gEepromIndex	=	0;	//*	set index back to zero for next eeprom dump
1596:stk500boot.c  **** 
1597:stk500boot.c  **** }
1598:stk500boot.c  **** 
1599:stk500boot.c  **** 
1600:stk500boot.c  **** 
1601:stk500boot.c  **** #if (FLASHEND > 0x08000)
1602:stk500boot.c  **** //*	this includes the interrupt names for the monitor portion. There is no longer enough
1603:stk500boot.c  **** //*	memory to include this
1604:stk500boot.c  **** //	#include	"avrinterruptnames.h"
1605:stk500boot.c  **** //	#ifndef _INTERRUPT_NAMES_DEFINED_
1606:stk500boot.c  **** //		#warning Interrupt vectors not defined
1607:stk500boot.c  **** //	#endif
1608:stk500boot.c  **** #endif
1609:stk500boot.c  **** 
1610:stk500boot.c  **** //************************************************************************
1611:stk500boot.c  **** static void	VectorDisplay(void)
1612:stk500boot.c  **** {
1613:stk500boot.c  **** unsigned long	byte1;
1614:stk500boot.c  **** unsigned long	byte2;
1615:stk500boot.c  **** unsigned long	byte3;
1616:stk500boot.c  **** unsigned long	byte4;
1617:stk500boot.c  **** unsigned long	word1;
1618:stk500boot.c  **** unsigned long	word2;
1619:stk500boot.c  **** int				vectorIndex;
1620:stk500boot.c  **** unsigned long	myMemoryPtr;
1621:stk500boot.c  **** unsigned long	wordMemoryAddress;
1622:stk500boot.c  **** unsigned long	realitiveAddr;
1623:stk500boot.c  **** unsigned long	myFullAddress;
1624:stk500boot.c  **** unsigned long	absoluteAddr;
1625:stk500boot.c  **** #if defined(_INTERRUPT_NAMES_DEFINED_)
1626:stk500boot.c  **** 	long		stringPointer;
1627:stk500boot.c  **** #endif
1628:stk500boot.c  **** 
1629:stk500boot.c  **** 	myMemoryPtr		=	0;
1630:stk500boot.c  **** 	vectorIndex		=	0;
1631:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
1632:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
1633:stk500boot.c  **** 	//					 V#   ADDR   op code
1634:stk500boot.c  **** 	//					  1 - 0000 = C3 BB 00 00 rjmp 03BB >000776 RESET
1635:stk500boot.c  **** 	while (vectorIndex < kInterruptVectorCount)
1636:stk500boot.c  **** 	{
1637:stk500boot.c  **** 		wordMemoryAddress	=	myMemoryPtr / 2;
1638:stk500boot.c  **** 		//					 01 - 0000 = 12 34
1639:stk500boot.c  **** 		PrintDecInt(vectorIndex + 1, 2);
1640:stk500boot.c  **** 		sendchar(0x20);
1641:stk500boot.c  **** 		sendchar('-');
1642:stk500boot.c  **** 		sendchar(0x20);
1643:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
1644:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
1645:stk500boot.c  **** 		sendchar(0x20);
1646:stk500boot.c  **** 		sendchar('=');
1647:stk500boot.c  **** 		sendchar(0x20);
1648:stk500boot.c  **** 
1649:stk500boot.c  **** 
1650:stk500boot.c  **** 		//*	the AVR is LITTLE ENDIAN, swap the byte order
1651:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1652:stk500boot.c  **** 		byte1	=	pgm_read_byte_far(myMemoryPtr++);
1653:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
1654:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
1655:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
1656:stk500boot.c  **** 	#else
1657:stk500boot.c  **** 		byte1	=	pgm_read_byte_near(myMemoryPtr++);
1658:stk500boot.c  **** 		byte2	=	pgm_read_byte_near(myMemoryPtr++);
1659:stk500boot.c  **** 		byte3	=	pgm_read_byte_near(myMemoryPtr++);
1660:stk500boot.c  **** 		byte4	=	pgm_read_byte_near(myMemoryPtr++);
1661:stk500boot.c  **** 	#endif
1662:stk500boot.c  **** 		word1	=	(byte2 << 8) + byte1;
1663:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
1664:stk500boot.c  **** 
1665:stk500boot.c  **** 
1666:stk500boot.c  **** 		PrintHexByte(byte2);
1667:stk500boot.c  **** 		sendchar(0x20);
1668:stk500boot.c  **** 		PrintHexByte(byte1);
1669:stk500boot.c  **** 		sendchar(0x20);
1670:stk500boot.c  **** 		PrintHexByte(byte4);
1671:stk500boot.c  **** 		sendchar(0x20);
1672:stk500boot.c  **** 		PrintHexByte(byte3);
1673:stk500boot.c  **** 		sendchar(0x20);
1674:stk500boot.c  **** 
1675:stk500boot.c  **** 		if (word1 == 0xffff)
1676:stk500boot.c  **** 		{
1677:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_noVector, 0);
1678:stk500boot.c  **** 		}
1679:stk500boot.c  **** 		else if ((word1 & 0xc000) == 0xc000)
1680:stk500boot.c  **** 		{
1681:stk500boot.c  **** 			//*	rjmp instruction
1682:stk500boot.c  **** 			realitiveAddr	=	word1 & 0x3FFF;
1683:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
1684:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
1685:stk500boot.c  **** 
1686:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_rjmp, 0);
1687:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
1688:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
1689:stk500boot.c  **** 			sendchar(0x20);
1690:stk500boot.c  **** 			sendchar('>');
1691:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1692:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1693:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1694:stk500boot.c  **** 
1695:stk500boot.c  **** 		}
1696:stk500boot.c  **** 		else if ((word1 & 0xfE0E) == 0x940c)
1697:stk500boot.c  **** 		{
1698:stk500boot.c  **** 			//*	jmp instruction, this is REALLY complicated, refer to the instruction manual (JMP)
1699:stk500boot.c  **** 			myFullAddress	=	((byte1 & 0x01) << 16) +
1700:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
1701:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
1702:stk500boot.c  **** 								word2;
1703:stk500boot.c  **** 
1704:stk500boot.c  **** 			absoluteAddr	=	myFullAddress << 1;
1705:stk500boot.c  **** 
1706:stk500boot.c  **** 			PrintFromPROGMEM(gTextMsg_jmp, 0);
1707:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
1708:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
1709:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
1710:stk500boot.c  **** 			sendchar(0x20);
1711:stk500boot.c  **** 			sendchar('>');
1712:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
1713:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
1714:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
1715:stk500boot.c  **** 		}
1716:stk500boot.c  **** 
1717:stk500boot.c  **** 	#if defined(_INTERRUPT_NAMES_DEFINED_)
1718:stk500boot.c  **** 		sendchar(0x20);
1719:stk500boot.c  **** 	#if (FLASHEND > 0x10000)
1720:stk500boot.c  **** 		stringPointer	=	pgm_read_word_far(&(gInterruptNameTable[vectorIndex]));
1721:stk500boot.c  **** 	#else
1722:stk500boot.c  **** 		stringPointer	=	pgm_read_word_near(&(gInterruptNameTable[vectorIndex]));
1723:stk500boot.c  **** 	#endif
1724:stk500boot.c  **** 		PrintFromPROGMEM((char *)stringPointer, 0);
1725:stk500boot.c  **** 	#endif
1726:stk500boot.c  **** 		PrintNewLine();
1727:stk500boot.c  **** 
1728:stk500boot.c  **** 		vectorIndex++;
1729:stk500boot.c  **** 	}
1730:stk500boot.c  **** }
1731:stk500boot.c  **** 
1732:stk500boot.c  **** //************************************************************************
1733:stk500boot.c  **** static void	PrintAvailablePort(char thePortLetter)
1734:stk500boot.c  **** {
 246               		.loc 1 1734 0
 247               		.cfi_startproc
 248               	.LVL17:
 249 000e CF93      		push r28
 250               	.LCFI2:
 251               		.cfi_def_cfa_offset 4
 252               		.cfi_offset 28, -3
 253               	/* prologue: function */
 254               	/* frame size = 0 */
 255               	/* stack size = 1 */
 256               	.L__stack_usage = 1
 257 0010 C82F      		mov r28,r24
1735:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_PORT, 0);
 258               		.loc 1 1735 0
 259 0012 60E0      		ldi r22,0
 260 0014 80E0      		ldi r24,lo8(gTextMsg_PORT)
 261 0016 90E0      		ldi r25,hi8(gTextMsg_PORT)
 262               	.LVL18:
 263 0018 0E94 0000 		call PrintFromPROGMEM
 264               	.LVL19:
1736:stk500boot.c  **** 	sendchar(thePortLetter);
 265               		.loc 1 1736 0
 266 001c 8C2F      		mov r24,r28
 267 001e 0E94 0000 		call sendchar
 268               	.LVL20:
 269               	/* epilogue start */
1737:stk500boot.c  **** 	PrintNewLine();
1738:stk500boot.c  **** }
 270               		.loc 1 1738 0
 271 0022 CF91      		pop r28
 272               	.LVL21:
1737:stk500boot.c  **** 	PrintNewLine();
 273               		.loc 1 1737 0
 274 0024 0C94 0000 		jmp PrintNewLine
 275               	.LVL22:
 276               		.cfi_endproc
 277               	.LFE29:
 279               		.text
 280               	.global	PrintFromPROGMEMln
 282               	PrintFromPROGMEMln:
 283               	.LFB20:
1304:stk500boot.c  **** 	PrintFromPROGMEM(dataPtr, offset);
 284               		.loc 1 1304 0
 285               		.cfi_startproc
 286               	.LVL23:
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 0 */
 290               	.L__stack_usage = 0
1305:stk500boot.c  **** 
 291               		.loc 1 1305 0
 292 006a 0E94 0000 		call PrintFromPROGMEM
 293               	.LVL24:
1307:stk500boot.c  **** }
 294               		.loc 1 1307 0
 295 006e 0C94 0000 		jmp PrintNewLine
 296               	.LVL25:
 297               		.cfi_endproc
 298               	.LFE20:
 300               	.global	PrintString
 302               	PrintString:
 303               	.LFB21:
1313:stk500boot.c  **** char	theChar;
 304               		.loc 1 1313 0
 305               		.cfi_startproc
 306               	.LVL26:
 307 0072 CF93      		push r28
 308               	.LCFI3:
 309               		.cfi_def_cfa_offset 4
 310               		.cfi_offset 28, -3
 311 0074 DF93      		push r29
 312               	.LCFI4:
 313               		.cfi_def_cfa_offset 5
 314               		.cfi_offset 29, -4
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 2 */
 318               	.L__stack_usage = 2
 319 0076 EC01      		movw r28,r24
 320               	.LVL27:
 321               	.L22:
1321:stk500boot.c  **** 		if (theChar != 0)
 322               		.loc 1 1321 0
 323 0078 8991      		ld r24,Y+
 324               	.LVL28:
1322:stk500boot.c  **** 		{
 325               		.loc 1 1322 0
 326 007a 8823      		tst r24
 327 007c 01F0      		breq .L20
1324:stk500boot.c  **** 		}
 328               		.loc 1 1324 0
 329 007e 0E94 0000 		call sendchar
 330               	.LVL29:
 331 0082 00C0      		rjmp .L22
 332               	.LVL30:
 333               	.L20:
 334               	/* epilogue start */
1328:stk500boot.c  **** 
 335               		.loc 1 1328 0
 336 0084 DF91      		pop r29
 337 0086 CF91      		pop r28
 338               	.LVL31:
 339 0088 0895      		ret
 340               		.cfi_endproc
 341               	.LFE21:
 343               	.global	PrintHexByte
 345               	PrintHexByte:
 346               	.LFB22:
1332:stk500boot.c  **** char	theChar;
 347               		.loc 1 1332 0
 348               		.cfi_startproc
 349               	.LVL32:
 350 008a CF93      		push r28
 351               	.LCFI5:
 352               		.cfi_def_cfa_offset 4
 353               		.cfi_offset 28, -3
 354               	/* prologue: function */
 355               	/* frame size = 0 */
 356               	/* stack size = 1 */
 357               	.L__stack_usage = 1
 358 008c C82F      		mov r28,r24
1335:stk500boot.c  **** 	if (theChar > 0x39)
 359               		.loc 1 1335 0
 360 008e 982F      		mov r25,r24
 361 0090 9295      		swap r25
 362 0092 9F70      		andi r25,lo8(15)
 363 0094 80E3      		ldi r24,lo8(48)
 364               	.LVL33:
 365 0096 890F      		add r24,r25
 366               	.LVL34:
1336:stk500boot.c  **** 	{
 367               		.loc 1 1336 0
 368 0098 8A33      		cpi r24,lo8(58)
 369 009a 00F0      		brlo .L24
1338:stk500boot.c  **** 	}
 370               		.loc 1 1338 0
 371 009c 87E3      		ldi r24,lo8(55)
 372               	.LVL35:
 373 009e 890F      		add r24,r25
 374               	.LVL36:
 375               	.L24:
1340:stk500boot.c  **** 
 376               		.loc 1 1340 0
 377 00a0 0E94 0000 		call sendchar
 378               	.LVL37:
1342:stk500boot.c  **** 	if (theChar > 0x39)
 379               		.loc 1 1342 0
 380 00a4 CF70      		andi r28,lo8(15)
 381               	.LVL38:
 382 00a6 80E3      		ldi r24,lo8(48)
 383 00a8 8C0F      		add r24,r28
 384               	.LVL39:
1343:stk500boot.c  **** 	{
 385               		.loc 1 1343 0
 386 00aa 8A33      		cpi r24,lo8(58)
 387 00ac 00F0      		brlo .L25
1345:stk500boot.c  **** 	}
 388               		.loc 1 1345 0
 389 00ae 87E3      		ldi r24,lo8(55)
 390               	.LVL40:
 391 00b0 8C0F      		add r24,r28
 392               	.LVL41:
 393               	.L25:
 394               	/* epilogue start */
1348:stk500boot.c  **** 
 395               		.loc 1 1348 0
 396 00b2 CF91      		pop r28
1347:stk500boot.c  **** }
 397               		.loc 1 1347 0
 398 00b4 0C94 0000 		jmp sendchar
 399               	.LVL42:
 400               		.cfi_endproc
 401               	.LFE22:
 403               		.section	.text.unlikely
 405               	DumpHex.constprop.0:
 406               	.LFB34:
1461:stk500boot.c  **** {
 407               		.loc 1 1461 0
 408               		.cfi_startproc
 409               	.LVL43:
 410 0028 2F92      		push r2
 411               	.LCFI6:
 412               		.cfi_def_cfa_offset 4
 413               		.cfi_offset 2, -3
 414 002a 3F92      		push r3
 415               	.LCFI7:
 416               		.cfi_def_cfa_offset 5
 417               		.cfi_offset 3, -4
 418 002c 4F92      		push r4
 419               	.LCFI8:
 420               		.cfi_def_cfa_offset 6
 421               		.cfi_offset 4, -5
 422 002e 5F92      		push r5
 423               	.LCFI9:
 424               		.cfi_def_cfa_offset 7
 425               		.cfi_offset 5, -6
 426 0030 6F92      		push r6
 427               	.LCFI10:
 428               		.cfi_def_cfa_offset 8
 429               		.cfi_offset 6, -7
 430 0032 7F92      		push r7
 431               	.LCFI11:
 432               		.cfi_def_cfa_offset 9
 433               		.cfi_offset 7, -8
 434 0034 8F92      		push r8
 435               	.LCFI12:
 436               		.cfi_def_cfa_offset 10
 437               		.cfi_offset 8, -9
 438 0036 9F92      		push r9
 439               	.LCFI13:
 440               		.cfi_def_cfa_offset 11
 441               		.cfi_offset 9, -10
 442 0038 AF92      		push r10
 443               	.LCFI14:
 444               		.cfi_def_cfa_offset 12
 445               		.cfi_offset 10, -11
 446 003a BF92      		push r11
 447               	.LCFI15:
 448               		.cfi_def_cfa_offset 13
 449               		.cfi_offset 11, -12
 450 003c CF92      		push r12
 451               	.LCFI16:
 452               		.cfi_def_cfa_offset 14
 453               		.cfi_offset 12, -13
 454 003e DF92      		push r13
 455               	.LCFI17:
 456               		.cfi_def_cfa_offset 15
 457               		.cfi_offset 13, -14
 458 0040 EF92      		push r14
 459               	.LCFI18:
 460               		.cfi_def_cfa_offset 16
 461               		.cfi_offset 14, -15
 462 0042 FF92      		push r15
 463               	.LCFI19:
 464               		.cfi_def_cfa_offset 17
 465               		.cfi_offset 15, -16
 466 0044 0F93      		push r16
 467               	.LCFI20:
 468               		.cfi_def_cfa_offset 18
 469               		.cfi_offset 16, -17
 470 0046 1F93      		push r17
 471               	.LCFI21:
 472               		.cfi_def_cfa_offset 19
 473               		.cfi_offset 17, -18
 474 0048 CF93      		push r28
 475               	.LCFI22:
 476               		.cfi_def_cfa_offset 20
 477               		.cfi_offset 28, -19
 478 004a DF93      		push r29
 479               	.LCFI23:
 480               		.cfi_def_cfa_offset 21
 481               		.cfi_offset 29, -20
 482 004c CDB7      		in r28,__SP_L__
 483 004e DEB7      		in r29,__SP_H__
 484               	.LCFI24:
 485               		.cfi_def_cfa_register 28
 486 0050 6397      		sbiw r28,19
 487               	.LCFI25:
 488               		.cfi_def_cfa_offset 40
 489 0052 0FB6      		in __tmp_reg__,__SREG__
 490 0054 F894      		cli
 491 0056 DEBF      		out __SP_H__,r29
 492 0058 0FBE      		out __SREG__,__tmp_reg__
 493 005a CDBF      		out __SP_L__,r28
 494               	/* prologue: function */
 495               	/* frame size = 19 */
 496               	/* stack size = 37 */
 497               	.L__stack_usage = 37
 498 005c 8B8B      		std Y+19,r24
 499 005e 6A01      		movw r12,r20
 500 0060 7B01      		movw r14,r22
 501               	.LVL44:
1461:stk500boot.c  **** {
 502               		.loc 1 1461 0
 503 0062 00E1      		ldi r16,lo8(16)
1471:stk500boot.c  **** 	myAddressPointer	=	startAddress;
 504               		.loc 1 1471 0
 505 0064 10E0      		ldi r17,0
 506 0066 CE01      		movw r24,r28
 507               	.LVL45:
 508 0068 0196      		adiw r24,1
 509 006a 4C01      		movw r8,r24
1515:stk500boot.c  **** 			}
 510               		.loc 1 1515 0
 511 006c 8EE2      		ldi r24,lo8(46)
 512 006e 382E      		mov r3,r24
 513 0070 90E1      		ldi r25,lo8(16)
 514 0072 292E      		mov r2,r25
 515 0074 280C      		add r2,r8
 516               	.LVL46:
 517               	.L35:
1475:stk500boot.c  **** 		{
 518               		.loc 1 1475 0
 519 0076 91E0      		ldi r25,1
 520 0078 C916      		cp r12,r25
 521 007a D104      		cpc r13,__zero_reg__
 522 007c E906      		cpc r14,r25
 523 007e F104      		cpc r15,__zero_reg__
 524 0080 00F0      		brlo .L27
1477:stk500boot.c  **** 		}
 525               		.loc 1 1477 0
 526 0082 8E2D      		mov r24,r14
 527 0084 0E94 0000 		call PrintHexByte
 528               	.LVL47:
 529               	.L27:
1479:stk500boot.c  **** 		PrintHexByte(myAddressPointer & 0x00ff);
 530               		.loc 1 1479 0
 531 0088 8D2D      		mov r24,r13
 532 008a 0E94 0000 		call PrintHexByte
 533               	.LVL48:
1480:stk500boot.c  **** 		sendchar(0x20);
 534               		.loc 1 1480 0
 535 008e 8C2D      		mov r24,r12
 536 0090 0E94 0000 		call PrintHexByte
 537               	.LVL49:
1481:stk500boot.c  **** 		sendchar('-');
 538               		.loc 1 1481 0
 539 0094 80E2      		ldi r24,lo8(32)
 540 0096 0E94 0000 		call sendchar
 541               	.LVL50:
1482:stk500boot.c  **** 		sendchar(0x20);
 542               		.loc 1 1482 0
 543 009a 8DE2      		ldi r24,lo8(45)
 544 009c 0E94 0000 		call sendchar
 545               	.LVL51:
1483:stk500boot.c  **** 
 546               		.loc 1 1483 0
 547 00a0 80E2      		ldi r24,lo8(32)
 548 00a2 0E94 0000 		call sendchar
 549               	.LVL52:
1485:stk500boot.c  **** 		for (ii=0; ii<16; ii++)
 550               		.loc 1 1485 0
 551 00a6 1982      		std Y+1,__zero_reg__
 552               	.LVL53:
 553 00a8 5401      		movw r10,r8
 554 00aa 2601      		movw r4,r12
 555 00ac 3701      		movw r6,r14
 556               	.LVL54:
 557               	.L34:
1488:stk500boot.c  **** 			{
 558               		.loc 1 1488 0
 559 00ae EB89      		ldd r30,Y+19
 560 00b0 E130      		cpi r30,lo8(1)
 561 00b2 01F0      		breq .L29
 562 00b4 00F0      		brlo .L30
 563 00b6 E230      		cpi r30,lo8(2)
 564 00b8 01F4      		brne .L28
1503:stk500boot.c  **** 					break;
 565               		.loc 1 1503 0
 566 00ba F201      		movw r30,r4
 567 00bc 1081      		ld r17,Z
 568               	.LVL55:
 569 00be 00C0      		rjmp .L28
 570               	.L30:
 571               	.LVL56:
 572               	.LBB55:
1492:stk500boot.c  **** 				#else
 573               		.loc 1 1492 0
 574               	/* #APP */
 575               	 ;  1492 "stk500boot.c" 1
 576 00c0 6BBE      		out 59, r6
 577 00c2 F201      		movw r30, r4
 578 00c4 1791      		elpm r17, Z+
 579               		
 580               	 ;  0 "" 2
 581               	.LVL57:
 582               	/* #NOAPP */
 583 00c6 00C0      		rjmp .L28
 584               	.LVL58:
 585               	.L29:
 586               	.LBE55:
1499:stk500boot.c  **** 					break;
 587               		.loc 1 1499 0
 588 00c8 C201      		movw r24,r4
 589 00ca 0E94 0000 		call eeprom_read_byte
 590               	.LVL59:
 591 00ce 182F      		mov r17,r24
 592               	.LVL60:
 593               	.L28:
1507:stk500boot.c  **** 			sendchar(0x20);
 594               		.loc 1 1507 0
 595 00d0 812F      		mov r24,r17
 596 00d2 0E94 0000 		call PrintHexByte
 597               	.LVL61:
1508:stk500boot.c  **** 			if ((theValue >= 0x20) && (theValue < 0x7f))
 598               		.loc 1 1508 0
 599 00d6 80E2      		ldi r24,lo8(32)
 600 00d8 0E94 0000 		call sendchar
 601               	.LVL62:
1509:stk500boot.c  **** 			{
 602               		.loc 1 1509 0
 603 00dc 80EE      		ldi r24,lo8(-32)
 604 00de 810F      		add r24,r17
1511:stk500boot.c  **** 			}
 605               		.loc 1 1511 0
 606 00e0 F501      		movw r30,r10
1509:stk500boot.c  **** 			{
 607               		.loc 1 1509 0
 608 00e2 8F35      		cpi r24,lo8(95)
 609 00e4 00F4      		brsh .L32
1511:stk500boot.c  **** 			}
 610               		.loc 1 1511 0
 611 00e6 1083      		st Z,r17
 612 00e8 00C0      		rjmp .L33
 613               	.L32:
1515:stk500boot.c  **** 			}
 614               		.loc 1 1515 0
 615 00ea 3082      		st Z,r3
 616               	.L33:
1518:stk500boot.c  **** 		}
 617               		.loc 1 1518 0
 618 00ec FFEF      		ldi r31,-1
 619 00ee 4F1A      		sub r4,r31
 620 00f0 5F0A      		sbc r5,r31
 621 00f2 6F0A      		sbc r6,r31
 622 00f4 7F0A      		sbc r7,r31
 623               	.LVL63:
 624 00f6 8FEF      		ldi r24,-1
 625 00f8 A81A      		sub r10,r24
 626 00fa B80A      		sbc r11,r24
1486:stk500boot.c  **** 		{
 627               		.loc 1 1486 0
 628 00fc 2A10      		cpse r2,r10
 629 00fe 00C0      		rjmp .L34
 630 0100 90E1      		ldi r25,16
 631 0102 C90E      		add r12,r25
 632 0104 D11C      		adc r13,__zero_reg__
 633 0106 E11C      		adc r14,__zero_reg__
 634 0108 F11C      		adc r15,__zero_reg__
1520:stk500boot.c  **** 		PrintString(asciiDump);
 635               		.loc 1 1520 0
 636 010a 198A      		std Y+17,__zero_reg__
1521:stk500boot.c  **** 		PrintNewLine();
 637               		.loc 1 1521 0
 638 010c C401      		movw r24,r8
 639 010e 0E94 0000 		call PrintString
 640               	.LVL64:
1522:stk500boot.c  **** 
 641               		.loc 1 1522 0
 642 0112 0E94 0000 		call PrintNewLine
 643               	.LVL65:
 644 0116 0150      		subi r16,lo8(-(-1))
 645               	.LVL66:
1473:stk500boot.c  **** 	{
 646               		.loc 1 1473 0
 647 0118 01F0      		breq .+2
 648 011a 00C0      		rjmp .L35
 649               	/* epilogue start */
1526:stk500boot.c  **** 
 650               		.loc 1 1526 0
 651 011c 6396      		adiw r28,19
 652               	.LVL67:
 653 011e 0FB6      		in __tmp_reg__,__SREG__
 654 0120 F894      		cli
 655 0122 DEBF      		out __SP_H__,r29
 656 0124 0FBE      		out __SREG__,__tmp_reg__
 657 0126 CDBF      		out __SP_L__,r28
 658 0128 DF91      		pop r29
 659 012a CF91      		pop r28
 660               	.LVL68:
 661 012c 1F91      		pop r17
 662               	.LVL69:
 663 012e 0F91      		pop r16
 664               	.LVL70:
 665 0130 FF90      		pop r15
 666 0132 EF90      		pop r14
 667 0134 DF90      		pop r13
 668 0136 CF90      		pop r12
 669               	.LVL71:
 670 0138 BF90      		pop r11
 671 013a AF90      		pop r10
 672 013c 9F90      		pop r9
 673 013e 8F90      		pop r8
 674 0140 7F90      		pop r7
 675 0142 6F90      		pop r6
 676 0144 5F90      		pop r5
 677 0146 4F90      		pop r4
 678 0148 3F90      		pop r3
 679 014a 2F90      		pop r2
 680 014c 0895      		ret
 681               		.cfi_endproc
 682               	.LFE34:
 684               		.text
 685               	.global	PrintDecInt
 687               	PrintDecInt:
 688               	.LFB23:
1352:stk500boot.c  **** int	theChar;
 689               		.loc 1 1352 0
 690               		.cfi_startproc
 691               	.LVL72:
 692 00b8 0F93      		push r16
 693               	.LCFI26:
 694               		.cfi_def_cfa_offset 4
 695               		.cfi_offset 16, -3
 696 00ba 1F93      		push r17
 697               	.LCFI27:
 698               		.cfi_def_cfa_offset 5
 699               		.cfi_offset 17, -4
 700 00bc CF93      		push r28
 701               	.LCFI28:
 702               		.cfi_def_cfa_offset 6
 703               		.cfi_offset 28, -5
 704 00be DF93      		push r29
 705               	.LCFI29:
 706               		.cfi_def_cfa_offset 7
 707               		.cfi_offset 29, -6
 708               	/* prologue: function */
 709               	/* frame size = 0 */
 710               	/* stack size = 4 */
 711               	.L__stack_usage = 4
 712 00c0 EC01      		movw r28,r24
 713 00c2 8B01      		movw r16,r22
 714               	.LVL73:
1358:stk500boot.c  **** 	{
 715               		.loc 1 1358 0
 716 00c4 8536      		cpi r24,101
 717 00c6 9105      		cpc r25,__zero_reg__
 718 00c8 04F4      		brge .L39
1358:stk500boot.c  **** 	{
 719               		.loc 1 1358 0 is_stmt 0 discriminator 1
 720 00ca 6330      		cpi r22,3
 721 00cc 7105      		cpc r23,__zero_reg__
 722 00ce 04F0      		brlt .L40
 723               	.L39:
 724               	.LVL74:
1360:stk500boot.c  **** 		sendchar(theChar );
 725               		.loc 1 1360 0 is_stmt 1
 726 00d0 CE01      		movw r24,r28
 727               	.LVL75:
 728 00d2 64E6      		ldi r22,lo8(100)
 729 00d4 70E0      		ldi r23,0
 730               	.LVL76:
 731 00d6 0E94 0000 		call __divmodhi4
 732               	.LVL77:
1361:stk500boot.c  **** 	}
 733               		.loc 1 1361 0
 734 00da 80E3      		ldi r24,lo8(48)
 735 00dc 860F      		add r24,r22
 736 00de 0E94 0000 		call sendchar
 737               	.LVL78:
 738               	.L40:
1364:stk500boot.c  **** 	{
 739               		.loc 1 1364 0
 740 00e2 CB30      		cpi r28,11
 741 00e4 D105      		cpc r29,__zero_reg__
 742 00e6 04F4      		brge .L41
1364:stk500boot.c  **** 	{
 743               		.loc 1 1364 0 is_stmt 0 discriminator 1
 744 00e8 0230      		cpi r16,2
 745 00ea 1105      		cpc r17,__zero_reg__
 746 00ec 04F0      		brlt .L42
 747               	.L41:
 748               	.LVL79:
1366:stk500boot.c  **** 		sendchar(theChar );
 749               		.loc 1 1366 0 is_stmt 1
 750 00ee CE01      		movw r24,r28
 751 00f0 64E6      		ldi r22,lo8(100)
 752 00f2 70E0      		ldi r23,0
 753 00f4 0E94 0000 		call __divmodhi4
 754 00f8 6AE0      		ldi r22,lo8(10)
 755 00fa 70E0      		ldi r23,0
 756 00fc 0E94 0000 		call __divmodhi4
1367:stk500boot.c  **** 	}
 757               		.loc 1 1367 0
 758 0100 80E3      		ldi r24,lo8(48)
 759 0102 860F      		add r24,r22
 760 0104 0E94 0000 		call sendchar
 761               	.LVL80:
 762               	.L42:
1369:stk500boot.c  **** 	sendchar(theChar );
 763               		.loc 1 1369 0
 764 0108 CE01      		movw r24,r28
 765 010a 6AE0      		ldi r22,lo8(10)
 766 010c 70E0      		ldi r23,0
 767 010e 0E94 0000 		call __divmodhi4
1370:stk500boot.c  **** }
 768               		.loc 1 1370 0
 769 0112 805D      		subi r24,lo8(-(48))
 770               	/* epilogue start */
1371:stk500boot.c  **** 
 771               		.loc 1 1371 0
 772 0114 DF91      		pop r29
 773 0116 CF91      		pop r28
 774               	.LVL81:
 775 0118 1F91      		pop r17
 776 011a 0F91      		pop r16
 777               	.LVL82:
1370:stk500boot.c  **** }
 778               		.loc 1 1370 0
 779 011c 0C94 0000 		jmp sendchar
 780               	.LVL83:
 781               		.cfi_endproc
 782               	.LFE23:
 784               		.section	.text.startup,"ax",@progbits
 785               	.global	main
 787               	main:
 788               	.LFB17:
 527:stk500boot.c  **** 	address_t		address			=	0;
 789               		.loc 1 527 0
 790               		.cfi_startproc
 791 0000 CF93      		push r28
 792               	.LCFI30:
 793               		.cfi_def_cfa_offset 4
 794               		.cfi_offset 28, -3
 795 0002 DF93      		push r29
 796               	.LCFI31:
 797               		.cfi_def_cfa_offset 5
 798               		.cfi_offset 29, -4
 799 0004 CDB7      		in r28,__SP_L__
 800 0006 DEB7      		in r29,__SP_H__
 801               	.LCFI32:
 802               		.cfi_def_cfa_register 28
 803 0008 C053      		subi r28,48
 804 000a D140      		sbci r29,1
 805               	.LCFI33:
 806               		.cfi_def_cfa_offset 309
 807 000c 0FB6      		in __tmp_reg__,__SREG__
 808 000e F894      		cli
 809 0010 DEBF      		out __SP_H__,r29
 810 0012 0FBE      		out __SREG__,__tmp_reg__
 811 0014 CDBF      		out __SP_L__,r28
 812               	/* prologue: function */
 813               	/* frame size = 304 */
 814               	/* stack size = 306 */
 815               	.L__stack_usage = 306
 816               	.LVL84:
 548:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND >> 8) );
 817               		.loc 1 548 0
 818               	/* #APP */
 819               	 ;  548 "stk500boot.c" 1
 820               		.set __stack, 8703
 821               	 ;  0 "" 2
 549:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_HI_ADDR) );
 822               		.loc 1 549 0
 823               	 ;  549 "stk500boot.c" 1
 824 0016 01E2      		ldi	16, 33
 825               	 ;  0 "" 2
 550:stk500boot.c  **** 	asm volatile ( "ldi	16, %0" :: "i" (RAMEND & 0x0ff) );
 826               		.loc 1 550 0
 827               	 ;  550 "stk500boot.c" 1
 828 0018 0EBF      		out 62,16
 829               	 ;  0 "" 2
 551:stk500boot.c  **** 	asm volatile ( "out %0,16" :: "i" (AVR_STACK_POINTER_LO_ADDR) );
 830               		.loc 1 551 0
 831               	 ;  551 "stk500boot.c" 1
 832 001a 0FEF      		ldi	16, 255
 833               	 ;  0 "" 2
 552:stk500boot.c  **** 
 834               		.loc 1 552 0
 835               	 ;  552 "stk500boot.c" 1
 836 001c 0DBF      		out 61,16
 837               	 ;  0 "" 2
 555:stk500boot.c  **** 	uint8_t mcuStatusReg = MCUSR;
 838               		.loc 1 555 0
 839               	 ;  555 "stk500boot.c" 1
 840 001e A895      		wdr
 841               	 ;  0 "" 2
 557:stk500boot.c  **** 	{
 842               		.loc 1 557 0
 843               	/* #NOAPP */
 844 0020 04B6      		in __tmp_reg__,0x34
 845 0022 03FE      		sbrs __tmp_reg__,3
 846 0024 00C0      		rjmp .L44
 559:stk500boot.c  **** 		"clr	r30		\n\t"
 847               		.loc 1 559 0
 848               	/* #APP */
 849               	 ;  559 "stk500boot.c" 1
 850 0026 EE27      		clr	r30		
 851 0028 FF27      		clr	r31		
 852 002a 0994      		ijmp	
 853               		
 854               	 ;  0 "" 2
 855               	/* #NOAPP */
 856               	.L44:
 857               	.LVL85:
 583:stk500boot.c  **** //	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED ON
 858               		.loc 1 583 0
 859 002c 9D9A      		sbi 0x13,5
 585:stk500boot.c  **** 
 860               		.loc 1 585 0
 861 002e A59A      		sbi 0x14,5
 603:stk500boot.c  **** #endif
 862               		.loc 1 603 0
 863 0030 8091 C000 		lds r24,192
 864 0034 8260      		ori r24,lo8(2)
 865 0036 8093 C000 		sts 192,r24
 605:stk500boot.c  **** 	UART_CONTROL_REG	=	(1 << UART_ENABLE_RECEIVER) | (1 << UART_ENABLE_TRANSMITTER);
 866               		.loc 1 605 0
 867 003a 80E1      		ldi r24,lo8(16)
 868 003c 8093 C400 		sts 196,r24
 606:stk500boot.c  **** 
 869               		.loc 1 606 0
 870 0040 88E1      		ldi r24,lo8(24)
 871 0042 8093 C100 		sts 193,r24
 608:stk500boot.c  **** 
 872               		.loc 1 608 0
 873               	/* #APP */
 874               	 ;  608 "stk500boot.c" 1
 875 0046 0000      		nop
 876               	 ;  0 "" 2
 567:stk500boot.c  **** 	boot_state	=	0;
 877               		.loc 1 567 0
 878               	/* #NOAPP */
 879 0048 C12C      		mov r12,__zero_reg__
 880 004a D12C      		mov r13,__zero_reg__
 881 004c 7601      		movw r14,r12
 638:stk500boot.c  **** 			{
 882               		.loc 1 638 0
 883 004e A7EC      		ldi r26,lo8(-57)
 884 0050 8A2E      		mov r8,r26
 885 0052 ABE1      		ldi r26,lo8(27)
 886 0054 9A2E      		mov r9,r26
 887 0056 A12C      		mov r10,__zero_reg__
 888 0058 B12C      		mov r11,__zero_reg__
 641:stk500boot.c  **** 			}
 889               		.loc 1 641 0
 890 005a B0E2      		ldi r27,lo8(32)
 891 005c 7B2E      		mov r7,r27
 892               	.LVL86:
 893               	.L45:
 527:stk500boot.c  **** 	address_t		address			=	0;
 894               		.loc 1 527 0
 895 005e 00E0      		ldi r16,0
 896 0060 10E0      		ldi r17,0
 897               	.LVL87:
 898               	.L52:
 899               	.LBB134:
 900               	.LBB135:
 475:stk500boot.c  **** }
 901               		.loc 1 475 0
 902 0062 8091 C000 		lds r24,192
 903               	.LBE135:
 904               	.LBE134:
 629:stk500boot.c  **** 		{
 905               		.loc 1 629 0
 906 0066 87FF      		sbrs r24,7
 907 0068 00C0      		rjmp .L48
 908               	.L51:
 645:stk500boot.c  **** 	}
 909               		.loc 1 645 0
 910 006a A801      		movw r20,r16
 911 006c 4F5F      		subi r20,-1
 912 006e 5F4F      		sbci r21,-1
 913               	.LVL88:
 627:stk500boot.c  **** 	{
 914               		.loc 1 627 0
 915 0070 01F0      		breq .L45
 916 0072 00C0      		rjmp .L282
 917               	.LVL89:
 918               	.L48:
 629:stk500boot.c  **** 		{
 919               		.loc 1 629 0 discriminator 1
 920 0074 0115      		cp r16,__zero_reg__
 921 0076 1105      		cpc r17,__zero_reg__
 922 0078 01F4      		brne .L51
 923               	.LVL90:
 924               	.LBB136:
 925               	.LBB137:
 926               		.loc 2 187 0
 927 007a 25E0      		ldi r18,lo8(5)
 928 007c 2A95      	1:	dec r18
 929 007e 01F4      		brne 1b
 930 0080 0000      		nop
 931               	.LVL91:
 932               	.LBE137:
 933               	.LBE136:
 632:stk500boot.c  **** 			if (boot_timer > boot_timeout)
 934               		.loc 1 632 0
 935 0082 3FEF      		ldi r19,-1
 936 0084 C31A      		sub r12,r19
 937 0086 D30A      		sbc r13,r19
 938 0088 E30A      		sbc r14,r19
 939 008a F30A      		sbc r15,r19
 940               	.LVL92:
 633:stk500boot.c  **** 			{
 941               		.loc 1 633 0
 942 008c 91E0      		ldi r25,lo8(1)
 943 008e 80E0      		ldi r24,0
 944 0090 41E2      		ldi r20,33
 945 0092 C416      		cp r12,r20
 946 0094 4EE4      		ldi r20,78
 947 0096 D406      		cpc r13,r20
 948 0098 E104      		cpc r14,__zero_reg__
 949 009a F104      		cpc r15,__zero_reg__
 950 009c 00F4      		brsh .L46
 951 009e 90E0      		ldi r25,0
 952               	.L46:
 635:stk500boot.c  **** 			}
 953               		.loc 1 635 0
 954 00a0 092F      		mov r16,r25
 955               	.LVL93:
 956 00a2 182F      		mov r17,r24
 638:stk500boot.c  **** 			{
 957               		.loc 1 638 0
 958 00a4 C701      		movw r24,r14
 959 00a6 B601      		movw r22,r12
 960 00a8 A501      		movw r20,r10
 961 00aa 9401      		movw r18,r8
 962 00ac 0E94 0000 		call __udivmodsi4
 963 00b0 672B      		or r22,r23
 964 00b2 682B      		or r22,r24
 965 00b4 692B      		or r22,r25
 966 00b6 01F4      		brne .L52
 641:stk500boot.c  **** 			}
 967               		.loc 1 641 0
 968 00b8 84B3      		in r24,0x14
 969 00ba 8725      		eor r24,r7
 970 00bc 84BB      		out 0x14,r24
 971 00be 00C0      		rjmp .L52
 972               	.LVL94:
 973               	.L282:
 649:stk500boot.c  **** 	{
 974               		.loc 1 649 0
 975 00c0 4130      		cpi r20,1
 976 00c2 5105      		cpc r21,__zero_reg__
 977 00c4 01F0      		breq .+4
 978 00c6 0C94 0000 		jmp .L54
 979 00ca C55D      		subi r28,lo8(-299)
 980 00cc DE4F      		sbci r29,hi8(-299)
 981 00ce 1982      		std Y+1,__zero_reg__
 982 00d0 1882      		st Y,__zero_reg__
 983 00d2 CB52      		subi r28,lo8(299)
 984 00d4 D140      		sbci r29,hi8(299)
 985 00d6 A12C      		mov r10,__zero_reg__
 986 00d8 B12C      		mov r11,__zero_reg__
 987 00da C65D      		subi r28,lo8(-298)
 988 00dc DE4F      		sbci r29,hi8(-298)
 989 00de 1882      		st Y,__zero_reg__
 990 00e0 CA52      		subi r28,lo8(298)
 991 00e2 D140      		sbci r29,hi8(298)
 992 00e4 10E0      		ldi r17,0
 993 00e6 212C      		mov r2,__zero_reg__
 994 00e8 312C      		mov r3,__zero_reg__
 995 00ea CA5D      		subi r28,lo8(-294)
 996 00ec DE4F      		sbci r29,hi8(-294)
 997 00ee 1882      		st Y,__zero_reg__
 998 00f0 1982      		std Y+1,__zero_reg__
 999 00f2 1A82      		std Y+2,__zero_reg__
 1000 00f4 1B82      		std Y+3,__zero_reg__
 1001 00f6 C652      		subi r28,lo8(294)
 1002 00f8 D140      		sbci r29,hi8(294)
 1003 00fa C12C      		mov r12,__zero_reg__
 1004 00fc D12C      		mov r13,__zero_reg__
 1005 00fe 7601      		movw r14,r12
 1006               	.LVL95:
 1007               	.L53:
 567:stk500boot.c  **** 	boot_state	=	0;
 1008               		.loc 1 567 0
 1009 0100 20E0      		ldi r18,0
 1010 0102 30E0      		ldi r19,0
 1011 0104 80E0      		ldi r24,0
 1012               	.LVL96:
 1013               	.L200:
 660:stk500boot.c  **** 				{
 1014               		.loc 1 660 0
 1015 0106 4130      		cpi r20,1
 1016 0108 5105      		cpc r21,__zero_reg__
 1017 010a 01F0      		breq .L271
 1018               	.LVL97:
 1019               	.L58:
 567:stk500boot.c  **** 	boot_state	=	0;
 1020               		.loc 1 567 0
 1021 010c 41E0      		ldi r20,lo8(1)
 1022 010e 52E1      		ldi r21,lo8(18)
 1023 0110 6AE7      		ldi r22,lo8(122)
 1024 0112 70E0      		ldi r23,0
 1025               	.L57:
 1026               	.LVL98:
 1027               	.LBB138:
 1028               	.LBB139:
 498:stk500boot.c  **** 	{
 1029               		.loc 1 498 0
 1030 0114 9091 C000 		lds r25,192
 1031 0118 97FD      		sbrc r25,7
 1032 011a 00C0      		rjmp .L271
 1033               	.LVL99:
 1034 011c 4150      		subi r20,1
 1035 011e 5109      		sbc r21,__zero_reg__
 1036 0120 6109      		sbc r22,__zero_reg__
 1037 0122 7109      		sbc r23,__zero_reg__
 1038               	.LVL100:
 502:stk500boot.c  **** 		{
 1039               		.loc 1 502 0
 1040 0124 01F4      		brne .L57
 1041               	.LVL101:
 1042               	.LBB140:
 1043               	.LBB141:
 506:stk500boot.c  **** 		#else
 1044               		.loc 1 506 0
 1045               	/* #APP */
 1046               	 ;  506 "stk500boot.c" 1
 1047 0126 6BBF      		out 59, r22
 1048 0128 FA01      		movw r30, r20
 1049 012a 4791      		elpm r20, Z+
 1050 012c 5691      		elpm r21, Z
 1051               		
 1052               	 ;  0 "" 2
 1053               	.LVL102:
 1054               	/* #NOAPP */
 1055               	.LBE141:
 510:stk500boot.c  **** 			{
 1056               		.loc 1 510 0
 1057 012e 4F3F      		cpi r20,-1
 1058 0130 5F4F      		sbci r21,-1
 1059 0132 01F0      		breq .L58
 512:stk500boot.c  **** 						"clr	r30		\n\t"
 1060               		.loc 1 512 0
 1061               	/* #APP */
 1062               	 ;  512 "stk500boot.c" 1
 1063 0134 EE27      		clr	r30		
 1064 0136 FF27      		clr	r31		
 1065 0138 0994      		ijmp	
 1066               		
 1067               	 ;  0 "" 2
 1068               	/* #NOAPP */
 1069 013a 00C0      		rjmp .L58
 1070               	.LVL103:
 1071               	.L271:
 1072               	.LBE140:
 521:stk500boot.c  **** }
 1073               		.loc 1 521 0
 1074 013c 9091 C600 		lds r25,198
 1075               	.LVL104:
 1076               	.LBE139:
 1077               	.LBE138:
 673:stk500boot.c  **** 
 1078               		.loc 1 673 0
 1079 0140 C55D      		subi r28,lo8(-299)
 1080 0142 DE4F      		sbci r29,hi8(-299)
 1081 0144 A881      		ld r26,Y
 1082 0146 B981      		ldd r27,Y+1
 1083 0148 CB52      		subi r28,lo8(299)
 1084 014a D140      		sbci r29,hi8(299)
 1085 014c 1196      		adiw r26,1
 1086 014e C55D      		subi r28,lo8(-299)
 1087 0150 DE4F      		sbci r29,hi8(-299)
 1088 0152 B983      		std Y+1,r27
 1089 0154 A883      		st Y,r26
 1090 0156 CB52      		subi r28,lo8(299)
 1091 0158 D140      		sbci r29,hi8(299)
 1092               	.LVL105:
 675:stk500boot.c  **** 				{
 1093               		.loc 1 675 0
 1094 015a 9132      		cpi r25,lo8(33)
 1095 015c 01F0      		breq .+2
 1096 015e 00C0      		rjmp .L60
 675:stk500boot.c  **** 				{
 1097               		.loc 1 675 0 is_stmt 0 discriminator 1
 1098 0160 1A97      		sbiw r26,10
 1099 0162 00F0      		brlo .+2
 1100 0164 00C0      		rjmp .L206
 677:stk500boot.c  **** 					if (exPointCntr == 3)
 1101               		.loc 1 677 0 is_stmt 1
 1102 0166 BFEF      		ldi r27,-1
 1103 0168 AB1A      		sub r10,r27
 1104 016a BB0A      		sbc r11,r27
 1105               	.LVL106:
 678:stk500boot.c  **** 					{
 1106               		.loc 1 678 0
 1107 016c E3E0      		ldi r30,3
 1108 016e AE16      		cp r10,r30
 1109 0170 B104      		cpc r11,__zero_reg__
 1110 0172 01F0      		breq .+2
 1111 0174 00C0      		rjmp .L61
 1112 0176 05E0      		ldi r16,lo8(5)
 1113 0178 10E0      		ldi r17,0
 1114               	.LVL107:
 1115               	.L64:
 567:stk500boot.c  **** 	boot_state	=	0;
 1116               		.loc 1 567 0
 1117 017a F9E1      		ldi r31,lo8(25)
 1118 017c AF2E      		mov r10,r31
 1119 017e B12C      		mov r11,__zero_reg__
 1120               	.LVL108:
 1121               	.L63:
 1122               	.LBB142:
 1123               	.LBB143:
1739:stk500boot.c  **** 
1740:stk500boot.c  **** //************************************************************************
1741:stk500boot.c  **** static void	ListAvailablePorts(void)
1742:stk500boot.c  **** {
1743:stk500boot.c  **** 
1744:stk500boot.c  **** #ifdef DDRA
1745:stk500boot.c  **** 	PrintAvailablePort('A');
1746:stk500boot.c  **** #endif
1747:stk500boot.c  **** 
1748:stk500boot.c  **** #ifdef DDRB
1749:stk500boot.c  **** 	PrintAvailablePort('B');
1750:stk500boot.c  **** #endif
1751:stk500boot.c  **** 
1752:stk500boot.c  **** #ifdef DDRC
1753:stk500boot.c  **** 	PrintAvailablePort('C');
1754:stk500boot.c  **** #endif
1755:stk500boot.c  **** 
1756:stk500boot.c  **** #ifdef DDRD
1757:stk500boot.c  **** 	PrintAvailablePort('D');
1758:stk500boot.c  **** #endif
1759:stk500boot.c  **** 
1760:stk500boot.c  **** #ifdef DDRE
1761:stk500boot.c  **** 	PrintAvailablePort('E');
1762:stk500boot.c  **** #endif
1763:stk500boot.c  **** 
1764:stk500boot.c  **** #ifdef DDRF
1765:stk500boot.c  **** 	PrintAvailablePort('F');
1766:stk500boot.c  **** #endif
1767:stk500boot.c  **** 
1768:stk500boot.c  **** #ifdef DDRG
1769:stk500boot.c  **** 	PrintAvailablePort('G');
1770:stk500boot.c  **** #endif
1771:stk500boot.c  **** 
1772:stk500boot.c  **** #ifdef DDRH
1773:stk500boot.c  **** 	PrintAvailablePort('H');
1774:stk500boot.c  **** #endif
1775:stk500boot.c  **** 
1776:stk500boot.c  **** #ifdef DDRI
1777:stk500boot.c  **** 	PrintAvailablePort('I');
1778:stk500boot.c  **** #endif
1779:stk500boot.c  **** 
1780:stk500boot.c  **** #ifdef DDRJ
1781:stk500boot.c  **** 	PrintAvailablePort('J');
1782:stk500boot.c  **** #endif
1783:stk500boot.c  **** 
1784:stk500boot.c  **** #ifdef DDRK
1785:stk500boot.c  **** 	PrintAvailablePort('K');
1786:stk500boot.c  **** #endif
1787:stk500boot.c  **** 
1788:stk500boot.c  **** #ifdef DDRL
1789:stk500boot.c  **** 	PrintAvailablePort('L');
1790:stk500boot.c  **** #endif
1791:stk500boot.c  **** 
1792:stk500boot.c  **** }
1793:stk500boot.c  **** 
1794:stk500boot.c  **** //************************************************************************
1795:stk500boot.c  **** static void	AVR_PortOutput(void)
1796:stk500boot.c  **** {
1797:stk500boot.c  **** char	portLetter;
1798:stk500boot.c  **** char	getCharFlag;
1799:stk500boot.c  **** 
1800:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_WHAT_PORT, 0);
1801:stk500boot.c  **** 
1802:stk500boot.c  **** 	portLetter	=	recchar();
1803:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
1804:stk500boot.c  **** 	sendchar(portLetter);
1805:stk500boot.c  **** 	PrintNewLine();
1806:stk500boot.c  **** 
1807:stk500boot.c  **** 	if ((portLetter >= 'A') && (portLetter <= 'Z'))
1808:stk500boot.c  **** 	{
1809:stk500boot.c  **** 		getCharFlag	=	true;
1810:stk500boot.c  **** 		switch(portLetter)
1811:stk500boot.c  **** 		{
1812:stk500boot.c  **** 		#ifdef DDRA
1813:stk500boot.c  **** 			case 'A':
1814:stk500boot.c  **** 				DDRA	=	0xff;
1815:stk500boot.c  **** 				while (!Serial_Available())
1816:stk500boot.c  **** 				{
1817:stk500boot.c  **** 					PORTA	^=	0xff;
1818:stk500boot.c  **** 					delay_ms(200);
1819:stk500boot.c  **** 				}
1820:stk500boot.c  **** 				PORTA	=	0;
1821:stk500boot.c  **** 				break;
1822:stk500boot.c  **** 		#endif
1823:stk500boot.c  **** 
1824:stk500boot.c  **** 		#ifdef DDRB
1825:stk500boot.c  **** 			case 'B':
1826:stk500boot.c  **** 				DDRB	=	0xff;
1827:stk500boot.c  **** 				while (!Serial_Available())
1828:stk500boot.c  **** 				{
1829:stk500boot.c  **** 					PORTB	^=	0xff;
1830:stk500boot.c  **** 					delay_ms(200);
1831:stk500boot.c  **** 				}
1832:stk500boot.c  **** 				PORTB	=	0;
1833:stk500boot.c  **** 				break;
1834:stk500boot.c  **** 		#endif
1835:stk500boot.c  **** 
1836:stk500boot.c  **** 		#ifdef DDRC
1837:stk500boot.c  **** 			case 'C':
1838:stk500boot.c  **** 				DDRC	=	0xff;
1839:stk500boot.c  **** 				while (!Serial_Available())
1840:stk500boot.c  **** 				{
1841:stk500boot.c  **** 					PORTC	^=	0xff;
1842:stk500boot.c  **** 					delay_ms(200);
1843:stk500boot.c  **** 				}
1844:stk500boot.c  **** 				PORTC	=	0;
1845:stk500boot.c  **** 				break;
1846:stk500boot.c  **** 		#endif
1847:stk500boot.c  **** 
1848:stk500boot.c  **** 		#ifdef DDRD
1849:stk500boot.c  **** 			case 'D':
1850:stk500boot.c  **** 				DDRD	=	0xff;
1851:stk500boot.c  **** 				while (!Serial_Available())
1852:stk500boot.c  **** 				{
1853:stk500boot.c  **** 					PORTD	^=	0xff;
1854:stk500boot.c  **** 					delay_ms(200);
1855:stk500boot.c  **** 				}
1856:stk500boot.c  **** 				PORTD	=	0;
1857:stk500boot.c  **** 				break;
1858:stk500boot.c  **** 		#endif
1859:stk500boot.c  **** 
1860:stk500boot.c  **** 		#ifdef DDRE
1861:stk500boot.c  **** 			case 'E':
1862:stk500boot.c  **** 				DDRE	=	0xff;
1863:stk500boot.c  **** 				while (!Serial_Available())
1864:stk500boot.c  **** 				{
1865:stk500boot.c  **** 					PORTE	^=	0xff;
1866:stk500boot.c  **** 					delay_ms(200);
1867:stk500boot.c  **** 				}
1868:stk500boot.c  **** 				PORTE	=	0;
1869:stk500boot.c  **** 				break;
1870:stk500boot.c  **** 		#endif
1871:stk500boot.c  **** 
1872:stk500boot.c  **** 		#ifdef DDRF
1873:stk500boot.c  **** 			case 'F':
1874:stk500boot.c  **** 				DDRF	=	0xff;
1875:stk500boot.c  **** 				while (!Serial_Available())
1876:stk500boot.c  **** 				{
1877:stk500boot.c  **** 					PORTF	^=	0xff;
1878:stk500boot.c  **** 					delay_ms(200);
1879:stk500boot.c  **** 				}
1880:stk500boot.c  **** 				PORTF	=	0;
1881:stk500boot.c  **** 				break;
1882:stk500boot.c  **** 		#endif
1883:stk500boot.c  **** 
1884:stk500boot.c  **** 		#ifdef DDRG
1885:stk500boot.c  **** 			case 'G':
1886:stk500boot.c  **** 				DDRG	=	0xff;
1887:stk500boot.c  **** 				while (!Serial_Available())
1888:stk500boot.c  **** 				{
1889:stk500boot.c  **** 					PORTG	^=	0xff;
1890:stk500boot.c  **** 					delay_ms(200);
1891:stk500boot.c  **** 				}
1892:stk500boot.c  **** 				PORTG	=	0;
1893:stk500boot.c  **** 				break;
1894:stk500boot.c  **** 		#endif
1895:stk500boot.c  **** 
1896:stk500boot.c  **** 		#ifdef DDRH
1897:stk500boot.c  **** 			case 'H':
1898:stk500boot.c  **** 				DDRH	=	0xff;
1899:stk500boot.c  **** 				while (!Serial_Available())
1900:stk500boot.c  **** 				{
1901:stk500boot.c  **** 					PORTH	^=	0xff;
1902:stk500boot.c  **** 					delay_ms(200);
1903:stk500boot.c  **** 				}
1904:stk500boot.c  **** 				PORTH	=	0;
1905:stk500boot.c  **** 				break;
1906:stk500boot.c  **** 		#endif
1907:stk500boot.c  **** 
1908:stk500boot.c  **** 		#ifdef DDRI
1909:stk500boot.c  **** 			case 'I':
1910:stk500boot.c  **** 				DDRI	=	0xff;
1911:stk500boot.c  **** 				while (!Serial_Available())
1912:stk500boot.c  **** 				{
1913:stk500boot.c  **** 					PORTI	^=	0xff;
1914:stk500boot.c  **** 					delay_ms(200);
1915:stk500boot.c  **** 				}
1916:stk500boot.c  **** 				PORTI	=	0;
1917:stk500boot.c  **** 				break;
1918:stk500boot.c  **** 		#endif
1919:stk500boot.c  **** 
1920:stk500boot.c  **** 		#ifdef DDRJ
1921:stk500boot.c  **** 			case 'J':
1922:stk500boot.c  **** 				DDRJ	=	0xff;
1923:stk500boot.c  **** 				while (!Serial_Available())
1924:stk500boot.c  **** 				{
1925:stk500boot.c  **** 					PORTJ	^=	0xff;
1926:stk500boot.c  **** 					delay_ms(200);
1927:stk500boot.c  **** 				}
1928:stk500boot.c  **** 				PORTJ	=	0;
1929:stk500boot.c  **** 				break;
1930:stk500boot.c  **** 		#endif
1931:stk500boot.c  **** 
1932:stk500boot.c  **** 		#ifdef DDRK
1933:stk500boot.c  **** 			case 'K':
1934:stk500boot.c  **** 				DDRK	=	0xff;
1935:stk500boot.c  **** 				while (!Serial_Available())
1936:stk500boot.c  **** 				{
1937:stk500boot.c  **** 					PORTK	^=	0xff;
1938:stk500boot.c  **** 					delay_ms(200);
1939:stk500boot.c  **** 				}
1940:stk500boot.c  **** 				PORTK	=	0;
1941:stk500boot.c  **** 				break;
1942:stk500boot.c  **** 		#endif
1943:stk500boot.c  **** 
1944:stk500boot.c  **** 		#ifdef DDRL
1945:stk500boot.c  **** 			case 'L':
1946:stk500boot.c  **** 				DDRL	=	0xff;
1947:stk500boot.c  **** 				while (!Serial_Available())
1948:stk500boot.c  **** 				{
1949:stk500boot.c  **** 					PORTL	^=	0xff;
1950:stk500boot.c  **** 					delay_ms(200);
1951:stk500boot.c  **** 				}
1952:stk500boot.c  **** 				PORTL	=	0;
1953:stk500boot.c  **** 				break;
1954:stk500boot.c  **** 		#endif
1955:stk500boot.c  **** 
1956:stk500boot.c  **** 			default:
1957:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_PortNotSupported, 0);
1958:stk500boot.c  **** 				getCharFlag	=	false;
1959:stk500boot.c  **** 				break;
1960:stk500boot.c  **** 		}
1961:stk500boot.c  **** 		if (getCharFlag)
1962:stk500boot.c  **** 		{
1963:stk500boot.c  **** 			recchar();
1964:stk500boot.c  **** 		}
1965:stk500boot.c  **** 	}
1966:stk500boot.c  **** 	else
1967:stk500boot.c  **** 	{
1968:stk500boot.c  **** 		PrintFromPROGMEMln(gTextMsg_MustBeLetter, 0);
1969:stk500boot.c  **** 	}
1970:stk500boot.c  **** }
1971:stk500boot.c  **** 
1972:stk500boot.c  **** 
1973:stk500boot.c  **** //*******************************************************************
1974:stk500boot.c  **** static void PrintHelp(void)
1975:stk500boot.c  **** {
1976:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 0);
1977:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
1978:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
1979:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
1980:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
1981:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
1982:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
1983:stk500boot.c  **** 
1984:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 0);
1985:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
1986:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
1987:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
1988:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
1989:stk500boot.c  **** }
1990:stk500boot.c  **** 
1991:stk500boot.c  **** //************************************************************************
1992:stk500boot.c  **** static void	RunMonitor(void)
1993:stk500boot.c  **** {
1994:stk500boot.c  **** char			keepGoing;
1995:stk500boot.c  **** unsigned char	theChar;
1996:stk500boot.c  **** int				ii, jj;
1997:stk500boot.c  **** 
1998:stk500boot.c  **** 	for (ii=0; ii<5; ii++)
1999:stk500boot.c  **** 	{
2000:stk500boot.c  **** 		for (jj=0; jj<25; jj++)
2001:stk500boot.c  **** 		{
2002:stk500boot.c  **** 			sendchar('!');
 1124               		.loc 1 2002 0
 1125 0180 81E2      		ldi r24,lo8(33)
 1126 0182 0E94 0000 		call sendchar
 1127               	.LVL109:
 1128 0186 F1E0      		ldi r31,1
 1129 0188 AF1A      		sub r10,r31
 1130 018a B108      		sbc r11,__zero_reg__
 1131               	.LVL110:
2000:stk500boot.c  **** 		{
 1132               		.loc 1 2000 0
 1133 018c 01F4      		brne .L63
2003:stk500boot.c  **** 		}
2004:stk500boot.c  **** 		PrintNewLine();
 1134               		.loc 1 2004 0
 1135 018e 0E94 0000 		call PrintNewLine
 1136               	.LVL111:
 1137 0192 0150      		subi r16,1
 1138 0194 1109      		sbc r17,__zero_reg__
 1139               	.LVL112:
1998:stk500boot.c  **** 	{
 1140               		.loc 1 1998 0
 1141 0196 01F4      		brne .L64
2005:stk500boot.c  **** 	}
2006:stk500boot.c  **** 
2007:stk500boot.c  **** 	gRamIndex			=	0;
 1142               		.loc 1 2007 0
 1143 0198 1092 0000 		sts gRamIndex,__zero_reg__
 1144 019c 1092 0000 		sts gRamIndex+1,__zero_reg__
 1145 01a0 1092 0000 		sts gRamIndex+2,__zero_reg__
 1146 01a4 1092 0000 		sts gRamIndex+3,__zero_reg__
2008:stk500boot.c  **** 	gFlashIndex			=	0;
 1147               		.loc 1 2008 0
 1148 01a8 1092 0000 		sts gFlashIndex,__zero_reg__
 1149 01ac 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1150 01b0 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1151 01b4 1092 0000 		sts gFlashIndex+3,__zero_reg__
2009:stk500boot.c  **** 	gEepromIndex		=	0;
 1152               		.loc 1 2009 0
 1153 01b8 1092 0000 		sts gEepromIndex,__zero_reg__
 1154 01bc 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1155 01c0 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1156 01c4 1092 0000 		sts gEepromIndex+3,__zero_reg__
2010:stk500boot.c  **** 
2011:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_Explorer, 0);
 1157               		.loc 1 2011 0
 1158 01c8 60E0      		ldi r22,0
 1159 01ca 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1160 01cc 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1161 01ce 0E94 0000 		call PrintFromPROGMEMln
 1162               	.LVL113:
 1163               	.LBB144:
 1164               	.LBB145:
1874:stk500boot.c  **** 				while (!Serial_Available())
 1165               		.loc 1 1874 0
 1166 01d2 1FEF      		ldi r17,lo8(-1)
 1167               	.LVL114:
 1168               	.L202:
 1169               	.LBE145:
 1170               	.LBE144:
2012:stk500boot.c  **** 
2013:stk500boot.c  **** 	keepGoing	=	1;
2014:stk500boot.c  **** 	while (keepGoing)
2015:stk500boot.c  **** 	{
2016:stk500boot.c  **** 		PrintFromPROGMEM(gTextMsg_Prompt, 0);
 1171               		.loc 1 2016 0
 1172 01d4 60E0      		ldi r22,0
 1173 01d6 80E0      		ldi r24,lo8(gTextMsg_Prompt)
 1174 01d8 90E0      		ldi r25,hi8(gTextMsg_Prompt)
 1175 01da 0E94 0000 		call PrintFromPROGMEM
 1176               	.LVL115:
2017:stk500boot.c  **** 		theChar	=	recchar();
 1177               		.loc 1 2017 0
 1178 01de 0E94 0000 		call recchar
 1179               	.LVL116:
 1180 01e2 082F      		mov r16,r24
 1181               	.LVL117:
2018:stk500boot.c  **** 		if (theChar >= 0x60)
 1182               		.loc 1 2018 0
 1183 01e4 8036      		cpi r24,lo8(96)
 1184 01e6 00F0      		brlo .L66
2019:stk500boot.c  **** 		{
2020:stk500boot.c  **** 			theChar	=	theChar & 0x5F;
 1185               		.loc 1 2020 0
 1186 01e8 0F75      		andi r16,lo8(95)
 1187               	.LVL118:
 1188               	.L66:
2021:stk500boot.c  **** 		}
2022:stk500boot.c  **** 
2023:stk500boot.c  **** 		if (theChar >= 0x20)
 1189               		.loc 1 2023 0
 1190 01ea 0032      		cpi r16,lo8(32)
 1191 01ec 00F0      		brlo .L67
2024:stk500boot.c  **** 		{
2025:stk500boot.c  **** 			sendchar(theChar);
 1192               		.loc 1 2025 0
 1193 01ee 802F      		mov r24,r16
 1194 01f0 0E94 0000 		call sendchar
 1195               	.LVL119:
2026:stk500boot.c  **** 			sendchar(0x20);
 1196               		.loc 1 2026 0
 1197 01f4 80E2      		ldi r24,lo8(32)
 1198 01f6 0E94 0000 		call sendchar
 1199               	.LVL120:
 1200               	.L67:
2027:stk500boot.c  **** 		}
2028:stk500boot.c  **** 
2029:stk500boot.c  **** 		switch(theChar)
 1201               		.loc 1 2029 0
 1202 01fa 0634      		cpi r16,lo8(70)
 1203 01fc 01F4      		brne .+2
 1204 01fe 00C0      		rjmp .L69
 1205 0200 00F0      		brlo .+2
 1206 0202 00C0      		rjmp .L70
 1207 0204 0034      		cpi r16,lo8(64)
 1208 0206 01F4      		brne .+2
 1209 0208 00C0      		rjmp .L71
 1210 020a 00F0      		brlo .+2
 1211 020c 00C0      		rjmp .L72
 1212 020e 0033      		cpi r16,lo8(48)
 1213 0210 01F4      		brne .+2
 1214 0212 00C0      		rjmp .L73
 1215 0214 0F33      		cpi r16,lo8(63)
 1216 0216 01F0      		breq .+2
 1217 0218 00C0      		rjmp .L68
2030:stk500boot.c  **** 		{
2031:stk500boot.c  **** 			case '0':
2032:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_0, 2);
2033:stk500boot.c  **** 				gFlashIndex		=	0;
2034:stk500boot.c  **** 				gRamIndex		=	0;
2035:stk500boot.c  **** 				gEepromIndex	=	0;
2036:stk500boot.c  **** 				break;
2037:stk500boot.c  **** 
2038:stk500boot.c  **** 			case '?':
2039:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 2);
 1218               		.loc 1 2039 0
 1219 021a 62E0      		ldi r22,lo8(2)
 1220 021c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1221 021e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1222 0220 0E94 0000 		call PrintFromPROGMEMln
 1223               	.LVL121:
 1224               	.LBB170:
 1225               	.LBB171:
1381:stk500boot.c  **** 
 1226               		.loc 1 1381 0
 1227 0224 60E0      		ldi r22,0
 1228 0226 80E0      		ldi r24,lo8(gTextMsg_Explorer)
 1229 0228 90E0      		ldi r25,hi8(gTextMsg_Explorer)
 1230 022a 0E94 0000 		call PrintFromPROGMEMln
 1231               	.LVL122:
1383:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_DATE_STR, 0);
 1232               		.loc 1 1383 0
 1233 022e 60E0      		ldi r22,0
 1234 0230 80E0      		ldi r24,lo8(gTextMsg_COMPILED_ON)
 1235 0232 90E0      		ldi r25,hi8(gTextMsg_COMPILED_ON)
 1236 0234 0E94 0000 		call PrintFromPROGMEM
 1237               	.LVL123:
1384:stk500boot.c  **** 
 1238               		.loc 1 1384 0
 1239 0238 60E0      		ldi r22,0
 1240 023a 80E0      		ldi r24,lo8(gTextMsg_GCC_DATE_STR)
 1241 023c 90E0      		ldi r25,hi8(gTextMsg_GCC_DATE_STR)
 1242 023e 0E94 0000 		call PrintFromPROGMEMln
 1243               	.LVL124:
1386:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1244               		.loc 1 1386 0
 1245 0242 60E0      		ldi r22,0
 1246 0244 80E0      		ldi r24,lo8(gTextMsg_CPU_Type)
 1247 0246 90E0      		ldi r25,hi8(gTextMsg_CPU_Type)
 1248 0248 0E94 0000 		call PrintFromPROGMEM
 1249               	.LVL125:
1387:stk500boot.c  **** 
 1250               		.loc 1 1387 0
 1251 024c 60E0      		ldi r22,0
 1252 024e 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1253 0250 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1254 0252 0E94 0000 		call PrintFromPROGMEMln
 1255               	.LVL126:
1389:stk500boot.c  **** 	PrintDecInt(__AVR_ARCH__, 1);
 1256               		.loc 1 1389 0
 1257 0256 60E0      		ldi r22,0
 1258 0258 80E0      		ldi r24,lo8(gTextMsg_AVR_ARCH)
 1259 025a 90E0      		ldi r25,hi8(gTextMsg_AVR_ARCH)
 1260 025c 0E94 0000 		call PrintFromPROGMEM
 1261               	.LVL127:
 1262               	.LBB172:
 1263               	.LBB173:
1370:stk500boot.c  **** }
 1264               		.loc 1 1370 0
 1265 0260 86E3      		ldi r24,lo8(54)
 1266 0262 0E94 0000 		call sendchar
 1267               	.LVL128:
 1268               	.LBE173:
 1269               	.LBE172:
1391:stk500boot.c  **** 
 1270               		.loc 1 1391 0
 1271 0266 0E94 0000 		call PrintNewLine
 1272               	.LVL129:
1393:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_GCC_VERSION_STR, 0);
 1273               		.loc 1 1393 0
 1274 026a 60E0      		ldi r22,0
 1275 026c 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION)
 1276 026e 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION)
 1277 0270 0E94 0000 		call PrintFromPROGMEM
 1278               	.LVL130:
1394:stk500boot.c  **** 
 1279               		.loc 1 1394 0
 1280 0274 60E0      		ldi r22,0
 1281 0276 80E0      		ldi r24,lo8(gTextMsg_GCC_VERSION_STR)
 1282 0278 90E0      		ldi r25,hi8(gTextMsg_GCC_VERSION_STR)
 1283 027a 0E94 0000 		call PrintFromPROGMEMln
 1284               	.LVL131:
1397:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_AVR_LIBC_VER_STR, 0);
 1285               		.loc 1 1397 0
 1286 027e 60E0      		ldi r22,0
 1287 0280 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC)
 1288 0282 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC)
 1289 0284 0E94 0000 		call PrintFromPROGMEM
 1290               	.LVL132:
1398:stk500boot.c  **** 
 1291               		.loc 1 1398 0
 1292 0288 60E0      		ldi r22,0
 1293 028a 80E0      		ldi r24,lo8(gTextMsg_AVR_LIBC_VER_STR)
 1294 028c 90E0      		ldi r25,hi8(gTextMsg_AVR_LIBC_VER_STR)
 1295 028e 0E94 0000 		call PrintFromPROGMEMln
 1296               	.LVL133:
1401:stk500boot.c  **** 	//*	these can be found in avr/iomxxx.h
 1297               		.loc 1 1401 0
 1298 0292 60E0      		ldi r22,0
 1299 0294 80E0      		ldi r24,lo8(gTextMsg_CPU_SIGNATURE)
 1300 0296 90E0      		ldi r25,hi8(gTextMsg_CPU_SIGNATURE)
 1301 0298 0E94 0000 		call PrintFromPROGMEM
 1302               	.LVL134:
1403:stk500boot.c  **** 	PrintHexByte(SIGNATURE_1);
 1303               		.loc 1 1403 0
 1304 029c 8EE1      		ldi r24,lo8(30)
 1305 029e 0E94 0000 		call PrintHexByte
 1306               	.LVL135:
1404:stk500boot.c  **** 	PrintHexByte(SIGNATURE_2);
 1307               		.loc 1 1404 0
 1308 02a2 88E9      		ldi r24,lo8(-104)
 1309 02a4 0E94 0000 		call PrintHexByte
 1310               	.LVL136:
1405:stk500boot.c  **** 	PrintNewLine();
 1311               		.loc 1 1405 0
 1312 02a8 81E0      		ldi r24,lo8(1)
 1313 02aa 0E94 0000 		call PrintHexByte
 1314               	.LVL137:
1406:stk500boot.c  **** #endif
 1315               		.loc 1 1406 0
 1316 02ae 0E94 0000 		call PrintNewLine
 1317               	.LVL138:
1412:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOW_FUSE_BITS);
 1318               		.loc 1 1412 0
 1319 02b2 60E0      		ldi r22,0
 1320 02b4 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOW)
 1321 02b6 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOW)
 1322 02b8 0E94 0000 		call PrintFromPROGMEM
 1323               	.LVL139:
 1324               	.LBB174:
1413:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1325               		.loc 1 1413 0
 1326 02bc 29E0      		ldi r18,lo8(9)
 1327 02be E0E0      		ldi r30,0
 1328 02c0 F0E0      		ldi r31,0
 1329               	/* #APP */
 1330               	 ;  1413 "stk500boot.c" 1
 1331 02c2 2093 5700 		sts 87, r18
 1332 02c6 8491      		lpm r24, Z
 1333               		
 1334               	 ;  0 "" 2
 1335               	.LVL140:
 1336               	/* #NOAPP */
 1337               	.LBE174:
1414:stk500boot.c  **** 	PrintNewLine();
 1338               		.loc 1 1414 0
 1339 02c8 0E94 0000 		call PrintHexByte
 1340               	.LVL141:
1415:stk500boot.c  **** 
 1341               		.loc 1 1415 0
 1342 02cc 0E94 0000 		call PrintNewLine
 1343               	.LVL142:
1417:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_HIGH_FUSE_BITS);
 1344               		.loc 1 1417 0
 1345 02d0 60E0      		ldi r22,0
 1346 02d2 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_HIGH)
 1347 02d4 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_HIGH)
 1348 02d6 0E94 0000 		call PrintFromPROGMEM
 1349               	.LVL143:
 1350               	.LBB175:
1418:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1351               		.loc 1 1418 0
 1352 02da 29E0      		ldi r18,lo8(9)
 1353 02dc E3E0      		ldi r30,lo8(3)
 1354 02de F0E0      		ldi r31,0
 1355               	/* #APP */
 1356               	 ;  1418 "stk500boot.c" 1
 1357 02e0 2093 5700 		sts 87, r18
 1358 02e4 8491      		lpm r24, Z
 1359               		
 1360               	 ;  0 "" 2
 1361               	.LVL144:
 1362               	/* #NOAPP */
 1363               	.LBE175:
1419:stk500boot.c  **** 	PrintNewLine();
 1364               		.loc 1 1419 0
 1365 02e6 0E94 0000 		call PrintHexByte
 1366               	.LVL145:
1420:stk500boot.c  **** 
 1367               		.loc 1 1420 0
 1368 02ea 0E94 0000 		call PrintNewLine
 1369               	.LVL146:
1422:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_EXTENDED_FUSE_BITS);
 1370               		.loc 1 1422 0
 1371 02ee 60E0      		ldi r22,0
 1372 02f0 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_EXT)
 1373 02f2 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_EXT)
 1374 02f4 0E94 0000 		call PrintFromPROGMEM
 1375               	.LVL147:
 1376               	.LBB176:
1423:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1377               		.loc 1 1423 0
 1378 02f8 E2E0      		ldi r30,lo8(2)
 1379 02fa F0E0      		ldi r31,0
 1380 02fc 39E0      		ldi r19,lo8(9)
 1381               	/* #APP */
 1382               	 ;  1423 "stk500boot.c" 1
 1383 02fe 3093 5700 		sts 87, r19
 1384 0302 8491      		lpm r24, Z
 1385               		
 1386               	 ;  0 "" 2
 1387               	.LVL148:
 1388               	/* #NOAPP */
 1389               	.LBE176:
1424:stk500boot.c  **** 	PrintNewLine();
 1390               		.loc 1 1424 0
 1391 0304 0E94 0000 		call PrintHexByte
 1392               	.LVL149:
1425:stk500boot.c  **** 
 1393               		.loc 1 1425 0
 1394 0308 0E94 0000 		call PrintNewLine
 1395               	.LVL150:
1427:stk500boot.c  **** 	fuseByte	=	boot_lock_fuse_bits_get(GET_LOCK_BITS);
 1396               		.loc 1 1427 0
 1397 030c 60E0      		ldi r22,0
 1398 030e 80E0      		ldi r24,lo8(gTextMsg_FUSE_BYTE_LOCK)
 1399 0310 90E0      		ldi r25,hi8(gTextMsg_FUSE_BYTE_LOCK)
 1400 0312 0E94 0000 		call PrintFromPROGMEM
 1401               	.LVL151:
 1402               	.LBB177:
1428:stk500boot.c  **** 	PrintHexByte(fuseByte);
 1403               		.loc 1 1428 0
 1404 0316 E1E0      		ldi r30,lo8(1)
 1405 0318 F0E0      		ldi r31,0
 1406 031a 49E0      		ldi r20,lo8(9)
 1407               	/* #APP */
 1408               	 ;  1428 "stk500boot.c" 1
 1409 031c 4093 5700 		sts 87, r20
 1410 0320 8491      		lpm r24, Z
 1411               		
 1412               	 ;  0 "" 2
 1413               	.LVL152:
 1414               	/* #NOAPP */
 1415               	.LBE177:
1429:stk500boot.c  **** 	PrintNewLine();
 1416               		.loc 1 1429 0
 1417 0322 0E94 0000 		call PrintHexByte
 1418               	.LVL153:
1430:stk500boot.c  **** 
 1419               		.loc 1 1430 0
 1420 0326 0E94 0000 		call PrintNewLine
 1421               	.LVL154:
 1422 032a 00C0      		rjmp .L202
 1423               	.LVL155:
 1424               	.L72:
 1425               	.LBE171:
 1426               	.LBE170:
2029:stk500boot.c  **** 		{
 1427               		.loc 1 2029 0
 1428 032c 0234      		cpi r16,lo8(66)
 1429 032e 01F4      		brne .+2
 1430 0330 00C0      		rjmp .L75
 1431 0332 0534      		cpi r16,lo8(69)
 1432 0334 01F4      		brne .+2
 1433 0336 00C0      		rjmp .L76
 1434 0338 00C0      		rjmp .L68
 1435               	.L70:
 1436 033a 0135      		cpi r16,lo8(81)
 1437 033c 01F4      		brne .+2
 1438 033e 00C0      		rjmp .L77
 1439 0340 00F4      		brsh .L78
 1440 0342 0834      		cpi r16,lo8(72)
 1441 0344 01F4      		brne .+2
 1442 0346 00C0      		rjmp .L79
 1443 0348 0C34      		cpi r16,lo8(76)
 1444 034a 01F0      		breq .+2
 1445 034c 00C0      		rjmp .L68
2040:stk500boot.c  **** 				PrintCPUstats();
2041:stk500boot.c  **** 				break;
2042:stk500boot.c  **** 
2043:stk500boot.c  **** 			case '@':
2044:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 2);
2045:stk500boot.c  **** 				EEPROMtest();
2046:stk500boot.c  **** 				break;
2047:stk500boot.c  **** 
2048:stk500boot.c  **** 			case 'B':
2049:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 2);
2050:stk500boot.c  **** 				BlinkLED();
2051:stk500boot.c  **** 				break;
2052:stk500boot.c  **** 
2053:stk500boot.c  **** 			case 'E':
2054:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 2);
2055:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
2056:stk500boot.c  **** 				gEepromIndex	+=	256;
2057:stk500boot.c  **** 				if (gEepromIndex > E2END)
2058:stk500boot.c  **** 				{
2059:stk500boot.c  **** 					gEepromIndex	=	0;
2060:stk500boot.c  **** 				}
2061:stk500boot.c  **** 				break;
2062:stk500boot.c  **** 
2063:stk500boot.c  **** 			case 'F':
2064:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 2);
2065:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
2066:stk500boot.c  **** 				gFlashIndex	+=	256;
2067:stk500boot.c  **** 				break;
2068:stk500boot.c  **** 
2069:stk500boot.c  **** 			case 'H':
2070:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 2);
2071:stk500boot.c  **** 				PrintHelp();
2072:stk500boot.c  **** 				break;
2073:stk500boot.c  **** 
2074:stk500boot.c  **** 			case 'L':
2075:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_L, 2);
 1446               		.loc 1 2075 0
 1447 034e 62E0      		ldi r22,lo8(2)
 1448 0350 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1449 0352 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1450 0354 0E94 0000 		call PrintFromPROGMEMln
 1451               	.LVL156:
 1452               	.LBB178:
 1453               	.LBB179:
1745:stk500boot.c  **** #endif
 1454               		.loc 1 1745 0
 1455 0358 81E4      		ldi r24,lo8(65)
 1456 035a 0E94 0000 		call PrintAvailablePort
 1457               	.LVL157:
1749:stk500boot.c  **** #endif
 1458               		.loc 1 1749 0
 1459 035e 82E4      		ldi r24,lo8(66)
 1460 0360 0E94 0000 		call PrintAvailablePort
 1461               	.LVL158:
1753:stk500boot.c  **** #endif
 1462               		.loc 1 1753 0
 1463 0364 83E4      		ldi r24,lo8(67)
 1464 0366 0E94 0000 		call PrintAvailablePort
 1465               	.LVL159:
1757:stk500boot.c  **** #endif
 1466               		.loc 1 1757 0
 1467 036a 84E4      		ldi r24,lo8(68)
 1468 036c 0E94 0000 		call PrintAvailablePort
 1469               	.LVL160:
1761:stk500boot.c  **** #endif
 1470               		.loc 1 1761 0
 1471 0370 85E4      		ldi r24,lo8(69)
 1472 0372 0E94 0000 		call PrintAvailablePort
 1473               	.LVL161:
1765:stk500boot.c  **** #endif
 1474               		.loc 1 1765 0
 1475 0376 86E4      		ldi r24,lo8(70)
 1476 0378 0E94 0000 		call PrintAvailablePort
 1477               	.LVL162:
1769:stk500boot.c  **** #endif
 1478               		.loc 1 1769 0
 1479 037c 87E4      		ldi r24,lo8(71)
 1480 037e 0E94 0000 		call PrintAvailablePort
 1481               	.LVL163:
1773:stk500boot.c  **** #endif
 1482               		.loc 1 1773 0
 1483 0382 88E4      		ldi r24,lo8(72)
 1484 0384 0E94 0000 		call PrintAvailablePort
 1485               	.LVL164:
1781:stk500boot.c  **** #endif
 1486               		.loc 1 1781 0
 1487 0388 8AE4      		ldi r24,lo8(74)
 1488 038a 0E94 0000 		call PrintAvailablePort
 1489               	.LVL165:
1785:stk500boot.c  **** #endif
 1490               		.loc 1 1785 0
 1491 038e 8BE4      		ldi r24,lo8(75)
 1492 0390 0E94 0000 		call PrintAvailablePort
 1493               	.LVL166:
1789:stk500boot.c  **** #endif
 1494               		.loc 1 1789 0
 1495 0394 8CE4      		ldi r24,lo8(76)
 1496 0396 0E94 0000 		call PrintAvailablePort
 1497               	.LVL167:
 1498 039a 00C0      		rjmp .L202
 1499               	.L78:
 1500               	.LBE179:
 1501               	.LBE178:
2029:stk500boot.c  **** 		{
 1502               		.loc 1 2029 0
 1503 039c 0635      		cpi r16,lo8(86)
 1504 039e 01F4      		brne .+2
 1505 03a0 00C0      		rjmp .L81
 1506 03a2 0935      		cpi r16,lo8(89)
 1507 03a4 01F4      		brne .+2
 1508 03a6 00C0      		rjmp .L82
 1509 03a8 0235      		cpi r16,lo8(82)
 1510 03aa 01F0      		breq .+2
 1511 03ac 00C0      		rjmp .L68
2076:stk500boot.c  **** 				ListAvailablePorts();
2077:stk500boot.c  **** 				break;
2078:stk500boot.c  **** 
2079:stk500boot.c  **** 			case 'Q':
2080:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 2);
2081:stk500boot.c  **** 				keepGoing	=	false;
2082:stk500boot.c  **** 				break;
2083:stk500boot.c  **** 
2084:stk500boot.c  **** 			case 'R':
2085:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 2);
 1512               		.loc 1 2085 0
 1513 03ae 62E0      		ldi r22,lo8(2)
 1514 03b0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1515 03b2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1516 03b4 0E94 0000 		call PrintFromPROGMEMln
 1517               	.LVL168:
2086:stk500boot.c  **** 				DumpHex(kDUMP_RAM, gRamIndex, 16);
 1518               		.loc 1 2086 0
 1519 03b8 4091 0000 		lds r20,gRamIndex
 1520 03bc 5091 0000 		lds r21,gRamIndex+1
 1521 03c0 6091 0000 		lds r22,gRamIndex+2
 1522 03c4 7091 0000 		lds r23,gRamIndex+3
 1523 03c8 82E0      		ldi r24,lo8(2)
 1524 03ca 0E94 0000 		call DumpHex.constprop.0
 1525               	.LVL169:
2087:stk500boot.c  **** 				gRamIndex	+=	256;
 1526               		.loc 1 2087 0
 1527 03ce 8091 0000 		lds r24,gRamIndex
 1528 03d2 9091 0000 		lds r25,gRamIndex+1
 1529 03d6 A091 0000 		lds r26,gRamIndex+2
 1530 03da B091 0000 		lds r27,gRamIndex+3
 1531 03de 9F5F      		subi r25,-1
 1532 03e0 AF4F      		sbci r26,-1
 1533 03e2 BF4F      		sbci r27,-1
 1534 03e4 8093 0000 		sts gRamIndex,r24
 1535 03e8 9093 0000 		sts gRamIndex+1,r25
 1536 03ec A093 0000 		sts gRamIndex+2,r26
 1537 03f0 B093 0000 		sts gRamIndex+3,r27
 1538 03f4 00C0      		rjmp .L202
 1539               	.L73:
2032:stk500boot.c  **** 				gFlashIndex		=	0;
 1540               		.loc 1 2032 0
 1541 03f6 62E0      		ldi r22,lo8(2)
 1542 03f8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1543 03fa 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1544 03fc 0E94 0000 		call PrintFromPROGMEMln
 1545               	.LVL170:
2033:stk500boot.c  **** 				gRamIndex		=	0;
 1546               		.loc 1 2033 0
 1547 0400 1092 0000 		sts gFlashIndex,__zero_reg__
 1548 0404 1092 0000 		sts gFlashIndex+1,__zero_reg__
 1549 0408 1092 0000 		sts gFlashIndex+2,__zero_reg__
 1550 040c 1092 0000 		sts gFlashIndex+3,__zero_reg__
2034:stk500boot.c  **** 				gEepromIndex	=	0;
 1551               		.loc 1 2034 0
 1552 0410 1092 0000 		sts gRamIndex,__zero_reg__
 1553 0414 1092 0000 		sts gRamIndex+1,__zero_reg__
 1554 0418 1092 0000 		sts gRamIndex+2,__zero_reg__
 1555 041c 1092 0000 		sts gRamIndex+3,__zero_reg__
 1556 0420 00C0      		rjmp .L273
 1557               	.L71:
2044:stk500boot.c  **** 				EEPROMtest();
 1558               		.loc 1 2044 0
 1559 0422 62E0      		ldi r22,lo8(2)
 1560 0424 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1561 0426 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1562 0428 0E94 0000 		call PrintFromPROGMEMln
 1563               	.LVL171:
 1564               	.LBB180:
 1565               	.LBB181:
1539:stk500boot.c  **** 	PrintNewLine();
 1566               		.loc 1 1539 0
 1567 042c 60E0      		ldi r22,0
 1568 042e 80E0      		ldi r24,lo8(gTextMsg_WriteToEEprom)
 1569 0430 90E0      		ldi r25,hi8(gTextMsg_WriteToEEprom)
 1570 0432 0E94 0000 		call PrintFromPROGMEMln
 1571               	.LVL172:
1540:stk500boot.c  **** 	ii			=	0;
 1572               		.loc 1 1540 0
 1573 0436 0E94 0000 		call PrintNewLine
 1574               	.LVL173:
1541:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1575               		.loc 1 1541 0
 1576 043a A12C      		mov r10,__zero_reg__
 1577 043c B12C      		mov r11,__zero_reg__
 1578               	.LVL174:
 1579               	.L85:
 1580 043e C501      		movw r24,r10
 1581 0440 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1582 0442 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1583               	.LBB182:
1543:stk500boot.c  **** #else
 1584               		.loc 1 1543 0
 1585 0444 A0E0      		ldi r26,0
 1586 0446 B0E0      		ldi r27,0
 1587               	/* #APP */
 1588               	 ;  1543 "stk500boot.c" 1
 1589 0448 ABBF      		out 59, r26
 1590 044a FC01      		movw r30, r24
 1591 044c 0791      		elpm r16, Z+
 1592               		
 1593               	 ;  0 "" 2
 1594               	.LVL175:
 1595               	/* #NOAPP */
 1596               	.LBE182:
 1597 044e 0A32      		cpi r16,lo8(42)
 1598 0450 01F4      		brne .L88
 1599               	.L91:
1561:stk500boot.c  **** 	PrintNewLine();
 1600               		.loc 1 1561 0
 1601 0452 0E94 0000 		call PrintNewLine
 1602               	.LVL176:
1562:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_ReadingEEprom, 0);
 1603               		.loc 1 1562 0
 1604 0456 0E94 0000 		call PrintNewLine
 1605               	.LVL177:
1563:stk500boot.c  **** 	PrintNewLine();
 1606               		.loc 1 1563 0
 1607 045a 60E0      		ldi r22,0
 1608 045c 80E0      		ldi r24,lo8(gTextMsg_ReadingEEprom)
 1609 045e 90E0      		ldi r25,hi8(gTextMsg_ReadingEEprom)
 1610 0460 0E94 0000 		call PrintFromPROGMEMln
 1611               	.LVL178:
1564:stk500boot.c  **** 	errorCount	=	0;
 1612               		.loc 1 1564 0
 1613 0464 0E94 0000 		call PrintNewLine
 1614               	.LVL179:
1565:stk500boot.c  **** 	ii			=	0;
 1615               		.loc 1 1565 0
 1616 0468 812C      		mov r8,__zero_reg__
 1617 046a 912C      		mov r9,__zero_reg__
1566:stk500boot.c  **** #if (FLASHEND > 0x10000)
 1618               		.loc 1 1566 0
 1619 046c A12C      		mov r10,__zero_reg__
 1620 046e B12C      		mov r11,__zero_reg__
 1621               	.LVL180:
 1622 0470 00C0      		rjmp .L89
 1623               	.LVL181:
 1624               	.L88:
1543:stk500boot.c  **** #else
 1625               		.loc 1 1543 0
 1626 0472 A114      		cp r10,__zero_reg__
 1627 0474 82E0      		ldi r24,2
 1628 0476 B806      		cpc r11,r24
 1629 0478 01F0      		breq .L91
1548:stk500boot.c  **** 		if (theChar == 0)
 1630               		.loc 1 1548 0
 1631 047a 602F      		mov r22,r16
 1632 047c C501      		movw r24,r10
 1633 047e 0E94 0000 		call eeprom_write_byte
 1634               	.LVL182:
1549:stk500boot.c  **** 		{
 1635               		.loc 1 1549 0
 1636 0482 0111      		cpse r16,__zero_reg__
 1637 0484 00C0      		rjmp .L86
1551:stk500boot.c  **** 		}
 1638               		.loc 1 1551 0
 1639 0486 60E0      		ldi r22,0
 1640 0488 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1641 048a 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1642 048c 0E94 0000 		call PrintFromPROGMEM
 1643               	.LVL183:
 1644 0490 00C0      		rjmp .L87
 1645               	.L86:
1555:stk500boot.c  **** 		}
 1646               		.loc 1 1555 0
 1647 0492 802F      		mov r24,r16
 1648 0494 0E94 0000 		call sendchar
 1649               	.LVL184:
 1650               	.L87:
1557:stk500boot.c  **** 	}
 1651               		.loc 1 1557 0
 1652 0498 5FEF      		ldi r21,-1
 1653 049a A51A      		sub r10,r21
 1654 049c B50A      		sbc r11,r21
 1655               	.LVL185:
 1656 049e 00C0      		rjmp .L85
 1657               	.LVL186:
 1658               	.L95:
1568:stk500boot.c  **** #else
 1659               		.loc 1 1568 0
 1660 04a0 A114      		cp r10,__zero_reg__
 1661 04a2 B2E0      		ldi r27,2
 1662 04a4 BB06      		cpc r11,r27
 1663 04a6 01F0      		breq .L97
1573:stk500boot.c  **** 		if (theEEPROMchar == 0)
 1664               		.loc 1 1573 0
 1665 04a8 C501      		movw r24,r10
 1666 04aa 0E94 0000 		call eeprom_read_byte
 1667               	.LVL187:
 1668 04ae 782E      		mov r7,r24
 1669               	.LVL188:
1574:stk500boot.c  **** 		{
 1670               		.loc 1 1574 0
 1671 04b0 8111      		cpse r24,__zero_reg__
 1672 04b2 00C0      		rjmp .L92
1576:stk500boot.c  **** 		}
 1673               		.loc 1 1576 0
 1674 04b4 60E0      		ldi r22,0
 1675 04b6 80E0      		ldi r24,lo8(gTextMsg_SPACE)
 1676 04b8 90E0      		ldi r25,hi8(gTextMsg_SPACE)
 1677 04ba 0E94 0000 		call PrintFromPROGMEM
 1678               	.LVL189:
 1679               	.L93:
1582:stk500boot.c  **** 		{
 1680               		.loc 1 1582 0
 1681 04be 7016      		cp r7,r16
 1682 04c0 01F0      		breq .L94
1584:stk500boot.c  **** 		}
 1683               		.loc 1 1584 0
 1684 04c2 9FEF      		ldi r25,-1
 1685 04c4 891A      		sub r8,r25
 1686 04c6 990A      		sbc r9,r25
 1687               	.LVL190:
 1688               	.L94:
1586:stk500boot.c  **** 	}
 1689               		.loc 1 1586 0
 1690 04c8 AFEF      		ldi r26,-1
 1691 04ca AA1A      		sub r10,r26
 1692 04cc BA0A      		sbc r11,r26
 1693               	.LVL191:
 1694               	.L89:
 1695 04ce C501      		movw r24,r10
 1696 04d0 8050      		subi r24,lo8(-(gTextMsg_Explorer))
 1697 04d2 9040      		sbci r25,hi8(-(gTextMsg_Explorer))
 1698               	.LBB183:
1568:stk500boot.c  **** #else
 1699               		.loc 1 1568 0
 1700 04d4 A0E0      		ldi r26,0
 1701 04d6 B0E0      		ldi r27,0
 1702               	/* #APP */
 1703               	 ;  1568 "stk500boot.c" 1
 1704 04d8 ABBF      		out 59, r26
 1705 04da FC01      		movw r30, r24
 1706 04dc 0791      		elpm r16, Z+
 1707               		
 1708               	 ;  0 "" 2
 1709               	.LVL192:
 1710               	/* #NOAPP */
 1711               	.LBE183:
 1712 04de 0A32      		cpi r16,lo8(42)
 1713 04e0 01F4      		brne .L95
 1714               	.L97:
1588:stk500boot.c  **** 	PrintNewLine();
 1715               		.loc 1 1588 0
 1716 04e2 0E94 0000 		call PrintNewLine
 1717               	.LVL193:
1589:stk500boot.c  **** 	PrintFromPROGMEM(gTextMsg_EEPROMerrorCnt, 0);
 1718               		.loc 1 1589 0
 1719 04e6 0E94 0000 		call PrintNewLine
 1720               	.LVL194:
1590:stk500boot.c  **** 	PrintDecInt(errorCount, 1);
 1721               		.loc 1 1590 0
 1722 04ea 60E0      		ldi r22,0
 1723 04ec 80E0      		ldi r24,lo8(gTextMsg_EEPROMerrorCnt)
 1724 04ee 90E0      		ldi r25,hi8(gTextMsg_EEPROMerrorCnt)
 1725 04f0 0E94 0000 		call PrintFromPROGMEM
 1726               	.LVL195:
1591:stk500boot.c  **** 	PrintNewLine();
 1727               		.loc 1 1591 0
 1728 04f4 61E0      		ldi r22,lo8(1)
 1729 04f6 70E0      		ldi r23,0
 1730 04f8 C401      		movw r24,r8
 1731 04fa 0E94 0000 		call PrintDecInt
 1732               	.LVL196:
1592:stk500boot.c  **** 	PrintNewLine();
 1733               		.loc 1 1592 0
 1734 04fe 0E94 0000 		call PrintNewLine
 1735               	.LVL197:
1593:stk500boot.c  **** 
 1736               		.loc 1 1593 0
 1737 0502 0E94 0000 		call PrintNewLine
 1738               	.LVL198:
 1739               	.L273:
1595:stk500boot.c  **** 
 1740               		.loc 1 1595 0
 1741 0506 1092 0000 		sts gEepromIndex,__zero_reg__
 1742 050a 1092 0000 		sts gEepromIndex+1,__zero_reg__
 1743 050e 1092 0000 		sts gEepromIndex+2,__zero_reg__
 1744 0512 1092 0000 		sts gEepromIndex+3,__zero_reg__
 1745 0516 00C0      		rjmp .L202
 1746               	.LVL199:
 1747               	.L92:
1580:stk500boot.c  **** 		}
 1748               		.loc 1 1580 0
 1749 0518 0E94 0000 		call sendchar
 1750               	.LVL200:
 1751 051c 00C0      		rjmp .L93
 1752               	.LVL201:
 1753               	.L75:
 1754               	.LBE181:
 1755               	.LBE180:
2049:stk500boot.c  **** 				BlinkLED();
 1756               		.loc 1 2049 0
 1757 051e 62E0      		ldi r22,lo8(2)
 1758 0520 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1759 0522 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1760 0524 0E94 0000 		call PrintFromPROGMEMln
 1761               	.LVL202:
 1762               	.LBB184:
 1763               	.LBB185:
1440:stk500boot.c  **** 	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED ON
 1764               		.loc 1 1440 0
 1765 0528 9D9A      		sbi 0x13,5
1441:stk500boot.c  **** 
 1766               		.loc 1 1441 0
 1767 052a A59A      		sbi 0x14,5
 1768               	.L98:
 1769               	.LBB186:
 1770               	.LBB187:
 475:stk500boot.c  **** }
 1771               		.loc 1 475 0
 1772 052c 8091 C000 		lds r24,192
 1773               	.LBE187:
 1774               	.LBE186:
1443:stk500boot.c  **** 	{
 1775               		.loc 1 1443 0
 1776 0530 87FD      		sbrc r24,7
 1777 0532 00C0      		rjmp .L125
1445:stk500boot.c  **** 		delay_ms(100);
 1778               		.loc 1 1445 0
 1779 0534 A598      		cbi 0x14,5
1446:stk500boot.c  **** 		PROGLED_PORT	|=	(1<<PROGLED_PIN);	// turn LED on
 1780               		.loc 1 1446 0
 1781 0536 84E6      		ldi r24,lo8(100)
 1782 0538 90E0      		ldi r25,0
 1783 053a 0E94 0000 		call delay_ms
 1784               	.LVL203:
1447:stk500boot.c  **** 		delay_ms(100);
 1785               		.loc 1 1447 0
 1786 053e A59A      		sbi 0x14,5
1448:stk500boot.c  **** 	}
 1787               		.loc 1 1448 0
 1788 0540 84E6      		ldi r24,lo8(100)
 1789 0542 90E0      		ldi r25,0
 1790 0544 0E94 0000 		call delay_ms
 1791               	.LVL204:
 1792 0548 00C0      		rjmp .L98
 1793               	.LVL205:
 1794               	.L283:
 1795               	.LBE185:
 1796               	.LBE184:
 1797               	.LBB189:
 1798               	.LBB168:
1820:stk500boot.c  **** 				break;
 1799               		.loc 1 1820 0
 1800 054a 12B8      		out 0x2,__zero_reg__
 1801               	.LVL206:
 1802               	.L125:
 1803               	.LBE168:
 1804               	.LBE189:
 1805               	.LBB190:
 1806               	.LBB188:
1450:stk500boot.c  **** }
 1807               		.loc 1 1450 0
 1808 054c 0E94 0000 		call recchar
 1809               	.LVL207:
 1810 0550 00C0      		rjmp .L202
 1811               	.LVL208:
 1812               	.L76:
 1813               	.LBE188:
 1814               	.LBE190:
2054:stk500boot.c  **** 				DumpHex(kDUMP_EEPROM, gEepromIndex, 16);
 1815               		.loc 1 2054 0
 1816 0552 62E0      		ldi r22,lo8(2)
 1817 0554 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1818 0556 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1819 0558 0E94 0000 		call PrintFromPROGMEMln
 1820               	.LVL209:
2055:stk500boot.c  **** 				gEepromIndex	+=	256;
 1821               		.loc 1 2055 0
 1822 055c 4091 0000 		lds r20,gEepromIndex
 1823 0560 5091 0000 		lds r21,gEepromIndex+1
 1824 0564 6091 0000 		lds r22,gEepromIndex+2
 1825 0568 7091 0000 		lds r23,gEepromIndex+3
 1826 056c 81E0      		ldi r24,lo8(1)
 1827 056e 0E94 0000 		call DumpHex.constprop.0
 1828               	.LVL210:
2056:stk500boot.c  **** 				if (gEepromIndex > E2END)
 1829               		.loc 1 2056 0
 1830 0572 8091 0000 		lds r24,gEepromIndex
 1831 0576 9091 0000 		lds r25,gEepromIndex+1
 1832 057a A091 0000 		lds r26,gEepromIndex+2
 1833 057e B091 0000 		lds r27,gEepromIndex+3
 1834 0582 9F5F      		subi r25,-1
 1835 0584 AF4F      		sbci r26,-1
 1836 0586 BF4F      		sbci r27,-1
 1837 0588 8093 0000 		sts gEepromIndex,r24
 1838 058c 9093 0000 		sts gEepromIndex+1,r25
 1839 0590 A093 0000 		sts gEepromIndex+2,r26
 1840 0594 B093 0000 		sts gEepromIndex+3,r27
2057:stk500boot.c  **** 				{
 1841               		.loc 1 2057 0
 1842 0598 8115      		cp r24,__zero_reg__
 1843 059a 9041      		sbci r25,16
 1844 059c A105      		cpc r26,__zero_reg__
 1845 059e B105      		cpc r27,__zero_reg__
 1846 05a0 00F4      		brsh .+2
 1847 05a2 00C0      		rjmp .L202
 1848 05a4 00C0      		rjmp .L273
 1849               	.L69:
2064:stk500boot.c  **** 				DumpHex(kDUMP_FLASH, gFlashIndex, 16);
 1850               		.loc 1 2064 0
 1851 05a6 62E0      		ldi r22,lo8(2)
 1852 05a8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1853 05aa 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1854 05ac 0E94 0000 		call PrintFromPROGMEMln
 1855               	.LVL211:
2065:stk500boot.c  **** 				gFlashIndex	+=	256;
 1856               		.loc 1 2065 0
 1857 05b0 4091 0000 		lds r20,gFlashIndex
 1858 05b4 5091 0000 		lds r21,gFlashIndex+1
 1859 05b8 6091 0000 		lds r22,gFlashIndex+2
 1860 05bc 7091 0000 		lds r23,gFlashIndex+3
 1861 05c0 80E0      		ldi r24,0
 1862 05c2 0E94 0000 		call DumpHex.constprop.0
 1863               	.LVL212:
2066:stk500boot.c  **** 				break;
 1864               		.loc 1 2066 0
 1865 05c6 8091 0000 		lds r24,gFlashIndex
 1866 05ca 9091 0000 		lds r25,gFlashIndex+1
 1867 05ce A091 0000 		lds r26,gFlashIndex+2
 1868 05d2 B091 0000 		lds r27,gFlashIndex+3
 1869 05d6 9F5F      		subi r25,-1
 1870 05d8 AF4F      		sbci r26,-1
 1871 05da BF4F      		sbci r27,-1
 1872 05dc 8093 0000 		sts gFlashIndex,r24
 1873 05e0 9093 0000 		sts gFlashIndex+1,r25
 1874 05e4 A093 0000 		sts gFlashIndex+2,r26
 1875 05e8 B093 0000 		sts gFlashIndex+3,r27
 1876 05ec 00C0      		rjmp .L202
 1877               	.L79:
2070:stk500boot.c  **** 				PrintHelp();
 1878               		.loc 1 2070 0
 1879 05ee 62E0      		ldi r22,lo8(2)
 1880 05f0 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1881 05f2 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1882 05f4 0E94 0000 		call PrintFromPROGMEMln
 1883               	.LVL213:
 1884               	.LBB191:
 1885               	.LBB192:
1976:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_QM, 0);
 1886               		.loc 1 1976 0
 1887 05f8 60E0      		ldi r22,0
 1888 05fa 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_0)
 1889 05fc 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_0)
 1890 05fe 0E94 0000 		call PrintFromPROGMEMln
 1891               	.LVL214:
1977:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_AT, 0);
 1892               		.loc 1 1977 0
 1893 0602 60E0      		ldi r22,0
 1894 0604 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_QM)
 1895 0606 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_QM)
 1896 0608 0E94 0000 		call PrintFromPROGMEMln
 1897               	.LVL215:
1978:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_B, 0);
 1898               		.loc 1 1978 0
 1899 060c 60E0      		ldi r22,0
 1900 060e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_AT)
 1901 0610 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_AT)
 1902 0612 0E94 0000 		call PrintFromPROGMEMln
 1903               	.LVL216:
1979:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_E, 0);
 1904               		.loc 1 1979 0
 1905 0616 60E0      		ldi r22,0
 1906 0618 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_B)
 1907 061a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_B)
 1908 061c 0E94 0000 		call PrintFromPROGMEMln
 1909               	.LVL217:
1980:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_F, 0);
 1910               		.loc 1 1980 0
 1911 0620 60E0      		ldi r22,0
 1912 0622 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_E)
 1913 0624 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_E)
 1914 0626 0E94 0000 		call PrintFromPROGMEMln
 1915               	.LVL218:
1981:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_H, 0);
 1916               		.loc 1 1981 0
 1917 062a 60E0      		ldi r22,0
 1918 062c 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_F)
 1919 062e 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_F)
 1920 0630 0E94 0000 		call PrintFromPROGMEMln
 1921               	.LVL219:
1982:stk500boot.c  **** 
 1922               		.loc 1 1982 0
 1923 0634 60E0      		ldi r22,0
 1924 0636 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_H)
 1925 0638 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_H)
 1926 063a 0E94 0000 		call PrintFromPROGMEMln
 1927               	.LVL220:
1984:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Q, 0);
 1928               		.loc 1 1984 0
 1929 063e 60E0      		ldi r22,0
 1930 0640 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_L)
 1931 0642 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_L)
 1932 0644 0E94 0000 		call PrintFromPROGMEMln
 1933               	.LVL221:
1985:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_R, 0);
 1934               		.loc 1 1985 0
 1935 0648 60E0      		ldi r22,0
 1936 064a 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1937 064c 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1938 064e 0E94 0000 		call PrintFromPROGMEMln
 1939               	.LVL222:
1986:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 0);
 1940               		.loc 1 1986 0
 1941 0652 60E0      		ldi r22,0
 1942 0654 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_R)
 1943 0656 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_R)
 1944 0658 0E94 0000 		call PrintFromPROGMEMln
 1945               	.LVL223:
1987:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 0);
 1946               		.loc 1 1987 0
 1947 065c 60E0      		ldi r22,0
 1948 065e 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1949 0660 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1950 0662 0E94 0000 		call PrintFromPROGMEMln
 1951               	.LVL224:
1988:stk500boot.c  **** }
 1952               		.loc 1 1988 0
 1953 0666 60E0      		ldi r22,0
 1954 0668 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 1955 066a 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 1956 066c 00C0      		rjmp .L272
 1957               	.L77:
 1958               	.LBE192:
 1959               	.LBE191:
2080:stk500boot.c  **** 				keepGoing	=	false;
 1960               		.loc 1 2080 0
 1961 066e 62E0      		ldi r22,lo8(2)
 1962 0670 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Q)
 1963 0672 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Q)
 1964 0674 0E94 0000 		call PrintFromPROGMEMln
 1965               	.LVL225:
 1966               	.LBE143:
 1967               	.LBE142:
 681:stk500boot.c  **** 						isLeave			=	1;
 1968               		.loc 1 681 0
 1969 0678 A12C      		mov r10,__zero_reg__
 1970 067a B12C      		mov r11,__zero_reg__
 682:stk500boot.c  **** 						msgParseState	=	99;	//*	we dont want it do anything
 1971               		.loc 1 682 0
 1972 067c 9924      		clr r9
 1973 067e 9394      		inc r9
 1974 0680 00C0      		rjmp .L101
 1975               	.LVL226:
 1976               	.L81:
 1977               	.LBB201:
 1978               	.LBB200:
2088:stk500boot.c  **** 				break;
2089:stk500boot.c  **** 
2090:stk500boot.c  **** 			case 'V':
2091:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_V, 2);
 1979               		.loc 1 2091 0
 1980 0682 62E0      		ldi r22,lo8(2)
 1981 0684 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_V)
 1982 0686 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_V)
 1983 0688 0E94 0000 		call PrintFromPROGMEMln
 1984               	.LVL227:
 1985               	.LBB193:
 1986               	.LBB194:
1631:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_VECTOR_HEADER, 0);
 1987               		.loc 1 1631 0
 1988 068c 60E0      		ldi r22,0
 1989 068e 80E0      		ldi r24,lo8(gTextMsg_CPU_Name)
 1990 0690 90E0      		ldi r25,hi8(gTextMsg_CPU_Name)
 1991 0692 0E94 0000 		call PrintFromPROGMEMln
 1992               	.LVL228:
1632:stk500boot.c  **** 	//					 V#   ADDR   op code
 1993               		.loc 1 1632 0
 1994 0696 60E0      		ldi r22,0
 1995 0698 80E0      		ldi r24,lo8(gTextMsg_VECTOR_HEADER)
 1996 069a 90E0      		ldi r25,hi8(gTextMsg_VECTOR_HEADER)
 1997 069c 0E94 0000 		call PrintFromPROGMEMln
 1998               	.LVL229:
1630:stk500boot.c  **** 	PrintFromPROGMEMln(gTextMsg_CPU_Name, 0);
 1999               		.loc 1 1630 0
 2000 06a0 CE5D      		subi r28,lo8(-290)
 2001 06a2 DE4F      		sbci r29,hi8(-290)
 2002 06a4 1982      		std Y+1,__zero_reg__
 2003 06a6 1882      		st Y,__zero_reg__
 2004 06a8 C252      		subi r28,lo8(290)
 2005 06aa D140      		sbci r29,hi8(290)
1629:stk500boot.c  **** 	vectorIndex		=	0;
 2006               		.loc 1 1629 0
 2007 06ac 412C      		mov r4,__zero_reg__
 2008 06ae 512C      		mov r5,__zero_reg__
 2009 06b0 3201      		movw r6,r4
 2010               	.LVL230:
 2011               	.L105:
1637:stk500boot.c  **** 		//					 01 - 0000 = 12 34
 2012               		.loc 1 1637 0
 2013 06b2 A301      		movw r20,r6
 2014 06b4 9201      		movw r18,r4
 2015 06b6 5695      		lsr r21
 2016 06b8 4795      		ror r20
 2017 06ba 3795      		ror r19
 2018 06bc 2795      		ror r18
 2019 06be C25E      		subi r28,lo8(-286)
 2020 06c0 DE4F      		sbci r29,hi8(-286)
 2021 06c2 2883      		st Y,r18
 2022 06c4 3983      		std Y+1,r19
 2023 06c6 4A83      		std Y+2,r20
 2024 06c8 5B83      		std Y+3,r21
 2025 06ca CE51      		subi r28,lo8(286)
 2026 06cc D140      		sbci r29,hi8(286)
 2027               	.LVL231:
1639:stk500boot.c  **** 		sendchar(0x20);
 2028               		.loc 1 1639 0
 2029 06ce CE5D      		subi r28,lo8(-290)
 2030 06d0 DE4F      		sbci r29,hi8(-290)
 2031 06d2 4881      		ld r20,Y
 2032 06d4 5981      		ldd r21,Y+1
 2033 06d6 C252      		subi r28,lo8(290)
 2034 06d8 D140      		sbci r29,hi8(290)
 2035 06da 4F5F      		subi r20,-1
 2036 06dc 5F4F      		sbci r21,-1
 2037 06de CE5D      		subi r28,lo8(-290)
 2038 06e0 DE4F      		sbci r29,hi8(-290)
 2039 06e2 5983      		std Y+1,r21
 2040 06e4 4883      		st Y,r20
 2041 06e6 C252      		subi r28,lo8(290)
 2042 06e8 D140      		sbci r29,hi8(290)
 2043               	.LVL232:
 2044 06ea 62E0      		ldi r22,lo8(2)
 2045 06ec 70E0      		ldi r23,0
 2046 06ee CA01      		movw r24,r20
 2047 06f0 0E94 0000 		call PrintDecInt
 2048               	.LVL233:
1640:stk500boot.c  **** 		sendchar('-');
 2049               		.loc 1 1640 0
 2050 06f4 80E2      		ldi r24,lo8(32)
 2051 06f6 0E94 0000 		call sendchar
 2052               	.LVL234:
1641:stk500boot.c  **** 		sendchar(0x20);
 2053               		.loc 1 1641 0
 2054 06fa 8DE2      		ldi r24,lo8(45)
 2055 06fc 0E94 0000 		call sendchar
 2056               	.LVL235:
1642:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress >> 8) & 0x00ff);
 2057               		.loc 1 1642 0
 2058 0700 80E2      		ldi r24,lo8(32)
 2059 0702 0E94 0000 		call sendchar
 2060               	.LVL236:
1643:stk500boot.c  **** 		PrintHexByte((wordMemoryAddress) & 0x00ff);
 2061               		.loc 1 1643 0
 2062 0706 80E0      		ldi r24,0
 2063 0708 0E94 0000 		call PrintHexByte
 2064               	.LVL237:
1644:stk500boot.c  **** 		sendchar(0x20);
 2065               		.loc 1 1644 0
 2066 070c C25E      		subi r28,lo8(-286)
 2067 070e DE4F      		sbci r29,hi8(-286)
 2068 0710 8881      		ld r24,Y
 2069 0712 CE51      		subi r28,lo8(286)
 2070 0714 D140      		sbci r29,hi8(286)
 2071 0716 0E94 0000 		call PrintHexByte
 2072               	.LVL238:
1645:stk500boot.c  **** 		sendchar('=');
 2073               		.loc 1 1645 0
 2074 071a 80E2      		ldi r24,lo8(32)
 2075 071c 0E94 0000 		call sendchar
 2076               	.LVL239:
1646:stk500boot.c  **** 		sendchar(0x20);
 2077               		.loc 1 1646 0
 2078 0720 8DE3      		ldi r24,lo8(61)
 2079 0722 0E94 0000 		call sendchar
 2080               	.LVL240:
1647:stk500boot.c  **** 
 2081               		.loc 1 1647 0
 2082 0726 80E2      		ldi r24,lo8(32)
 2083 0728 0E94 0000 		call sendchar
 2084               	.LVL241:
 2085               	.LBB195:
1652:stk500boot.c  **** 		byte2	=	pgm_read_byte_far(myMemoryPtr++);
 2086               		.loc 1 1652 0
 2087               	/* #APP */
 2088               	 ;  1652 "stk500boot.c" 1
 2089 072c 6BBE      		out 59, r6
 2090 072e F201      		movw r30, r4
 2091 0730 A790      		elpm r10, Z+
 2092               		
 2093               	 ;  0 "" 2
 2094               	.LVL242:
 2095               	/* #NOAPP */
 2096 0732 D301      		movw r26,r6
 2097 0734 C201      		movw r24,r4
 2098 0736 0196      		adiw r24,1
 2099 0738 A11D      		adc r26,__zero_reg__
 2100 073a B11D      		adc r27,__zero_reg__
 2101               	.LVL243:
 2102               	.LBE195:
 2103               	.LBB196:
1653:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2104               		.loc 1 1653 0
 2105               	/* #APP */
 2106               	 ;  1653 "stk500boot.c" 1
 2107 073c ABBF      		out 59, r26
 2108 073e FC01      		movw r30, r24
 2109 0740 9790      		elpm r9, Z+
 2110               		
 2111               	 ;  0 "" 2
 2112               	.LVL244:
 2113               	/* #NOAPP */
 2114 0742 D301      		movw r26,r6
 2115 0744 C201      		movw r24,r4
 2116               	.LVL245:
 2117 0746 0296      		adiw r24,2
 2118 0748 A11D      		adc r26,__zero_reg__
 2119 074a B11D      		adc r27,__zero_reg__
 2120               	.LVL246:
 2121               	.LBE196:
 2122               	.LBB197:
1654:stk500boot.c  **** 		byte4	=	pgm_read_byte_far(myMemoryPtr++);
 2123               		.loc 1 1654 0
 2124               	/* #APP */
 2125               	 ;  1654 "stk500boot.c" 1
 2126 074c ABBF      		out 59, r26
 2127 074e FC01      		movw r30, r24
 2128 0750 B790      		elpm r11, Z+
 2129               		
 2130               	 ;  0 "" 2
 2131               	.LVL247:
 2132               	/* #NOAPP */
 2133               	.LBE197:
 2134               	.LBB198:
1655:stk500boot.c  **** 	#else
 2135               		.loc 1 1655 0
 2136 0752 D301      		movw r26,r6
 2137 0754 C201      		movw r24,r4
 2138               	.LVL248:
 2139 0756 0396      		adiw r24,3
 2140 0758 A11D      		adc r26,__zero_reg__
 2141 075a B11D      		adc r27,__zero_reg__
 2142               	/* #APP */
 2143               	 ;  1655 "stk500boot.c" 1
 2144 075c ABBF      		out 59, r26
 2145 075e FC01      		movw r30, r24
 2146 0760 0791      		elpm r16, Z+
 2147               		
 2148               	 ;  0 "" 2
 2149               	/* #NOAPP */
 2150 0762 54E0      		ldi r21,4
 2151 0764 450E      		add r4,r21
 2152 0766 511C      		adc r5,__zero_reg__
 2153 0768 611C      		adc r6,__zero_reg__
 2154 076a 711C      		adc r7,__zero_reg__
 2155               	.LVL249:
 2156               	.LBE198:
1653:stk500boot.c  **** 		byte3	=	pgm_read_byte_far(myMemoryPtr++);
 2157               		.loc 1 1653 0
 2158 076c 492D      		mov r20,r9
 2159 076e 50E0      		ldi r21,0
 2160 0770 60E0      		ldi r22,0
 2161 0772 70E0      		ldi r23,0
1662:stk500boot.c  **** 		word2	=	(byte4 << 8) + byte3;
 2162               		.loc 1 1662 0
 2163 0774 762F      		mov r23,r22
 2164 0776 652F      		mov r22,r21
 2165 0778 542F      		mov r21,r20
 2166 077a 4427      		clr r20
 2167 077c 4A0D      		add r20,r10
 2168 077e 511D      		adc r21,__zero_reg__
 2169 0780 611D      		adc r22,__zero_reg__
 2170 0782 711D      		adc r23,__zero_reg__
 2171               	.LVL250:
1666:stk500boot.c  **** 		sendchar(0x20);
 2172               		.loc 1 1666 0
 2173 0784 892D      		mov r24,r9
 2174 0786 C35D      		subi r28,lo8(-301)
 2175 0788 DE4F      		sbci r29,hi8(-301)
 2176 078a 4883      		st Y,r20
 2177 078c CD52      		subi r28,lo8(301)
 2178 078e D140      		sbci r29,hi8(301)
 2179 0790 C25D      		subi r28,lo8(-302)
 2180 0792 DE4F      		sbci r29,hi8(-302)
 2181 0794 5883      		st Y,r21
 2182 0796 CE52      		subi r28,lo8(302)
 2183 0798 D140      		sbci r29,hi8(302)
 2184 079a C15D      		subi r28,lo8(-303)
 2185 079c DE4F      		sbci r29,hi8(-303)
 2186 079e 6883      		st Y,r22
 2187 07a0 CF52      		subi r28,lo8(303)
 2188 07a2 D140      		sbci r29,hi8(303)
 2189 07a4 C05D      		subi r28,lo8(-304)
 2190 07a6 DE4F      		sbci r29,hi8(-304)
 2191 07a8 7883      		st Y,r23
 2192 07aa C053      		subi r28,lo8(304)
 2193 07ac D140      		sbci r29,hi8(304)
 2194 07ae 0E94 0000 		call PrintHexByte
 2195               	.LVL251:
1667:stk500boot.c  **** 		PrintHexByte(byte1);
 2196               		.loc 1 1667 0
 2197 07b2 80E2      		ldi r24,lo8(32)
 2198 07b4 0E94 0000 		call sendchar
 2199               	.LVL252:
1668:stk500boot.c  **** 		sendchar(0x20);
 2200               		.loc 1 1668 0
 2201 07b8 8A2D      		mov r24,r10
 2202 07ba 0E94 0000 		call PrintHexByte
 2203               	.LVL253:
1669:stk500boot.c  **** 		PrintHexByte(byte4);
 2204               		.loc 1 1669 0
 2205 07be 80E2      		ldi r24,lo8(32)
 2206 07c0 0E94 0000 		call sendchar
 2207               	.LVL254:
1670:stk500boot.c  **** 		sendchar(0x20);
 2208               		.loc 1 1670 0
 2209 07c4 802F      		mov r24,r16
 2210 07c6 0E94 0000 		call PrintHexByte
 2211               	.LVL255:
1671:stk500boot.c  **** 		PrintHexByte(byte3);
 2212               		.loc 1 1671 0
 2213 07ca 80E2      		ldi r24,lo8(32)
 2214 07cc 0E94 0000 		call sendchar
 2215               	.LVL256:
1672:stk500boot.c  **** 		sendchar(0x20);
 2216               		.loc 1 1672 0
 2217 07d0 8B2D      		mov r24,r11
 2218 07d2 0E94 0000 		call PrintHexByte
 2219               	.LVL257:
1673:stk500boot.c  **** 
 2220               		.loc 1 1673 0
 2221 07d6 80E2      		ldi r24,lo8(32)
 2222 07d8 0E94 0000 		call sendchar
 2223               	.LVL258:
1675:stk500boot.c  **** 		{
 2224               		.loc 1 1675 0
 2225 07dc C35D      		subi r28,lo8(-301)
 2226 07de DE4F      		sbci r29,hi8(-301)
 2227 07e0 4881      		ld r20,Y
 2228 07e2 CD52      		subi r28,lo8(301)
 2229 07e4 D140      		sbci r29,hi8(301)
 2230 07e6 C25D      		subi r28,lo8(-302)
 2231 07e8 DE4F      		sbci r29,hi8(-302)
 2232 07ea 5881      		ld r21,Y
 2233 07ec CE52      		subi r28,lo8(302)
 2234 07ee D140      		sbci r29,hi8(302)
 2235 07f0 C15D      		subi r28,lo8(-303)
 2236 07f2 DE4F      		sbci r29,hi8(-303)
 2237 07f4 6881      		ld r22,Y
 2238 07f6 CF52      		subi r28,lo8(303)
 2239 07f8 D140      		sbci r29,hi8(303)
 2240 07fa C05D      		subi r28,lo8(-304)
 2241 07fc DE4F      		sbci r29,hi8(-304)
 2242 07fe 7881      		ld r23,Y
 2243 0800 C053      		subi r28,lo8(304)
 2244 0802 D140      		sbci r29,hi8(304)
 2245 0804 4F3F      		cpi r20,-1
 2246 0806 8FEF      		ldi r24,-1
 2247 0808 5807      		cpc r21,r24
 2248 080a 6105      		cpc r22,__zero_reg__
 2249 080c 7105      		cpc r23,__zero_reg__
 2250 080e 01F4      		brne .L102
1677:stk500boot.c  **** 		}
 2251               		.loc 1 1677 0
 2252 0810 60E0      		ldi r22,0
 2253 0812 80E0      		ldi r24,lo8(gTextMsg_noVector)
 2254 0814 90E0      		ldi r25,hi8(gTextMsg_noVector)
 2255 0816 0E94 0000 		call PrintFromPROGMEM
 2256               	.LVL259:
 2257 081a 00C0      		rjmp .L103
 2258               	.L102:
1679:stk500boot.c  **** 		{
 2259               		.loc 1 1679 0
 2260 081c DB01      		movw r26,r22
 2261 081e CA01      		movw r24,r20
 2262 0820 8827      		clr r24
 2263 0822 907C      		andi r25,192
 2264 0824 AA27      		clr r26
 2265 0826 BB27      		clr r27
 2266 0828 8115      		cp r24,__zero_reg__
 2267 082a 904C      		sbci r25,-64
 2268 082c A105      		cpc r26,__zero_reg__
 2269 082e B105      		cpc r27,__zero_reg__
 2270 0830 01F4      		brne .L104
1682:stk500boot.c  **** 			absoluteAddr	=	wordMemoryAddress + realitiveAddr;	//*	add the offset to the current address
 2271               		.loc 1 1682 0
 2272 0832 4A01      		movw r8,r20
 2273 0834 5B01      		movw r10,r22
 2274 0836 FFE3      		ldi r31,63
 2275 0838 9F22      		and r9,r31
 2276 083a AA24      		clr r10
 2277 083c BB24      		clr r11
 2278               	.LVL260:
1683:stk500boot.c  **** 			absoluteAddr	=	absoluteAddr << 1;					//*	multiply by 2 for byte address
 2279               		.loc 1 1683 0
 2280 083e C25E      		subi r28,lo8(-286)
 2281 0840 DE4F      		sbci r29,hi8(-286)
 2282 0842 8881      		ld r24,Y
 2283 0844 9981      		ldd r25,Y+1
 2284 0846 AA81      		ldd r26,Y+2
 2285 0848 BB81      		ldd r27,Y+3
 2286 084a CE51      		subi r28,lo8(286)
 2287 084c D140      		sbci r29,hi8(286)
 2288 084e 880D      		add r24,r8
 2289 0850 991D      		adc r25,r9
 2290 0852 AA1D      		adc r26,r10
 2291 0854 BB1D      		adc r27,r11
 2292               	.LVL261:
1684:stk500boot.c  **** 
 2293               		.loc 1 1684 0
 2294 0856 9C01      		movw r18,r24
 2295 0858 AD01      		movw r20,r26
 2296 085a 220F      		lsl r18
 2297 085c 331F      		rol r19
 2298 085e 441F      		rol r20
 2299 0860 551F      		rol r21
 2300 0862 C25E      		subi r28,lo8(-286)
 2301 0864 DE4F      		sbci r29,hi8(-286)
 2302 0866 2883      		st Y,r18
 2303 0868 3983      		std Y+1,r19
 2304 086a 4A83      		std Y+2,r20
 2305 086c 5B83      		std Y+3,r21
 2306 086e CE51      		subi r28,lo8(286)
 2307 0870 D140      		sbci r29,hi8(286)
 2308               	.LVL262:
1686:stk500boot.c  **** 			PrintHexByte((realitiveAddr >> 8) & 0x00ff);
 2309               		.loc 1 1686 0
 2310 0872 60E0      		ldi r22,0
 2311 0874 80E0      		ldi r24,lo8(gTextMsg_rjmp)
 2312 0876 90E0      		ldi r25,hi8(gTextMsg_rjmp)
 2313 0878 0E94 0000 		call PrintFromPROGMEM
 2314               	.LVL263:
1687:stk500boot.c  **** 			PrintHexByte((realitiveAddr) & 0x00ff);
 2315               		.loc 1 1687 0
 2316 087c 892D      		mov r24,r9
 2317 087e 0E94 0000 		call PrintHexByte
 2318               	.LVL264:
1688:stk500boot.c  **** 			sendchar(0x20);
 2319               		.loc 1 1688 0
 2320 0882 882D      		mov r24,r8
 2321 0884 0E94 0000 		call PrintHexByte
 2322               	.LVL265:
1689:stk500boot.c  **** 			sendchar('>');
 2323               		.loc 1 1689 0
 2324 0888 80E2      		ldi r24,lo8(32)
 2325 088a 0E94 0000 		call sendchar
 2326               	.LVL266:
1690:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2327               		.loc 1 1690 0
 2328 088e 8EE3      		ldi r24,lo8(62)
 2329 0890 0E94 0000 		call sendchar
 2330               	.LVL267:
1691:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2331               		.loc 1 1691 0
 2332 0894 80E0      		ldi r24,0
 2333 0896 00C0      		rjmp .L274
 2334               	.LVL268:
 2335               	.L104:
1696:stk500boot.c  **** 		{
 2336               		.loc 1 1696 0
 2337 0898 4E70      		andi r20,14
 2338 089a 5E7F      		andi r21,254
 2339 089c 6627      		clr r22
 2340 089e 7727      		clr r23
 2341 08a0 4C30      		cpi r20,12
 2342 08a2 5449      		sbci r21,-108
 2343 08a4 6105      		cpc r22,__zero_reg__
 2344 08a6 7105      		cpc r23,__zero_reg__
 2345 08a8 01F0      		breq .+2
 2346 08aa 00C0      		rjmp .L103
1655:stk500boot.c  **** 	#else
 2347               		.loc 1 1655 0
 2348 08ac 802F      		mov r24,r16
 2349 08ae 90E0      		ldi r25,0
 2350 08b0 A0E0      		ldi r26,0
 2351 08b2 B0E0      		ldi r27,0
1663:stk500boot.c  **** 
 2352               		.loc 1 1663 0
 2353 08b4 BA2F      		mov r27,r26
 2354 08b6 A92F      		mov r26,r25
 2355 08b8 982F      		mov r25,r24
 2356 08ba 8827      		clr r24
 2357 08bc 8B0D      		add r24,r11
 2358 08be 911D      		adc r25,__zero_reg__
 2359 08c0 A11D      		adc r26,__zero_reg__
 2360 08c2 B11D      		adc r27,__zero_reg__
1699:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2361               		.loc 1 1699 0
 2362 08c4 4A2D      		mov r20,r10
 2363 08c6 4170      		andi r20,lo8(1)
 2364 08c8 50E0      		ldi r21,0
 2365 08ca 60E0      		ldi r22,0
 2366 08cc 70E0      		ldi r23,0
 2367 08ce BA01      		movw r22,r20
 2368 08d0 5527      		clr r21
 2369 08d2 4427      		clr r20
 2370 08d4 480F      		add r20,r24
 2371 08d6 591F      		adc r21,r25
 2372 08d8 6A1F      		adc r22,r26
 2373 08da 7B1F      		adc r23,r27
1700:stk500boot.c  **** 								((byte2 & 0x01) << 21) +
 2374               		.loc 1 1700 0
 2375 08dc 8A2D      		mov r24,r10
 2376 08de 807F      		andi r24,lo8(-16)
 2377 08e0 90E0      		ldi r25,0
 2378 08e2 A0E0      		ldi r26,0
 2379 08e4 B0E0      		ldi r27,0
 2380 08e6 F1E1      		ldi r31,17
 2381               		1:
 2382 08e8 880F      		lsl r24
 2383 08ea 991F      		rol r25
 2384 08ec AA1F      		rol r26
 2385 08ee BB1F      		rol r27
 2386 08f0 FA95      		dec r31
 2387 08f2 01F4      		brne 1b
 2388 08f4 840F      		add r24,r20
 2389 08f6 951F      		adc r25,r21
 2390 08f8 A61F      		adc r26,r22
 2391 08fa B71F      		adc r27,r23
1701:stk500boot.c  **** 								word2;
 2392               		.loc 1 1701 0
 2393 08fc 292D      		mov r18,r9
 2394 08fe 2170      		andi r18,lo8(1)
 2395 0900 822E      		mov r8,r18
 2396 0902 912C      		mov r9,__zero_reg__
 2397               	.LVL269:
 2398 0904 A12C      		mov r10,__zero_reg__
 2399 0906 B12C      		mov r11,__zero_reg__
 2400               	.LVL270:
 2401 0908 05E1      		ldi r16,21
 2402               		1:
 2403 090a 880C      		lsl r8
 2404 090c 991C      		rol r9
 2405 090e AA1C      		rol r10
 2406 0910 BB1C      		rol r11
 2407 0912 0A95      		dec r16
 2408 0914 01F4      		brne 1b
 2409               	.LVL271:
1699:stk500boot.c  **** 								((byte1 & 0xf0) << 17) +
 2410               		.loc 1 1699 0
 2411 0916 880E      		add r8,r24
 2412 0918 991E      		adc r9,r25
 2413 091a AA1E      		adc r10,r26
 2414 091c BB1E      		adc r11,r27
 2415               	.LVL272:
1704:stk500boot.c  **** 
 2416               		.loc 1 1704 0
 2417 091e A501      		movw r20,r10
 2418 0920 9401      		movw r18,r8
 2419 0922 220F      		lsl r18
 2420 0924 331F      		rol r19
 2421 0926 441F      		rol r20
 2422 0928 551F      		rol r21
 2423 092a C25E      		subi r28,lo8(-286)
 2424 092c DE4F      		sbci r29,hi8(-286)
 2425 092e 2883      		st Y,r18
 2426 0930 3983      		std Y+1,r19
 2427 0932 4A83      		std Y+2,r20
 2428 0934 5B83      		std Y+3,r21
 2429 0936 CE51      		subi r28,lo8(286)
 2430 0938 D140      		sbci r29,hi8(286)
 2431               	.LVL273:
1706:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 16) & 0x00ff);
 2432               		.loc 1 1706 0
 2433 093a 60E0      		ldi r22,0
 2434 093c 80E0      		ldi r24,lo8(gTextMsg_jmp)
 2435 093e 90E0      		ldi r25,hi8(gTextMsg_jmp)
 2436 0940 0E94 0000 		call PrintFromPROGMEM
 2437               	.LVL274:
1707:stk500boot.c  **** 			PrintHexByte((myFullAddress >> 8) & 0x00ff);
 2438               		.loc 1 1707 0
 2439 0944 8A2D      		mov r24,r10
 2440 0946 0E94 0000 		call PrintHexByte
 2441               	.LVL275:
1708:stk500boot.c  **** 			PrintHexByte((myFullAddress) & 0x00ff);
 2442               		.loc 1 1708 0
 2443 094a 892D      		mov r24,r9
 2444 094c 0E94 0000 		call PrintHexByte
 2445               	.LVL276:
1709:stk500boot.c  **** 			sendchar(0x20);
 2446               		.loc 1 1709 0
 2447 0950 882D      		mov r24,r8
 2448 0952 0E94 0000 		call PrintHexByte
 2449               	.LVL277:
1710:stk500boot.c  **** 			sendchar('>');
 2450               		.loc 1 1710 0
 2451 0956 80E2      		ldi r24,lo8(32)
 2452 0958 0E94 0000 		call sendchar
 2453               	.LVL278:
1711:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 16) & 0x00ff);
 2454               		.loc 1 1711 0
 2455 095c 8EE3      		ldi r24,lo8(62)
 2456 095e 0E94 0000 		call sendchar
 2457               	.LVL279:
1712:stk500boot.c  **** 			PrintHexByte((absoluteAddr >> 8) & 0x00ff);
 2458               		.loc 1 1712 0
 2459 0962 C05E      		subi r28,lo8(-288)
 2460 0964 DE4F      		sbci r29,hi8(-288)
 2461 0966 8881      		ld r24,Y
 2462 0968 C052      		subi r28,lo8(288)
 2463 096a D140      		sbci r29,hi8(288)
 2464               	.LVL280:
 2465               	.L274:
 2466 096c 0E94 0000 		call PrintHexByte
 2467               	.LVL281:
1713:stk500boot.c  **** 			PrintHexByte((absoluteAddr) & 0x00ff);
 2468               		.loc 1 1713 0
 2469 0970 C15E      		subi r28,lo8(-287)
 2470 0972 DE4F      		sbci r29,hi8(-287)
 2471 0974 8881      		ld r24,Y
 2472 0976 CF51      		subi r28,lo8(287)
 2473 0978 D140      		sbci r29,hi8(287)
 2474 097a 0E94 0000 		call PrintHexByte
 2475               	.LVL282:
1714:stk500boot.c  **** 		}
 2476               		.loc 1 1714 0
 2477 097e C25E      		subi r28,lo8(-286)
 2478 0980 DE4F      		sbci r29,hi8(-286)
 2479 0982 8881      		ld r24,Y
 2480 0984 CE51      		subi r28,lo8(286)
 2481 0986 D140      		sbci r29,hi8(286)
 2482 0988 0E94 0000 		call PrintHexByte
 2483               	.LVL283:
 2484               	.L103:
1726:stk500boot.c  **** 
 2485               		.loc 1 1726 0
 2486 098c 0E94 0000 		call PrintNewLine
 2487               	.LVL284:
1635:stk500boot.c  **** 	{
 2488               		.loc 1 1635 0
 2489 0990 CE5D      		subi r28,lo8(-290)
 2490 0992 DE4F      		sbci r29,hi8(-290)
 2491 0994 4881      		ld r20,Y
 2492 0996 5981      		ldd r21,Y+1
 2493 0998 C252      		subi r28,lo8(290)
 2494 099a D140      		sbci r29,hi8(290)
 2495 099c 4933      		cpi r20,57
 2496 099e 5105      		cpc r21,__zero_reg__
 2497 09a0 01F0      		breq .+2
 2498 09a2 00C0      		rjmp .L105
 2499 09a4 00C0      		rjmp .L202
 2500               	.LVL285:
 2501               	.L82:
 2502               	.LBE194:
 2503               	.LBE193:
2092:stk500boot.c  **** 				VectorDisplay();
2093:stk500boot.c  **** 				break;
2094:stk500boot.c  **** 
2095:stk500boot.c  **** 			case 'Y':
2096:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HELP_MSG_Y, 2);
 2504               		.loc 1 2096 0
 2505 09a6 62E0      		ldi r22,lo8(2)
 2506 09a8 80E0      		ldi r24,lo8(gTextMsg_HELP_MSG_Y)
 2507 09aa 90E0      		ldi r25,hi8(gTextMsg_HELP_MSG_Y)
 2508 09ac 0E94 0000 		call PrintFromPROGMEMln
 2509               	.LVL286:
 2510               	.LBB199:
 2511               	.LBB169:
1800:stk500boot.c  **** 
 2512               		.loc 1 1800 0
 2513 09b0 60E0      		ldi r22,0
 2514 09b2 80E0      		ldi r24,lo8(gTextMsg_WHAT_PORT)
 2515 09b4 90E0      		ldi r25,hi8(gTextMsg_WHAT_PORT)
 2516 09b6 0E94 0000 		call PrintFromPROGMEM
 2517               	.LVL287:
1802:stk500boot.c  **** 	portLetter	=	portLetter & 0x5f;
 2518               		.loc 1 1802 0
 2519 09ba 0E94 0000 		call recchar
 2520               	.LVL288:
1803:stk500boot.c  **** 	sendchar(portLetter);
 2521               		.loc 1 1803 0
 2522 09be 082F      		mov r16,r24
 2523               	.LVL289:
 2524 09c0 0F75      		andi r16,lo8(95)
 2525               	.LVL290:
1804:stk500boot.c  **** 	PrintNewLine();
 2526               		.loc 1 1804 0
 2527 09c2 802F      		mov r24,r16
 2528 09c4 0E94 0000 		call sendchar
 2529               	.LVL291:
1805:stk500boot.c  **** 
 2530               		.loc 1 1805 0
 2531 09c8 0E94 0000 		call PrintNewLine
 2532               	.LVL292:
1807:stk500boot.c  **** 	{
 2533               		.loc 1 1807 0
 2534 09cc 8FEB      		ldi r24,lo8(-65)
 2535 09ce 800F      		add r24,r16
 2536 09d0 8A31      		cpi r24,lo8(26)
 2537 09d2 00F0      		brlo .+2
 2538 09d4 00C0      		rjmp .L107
 2539               	.LVL293:
1810:stk500boot.c  **** 		{
 2540               		.loc 1 1810 0
 2541 09d6 0634      		cpi r16,lo8(70)
 2542 09d8 01F4      		brne .+2
 2543 09da 00C0      		rjmp .L109
 2544 09dc 00F4      		brsh .L110
 2545 09de 0334      		cpi r16,lo8(67)
 2546 09e0 01F4      		brne .+2
 2547 09e2 00C0      		rjmp .L111
 2548 09e4 00F4      		brsh .L112
 2549 09e6 0134      		cpi r16,lo8(65)
 2550 09e8 01F0      		breq .L113
 2551 09ea 0234      		cpi r16,lo8(66)
 2552 09ec 01F0      		breq .+2
 2553 09ee 00C0      		rjmp .L108
1826:stk500boot.c  **** 				while (!Serial_Available())
 2554               		.loc 1 1826 0
 2555 09f0 14B9      		out 0x4,r17
 2556 09f2 00C0      		rjmp .L126
 2557               	.L112:
1810:stk500boot.c  **** 		{
 2558               		.loc 1 1810 0
 2559 09f4 0434      		cpi r16,lo8(68)
 2560 09f6 01F4      		brne .+2
 2561 09f8 00C0      		rjmp .L115
 2562 09fa 0534      		cpi r16,lo8(69)
 2563 09fc 01F0      		breq .+2
 2564 09fe 00C0      		rjmp .L108
1862:stk500boot.c  **** 				while (!Serial_Available())
 2565               		.loc 1 1862 0
 2566 0a00 1DB9      		out 0xd,r17
 2567 0a02 00C0      		rjmp .L132
 2568               	.L110:
1810:stk500boot.c  **** 		{
 2569               		.loc 1 1810 0
 2570 0a04 0A34      		cpi r16,lo8(74)
 2571 0a06 01F4      		brne .+2
 2572 0a08 00C0      		rjmp .L117
 2573 0a0a 00F4      		brsh .L118
 2574 0a0c 0734      		cpi r16,lo8(71)
 2575 0a0e 01F4      		brne .+2
 2576 0a10 00C0      		rjmp .L119
 2577 0a12 0834      		cpi r16,lo8(72)
 2578 0a14 01F0      		breq .+2
 2579 0a16 00C0      		rjmp .L108
1898:stk500boot.c  **** 				while (!Serial_Available())
 2580               		.loc 1 1898 0
 2581 0a18 1093 0101 		sts 257,r17
 2582 0a1c 00C0      		rjmp .L138
 2583               	.L118:
1810:stk500boot.c  **** 		{
 2584               		.loc 1 1810 0
 2585 0a1e 0B34      		cpi r16,lo8(75)
 2586 0a20 01F4      		brne .+2
 2587 0a22 00C0      		rjmp .L121
 2588 0a24 0C34      		cpi r16,lo8(76)
 2589 0a26 01F0      		breq .+2
 2590 0a28 00C0      		rjmp .L108
1946:stk500boot.c  **** 				while (!Serial_Available())
 2591               		.loc 1 1946 0
 2592 0a2a 1093 0A01 		sts 266,r17
 2593 0a2e 00C0      		rjmp .L144
 2594               	.L113:
1814:stk500boot.c  **** 				while (!Serial_Available())
 2595               		.loc 1 1814 0
 2596 0a30 11B9      		out 0x1,r17
 2597               	.L123:
 2598               	.LBB146:
 2599               	.LBB147:
 475:stk500boot.c  **** }
 2600               		.loc 1 475 0
 2601 0a32 8091 C000 		lds r24,192
 2602               	.LBE147:
 2603               	.LBE146:
1815:stk500boot.c  **** 				{
 2604               		.loc 1 1815 0
 2605 0a36 87FD      		sbrc r24,7
 2606 0a38 00C0      		rjmp .L283
1817:stk500boot.c  **** 					delay_ms(200);
 2607               		.loc 1 1817 0
 2608 0a3a 82B1      		in r24,0x2
 2609 0a3c 8095      		com r24
 2610 0a3e 82B9      		out 0x2,r24
1818:stk500boot.c  **** 				}
 2611               		.loc 1 1818 0
 2612 0a40 88EC      		ldi r24,lo8(-56)
 2613 0a42 90E0      		ldi r25,0
 2614 0a44 0E94 0000 		call delay_ms
 2615               	.LVL294:
 2616 0a48 00C0      		rjmp .L123
 2617               	.L126:
 2618               	.LBB148:
 2619               	.LBB149:
 475:stk500boot.c  **** }
 2620               		.loc 1 475 0
 2621 0a4a 8091 C000 		lds r24,192
 2622               	.LBE149:
 2623               	.LBE148:
1827:stk500boot.c  **** 				{
 2624               		.loc 1 1827 0
 2625 0a4e 87FD      		sbrc r24,7
 2626 0a50 00C0      		rjmp .L284
1829:stk500boot.c  **** 					delay_ms(200);
 2627               		.loc 1 1829 0
 2628 0a52 85B1      		in r24,0x5
 2629 0a54 8095      		com r24
 2630 0a56 85B9      		out 0x5,r24
1830:stk500boot.c  **** 				}
 2631               		.loc 1 1830 0
 2632 0a58 88EC      		ldi r24,lo8(-56)
 2633 0a5a 90E0      		ldi r25,0
 2634 0a5c 0E94 0000 		call delay_ms
 2635               	.LVL295:
 2636 0a60 00C0      		rjmp .L126
 2637               	.L284:
1832:stk500boot.c  **** 				break;
 2638               		.loc 1 1832 0
 2639 0a62 15B8      		out 0x5,__zero_reg__
 2640 0a64 00C0      		rjmp .L125
 2641               	.L111:
1838:stk500boot.c  **** 				while (!Serial_Available())
 2642               		.loc 1 1838 0
 2643 0a66 17B9      		out 0x7,r17
 2644               	.L128:
 2645               	.LBB150:
 2646               	.LBB151:
 475:stk500boot.c  **** }
 2647               		.loc 1 475 0
 2648 0a68 8091 C000 		lds r24,192
 2649               	.LBE151:
 2650               	.LBE150:
1839:stk500boot.c  **** 				{
 2651               		.loc 1 1839 0
 2652 0a6c 87FD      		sbrc r24,7
 2653 0a6e 00C0      		rjmp .L285
1841:stk500boot.c  **** 					delay_ms(200);
 2654               		.loc 1 1841 0
 2655 0a70 88B1      		in r24,0x8
 2656 0a72 8095      		com r24
 2657 0a74 88B9      		out 0x8,r24
1842:stk500boot.c  **** 				}
 2658               		.loc 1 1842 0
 2659 0a76 88EC      		ldi r24,lo8(-56)
 2660 0a78 90E0      		ldi r25,0
 2661 0a7a 0E94 0000 		call delay_ms
 2662               	.LVL296:
 2663 0a7e 00C0      		rjmp .L128
 2664               	.L285:
1844:stk500boot.c  **** 				break;
 2665               		.loc 1 1844 0
 2666 0a80 18B8      		out 0x8,__zero_reg__
 2667 0a82 00C0      		rjmp .L125
 2668               	.L115:
1850:stk500boot.c  **** 				while (!Serial_Available())
 2669               		.loc 1 1850 0
 2670 0a84 1AB9      		out 0xa,r17
 2671               	.L130:
 2672               	.LBB152:
 2673               	.LBB153:
 475:stk500boot.c  **** }
 2674               		.loc 1 475 0
 2675 0a86 8091 C000 		lds r24,192
 2676               	.LBE153:
 2677               	.LBE152:
1851:stk500boot.c  **** 				{
 2678               		.loc 1 1851 0
 2679 0a8a 87FD      		sbrc r24,7
 2680 0a8c 00C0      		rjmp .L286
1853:stk500boot.c  **** 					delay_ms(200);
 2681               		.loc 1 1853 0
 2682 0a8e 8BB1      		in r24,0xb
 2683 0a90 8095      		com r24
 2684 0a92 8BB9      		out 0xb,r24
1854:stk500boot.c  **** 				}
 2685               		.loc 1 1854 0
 2686 0a94 88EC      		ldi r24,lo8(-56)
 2687 0a96 90E0      		ldi r25,0
 2688 0a98 0E94 0000 		call delay_ms
 2689               	.LVL297:
 2690 0a9c 00C0      		rjmp .L130
 2691               	.L286:
1856:stk500boot.c  **** 				break;
 2692               		.loc 1 1856 0
 2693 0a9e 1BB8      		out 0xb,__zero_reg__
 2694 0aa0 00C0      		rjmp .L125
 2695               	.L132:
 2696               	.LBB154:
 2697               	.LBB155:
 475:stk500boot.c  **** }
 2698               		.loc 1 475 0
 2699 0aa2 8091 C000 		lds r24,192
 2700               	.LBE155:
 2701               	.LBE154:
1863:stk500boot.c  **** 				{
 2702               		.loc 1 1863 0
 2703 0aa6 87FD      		sbrc r24,7
 2704 0aa8 00C0      		rjmp .L287
1865:stk500boot.c  **** 					delay_ms(200);
 2705               		.loc 1 1865 0
 2706 0aaa 8EB1      		in r24,0xe
 2707 0aac 8095      		com r24
 2708 0aae 8EB9      		out 0xe,r24
1866:stk500boot.c  **** 				}
 2709               		.loc 1 1866 0
 2710 0ab0 88EC      		ldi r24,lo8(-56)
 2711 0ab2 90E0      		ldi r25,0
 2712 0ab4 0E94 0000 		call delay_ms
 2713               	.LVL298:
 2714 0ab8 00C0      		rjmp .L132
 2715               	.L287:
1868:stk500boot.c  **** 				break;
 2716               		.loc 1 1868 0
 2717 0aba 1EB8      		out 0xe,__zero_reg__
 2718 0abc 00C0      		rjmp .L125
 2719               	.L109:
1874:stk500boot.c  **** 				while (!Serial_Available())
 2720               		.loc 1 1874 0
 2721 0abe 10BB      		out 0x10,r17
 2722               	.L134:
 2723               	.LBB156:
 2724               	.LBB157:
 475:stk500boot.c  **** }
 2725               		.loc 1 475 0
 2726 0ac0 8091 C000 		lds r24,192
 2727               	.LBE157:
 2728               	.LBE156:
1875:stk500boot.c  **** 				{
 2729               		.loc 1 1875 0
 2730 0ac4 87FD      		sbrc r24,7
 2731 0ac6 00C0      		rjmp .L288
1877:stk500boot.c  **** 					delay_ms(200);
 2732               		.loc 1 1877 0
 2733 0ac8 81B3      		in r24,0x11
 2734 0aca 8095      		com r24
 2735 0acc 81BB      		out 0x11,r24
1878:stk500boot.c  **** 				}
 2736               		.loc 1 1878 0
 2737 0ace 88EC      		ldi r24,lo8(-56)
 2738 0ad0 90E0      		ldi r25,0
 2739 0ad2 0E94 0000 		call delay_ms
 2740               	.LVL299:
 2741 0ad6 00C0      		rjmp .L134
 2742               	.L288:
1880:stk500boot.c  **** 				break;
 2743               		.loc 1 1880 0
 2744 0ad8 11BA      		out 0x11,__zero_reg__
 2745 0ada 00C0      		rjmp .L125
 2746               	.L119:
1886:stk500boot.c  **** 				while (!Serial_Available())
 2747               		.loc 1 1886 0
 2748 0adc 13BB      		out 0x13,r17
 2749               	.L136:
 2750               	.LBB158:
 2751               	.LBB159:
 475:stk500boot.c  **** }
 2752               		.loc 1 475 0
 2753 0ade 8091 C000 		lds r24,192
 2754               	.LBE159:
 2755               	.LBE158:
1887:stk500boot.c  **** 				{
 2756               		.loc 1 1887 0
 2757 0ae2 87FD      		sbrc r24,7
 2758 0ae4 00C0      		rjmp .L289
1889:stk500boot.c  **** 					delay_ms(200);
 2759               		.loc 1 1889 0
 2760 0ae6 84B3      		in r24,0x14
 2761 0ae8 8095      		com r24
 2762 0aea 84BB      		out 0x14,r24
1890:stk500boot.c  **** 				}
 2763               		.loc 1 1890 0
 2764 0aec 88EC      		ldi r24,lo8(-56)
 2765 0aee 90E0      		ldi r25,0
 2766 0af0 0E94 0000 		call delay_ms
 2767               	.LVL300:
 2768 0af4 00C0      		rjmp .L136
 2769               	.L289:
1892:stk500boot.c  **** 				break;
 2770               		.loc 1 1892 0
 2771 0af6 14BA      		out 0x14,__zero_reg__
 2772 0af8 00C0      		rjmp .L125
 2773               	.L138:
 2774               	.LBB160:
 2775               	.LBB161:
 475:stk500boot.c  **** }
 2776               		.loc 1 475 0
 2777 0afa 8091 C000 		lds r24,192
 2778               	.LBE161:
 2779               	.LBE160:
1899:stk500boot.c  **** 				{
 2780               		.loc 1 1899 0
 2781 0afe 87FD      		sbrc r24,7
 2782 0b00 00C0      		rjmp .L290
1901:stk500boot.c  **** 					delay_ms(200);
 2783               		.loc 1 1901 0
 2784 0b02 8091 0201 		lds r24,258
 2785 0b06 8095      		com r24
 2786 0b08 8093 0201 		sts 258,r24
1902:stk500boot.c  **** 				}
 2787               		.loc 1 1902 0
 2788 0b0c 88EC      		ldi r24,lo8(-56)
 2789 0b0e 90E0      		ldi r25,0
 2790 0b10 0E94 0000 		call delay_ms
 2791               	.LVL301:
 2792 0b14 00C0      		rjmp .L138
 2793               	.L290:
1904:stk500boot.c  **** 				break;
 2794               		.loc 1 1904 0
 2795 0b16 1092 0201 		sts 258,__zero_reg__
 2796 0b1a 00C0      		rjmp .L125
 2797               	.L117:
1922:stk500boot.c  **** 				while (!Serial_Available())
 2798               		.loc 1 1922 0
 2799 0b1c 1093 0401 		sts 260,r17
 2800               	.L140:
 2801               	.LBB162:
 2802               	.LBB163:
 475:stk500boot.c  **** }
 2803               		.loc 1 475 0
 2804 0b20 8091 C000 		lds r24,192
 2805               	.LBE163:
 2806               	.LBE162:
1923:stk500boot.c  **** 				{
 2807               		.loc 1 1923 0
 2808 0b24 87FD      		sbrc r24,7
 2809 0b26 00C0      		rjmp .L291
1925:stk500boot.c  **** 					delay_ms(200);
 2810               		.loc 1 1925 0
 2811 0b28 8091 0501 		lds r24,261
 2812 0b2c 8095      		com r24
 2813 0b2e 8093 0501 		sts 261,r24
1926:stk500boot.c  **** 				}
 2814               		.loc 1 1926 0
 2815 0b32 88EC      		ldi r24,lo8(-56)
 2816 0b34 90E0      		ldi r25,0
 2817 0b36 0E94 0000 		call delay_ms
 2818               	.LVL302:
 2819 0b3a 00C0      		rjmp .L140
 2820               	.L291:
1928:stk500boot.c  **** 				break;
 2821               		.loc 1 1928 0
 2822 0b3c 1092 0501 		sts 261,__zero_reg__
 2823 0b40 00C0      		rjmp .L125
 2824               	.L121:
1934:stk500boot.c  **** 				while (!Serial_Available())
 2825               		.loc 1 1934 0
 2826 0b42 1093 0701 		sts 263,r17
 2827               	.L142:
 2828               	.LBB164:
 2829               	.LBB165:
 475:stk500boot.c  **** }
 2830               		.loc 1 475 0
 2831 0b46 8091 C000 		lds r24,192
 2832               	.LBE165:
 2833               	.LBE164:
1935:stk500boot.c  **** 				{
 2834               		.loc 1 1935 0
 2835 0b4a 87FD      		sbrc r24,7
 2836 0b4c 00C0      		rjmp .L292
1937:stk500boot.c  **** 					delay_ms(200);
 2837               		.loc 1 1937 0
 2838 0b4e 8091 0801 		lds r24,264
 2839 0b52 8095      		com r24
 2840 0b54 8093 0801 		sts 264,r24
1938:stk500boot.c  **** 				}
 2841               		.loc 1 1938 0
 2842 0b58 88EC      		ldi r24,lo8(-56)
 2843 0b5a 90E0      		ldi r25,0
 2844 0b5c 0E94 0000 		call delay_ms
 2845               	.LVL303:
 2846 0b60 00C0      		rjmp .L142
 2847               	.L292:
1940:stk500boot.c  **** 				break;
 2848               		.loc 1 1940 0
 2849 0b62 1092 0801 		sts 264,__zero_reg__
 2850 0b66 00C0      		rjmp .L125
 2851               	.L144:
 2852               	.LBB166:
 2853               	.LBB167:
 475:stk500boot.c  **** }
 2854               		.loc 1 475 0
 2855 0b68 8091 C000 		lds r24,192
 2856               	.LBE167:
 2857               	.LBE166:
1947:stk500boot.c  **** 				{
 2858               		.loc 1 1947 0
 2859 0b6c 87FD      		sbrc r24,7
 2860 0b6e 00C0      		rjmp .L293
1949:stk500boot.c  **** 					delay_ms(200);
 2861               		.loc 1 1949 0
 2862 0b70 8091 0B01 		lds r24,267
 2863 0b74 8095      		com r24
 2864 0b76 8093 0B01 		sts 267,r24
1950:stk500boot.c  **** 				}
 2865               		.loc 1 1950 0
 2866 0b7a 88EC      		ldi r24,lo8(-56)
 2867 0b7c 90E0      		ldi r25,0
 2868 0b7e 0E94 0000 		call delay_ms
 2869               	.LVL304:
 2870 0b82 00C0      		rjmp .L144
 2871               	.L293:
1952:stk500boot.c  **** 				break;
 2872               		.loc 1 1952 0
 2873 0b84 1092 0B01 		sts 267,__zero_reg__
 2874 0b88 00C0      		rjmp .L125
 2875               	.L108:
1957:stk500boot.c  **** 				getCharFlag	=	false;
 2876               		.loc 1 1957 0
 2877 0b8a 60E0      		ldi r22,0
 2878 0b8c 80E0      		ldi r24,lo8(gTextMsg_PortNotSupported)
 2879 0b8e 90E0      		ldi r25,hi8(gTextMsg_PortNotSupported)
 2880 0b90 00C0      		rjmp .L272
 2881               	.LVL305:
 2882               	.L107:
1968:stk500boot.c  **** 	}
 2883               		.loc 1 1968 0
 2884 0b92 60E0      		ldi r22,0
 2885 0b94 80E0      		ldi r24,lo8(gTextMsg_MustBeLetter)
 2886 0b96 90E0      		ldi r25,hi8(gTextMsg_MustBeLetter)
 2887 0b98 00C0      		rjmp .L272
 2888               	.LVL306:
 2889               	.L68:
 2890               	.LBE169:
 2891               	.LBE199:
2097:stk500boot.c  **** 				AVR_PortOutput();
2098:stk500boot.c  **** 				break;
2099:stk500boot.c  **** 
2100:stk500boot.c  **** 			default:
2101:stk500boot.c  **** 				PrintFromPROGMEMln(gTextMsg_HUH, 0);
 2892               		.loc 1 2101 0
 2893 0b9a 60E0      		ldi r22,0
 2894 0b9c 80E0      		ldi r24,lo8(gTextMsg_HUH)
 2895 0b9e 90E0      		ldi r25,hi8(gTextMsg_HUH)
 2896               	.LVL307:
 2897               	.L272:
 2898 0ba0 0E94 0000 		call PrintFromPROGMEMln
 2899               	.LVL308:
 2900 0ba4 00C0      		rjmp .L202
 2901               	.LVL309:
 2902               	.L60:
 2903               	.LBE200:
 2904               	.LBE201:
 693:stk500boot.c  **** 				{
 2905               		.loc 1 693 0
 2906 0ba6 8330      		cpi r24,lo8(3)
 2907 0ba8 01F0      		breq .L210
 2908 0baa 00F4      		brsh .L148
 2909 0bac 8130      		cpi r24,lo8(1)
 2910 0bae 01F0      		breq .L208
 2911 0bb0 00F0      		brlo .L268
 2912 0bb2 00C0      		rjmp .L294
 2913               	.L148:
 2914 0bb4 8530      		cpi r24,lo8(5)
 2915 0bb6 01F0      		breq .L211
 2916 0bb8 00F0      		brlo .L153
 2917 0bba 8630      		cpi r24,lo8(6)
 2918 0bbc 01F0      		breq .+2
 2919 0bbe 00C0      		rjmp .L295
 689:stk500boot.c  **** 				}
 2920               		.loc 1 689 0
 2921 0bc0 A12C      		mov r10,__zero_reg__
 2922 0bc2 B12C      		mov r11,__zero_reg__
 2923 0bc4 00C0      		rjmp .L154
 2924               	.L268:
 2925 0bc6 A12C      		mov r10,__zero_reg__
 2926 0bc8 B12C      		mov r11,__zero_reg__
 696:stk500boot.c  **** 						{
 2927               		.loc 1 696 0
 2928 0bca 9B31      		cpi r25,lo8(27)
 2929 0bcc 01F4      		brne .+2
 2930 0bce 00C0      		rjmp .L155
 2931               	.LVL310:
 2932               	.L157:
 2933 0bd0 40E0      		ldi r20,0
 2934 0bd2 50E0      		ldi r21,0
 2935 0bd4 00C0      		rjmp .L200
 2936               	.LVL311:
 2937               	.L208:
 689:stk500boot.c  **** 				}
 2938               		.loc 1 689 0
 2939 0bd6 A12C      		mov r10,__zero_reg__
 2940 0bd8 B12C      		mov r11,__zero_reg__
 2941               	.LVL312:
 2942               	.L149:
 707:stk500boot.c  **** 					#else
 2943               		.loc 1 707 0
 2944 0bda 1927      		eor r17,r25
 2945               	.LVL313:
 720:stk500boot.c  **** 
 2946               		.loc 1 720 0
 2947 0bdc C65D      		subi r28,lo8(-298)
 2948 0bde DE4F      		sbci r29,hi8(-298)
 2949 0be0 9883      		st Y,r25
 2950 0be2 CA52      		subi r28,lo8(298)
 2951 0be4 D140      		sbci r29,hi8(298)
 706:stk500boot.c  **** 						checksum		^=	c;
 2952               		.loc 1 706 0
 2953 0be6 82E0      		ldi r24,lo8(2)
 720:stk500boot.c  **** 
 2954               		.loc 1 720 0
 2955 0be8 00C0      		rjmp .L157
 2956               	.LVL314:
 2957               	.L294:
 689:stk500boot.c  **** 				}
 2958               		.loc 1 689 0
 2959 0bea A12C      		mov r10,__zero_reg__
 2960 0bec B12C      		mov r11,__zero_reg__
 2961               	.LVL315:
 2962               	.L150:
 723:stk500boot.c  **** 						msgParseState	=	ST_MSG_SIZE_2;
 2963               		.loc 1 723 0
 2964 0bee 292F      		mov r18,r25
 2965               	.LVL316:
 2966 0bf0 30E0      		ldi r19,0
 2967 0bf2 322F      		mov r19,r18
 2968 0bf4 2227      		clr r18
 2969               	.LVL317:
 725:stk500boot.c  **** 						break;
 2970               		.loc 1 725 0
 2971 0bf6 1927      		eor r17,r25
 2972               	.LVL318:
 724:stk500boot.c  **** 						checksum		^=	c;
 2973               		.loc 1 724 0
 2974 0bf8 83E0      		ldi r24,lo8(3)
 726:stk500boot.c  **** 
 2975               		.loc 1 726 0
 2976 0bfa 00C0      		rjmp .L157
 2977               	.LVL319:
 2978               	.L210:
 689:stk500boot.c  **** 				}
 2979               		.loc 1 689 0
 2980 0bfc A12C      		mov r10,__zero_reg__
 2981 0bfe B12C      		mov r11,__zero_reg__
 2982               	.LVL320:
 2983               	.L147:
 729:stk500boot.c  **** 						msgParseState	=	ST_GET_TOKEN;
 2984               		.loc 1 729 0
 2985 0c00 292B      		or r18,r25
 2986               	.LVL321:
 731:stk500boot.c  **** 						break;
 2987               		.loc 1 731 0
 2988 0c02 1927      		eor r17,r25
 2989               	.LVL322:
 730:stk500boot.c  **** 						checksum		^=	c;
 2990               		.loc 1 730 0
 2991 0c04 84E0      		ldi r24,lo8(4)
 732:stk500boot.c  **** 
 2992               		.loc 1 732 0
 2993 0c06 00C0      		rjmp .L157
 2994               	.LVL323:
 2995               	.L153:
 689:stk500boot.c  **** 				}
 2996               		.loc 1 689 0
 2997 0c08 A12C      		mov r10,__zero_reg__
 2998 0c0a B12C      		mov r11,__zero_reg__
 735:stk500boot.c  **** 						{
 2999               		.loc 1 735 0
 3000 0c0c 9E30      		cpi r25,lo8(14)
 3001 0c0e 01F0      		breq .+2
 3002 0c10 00C0      		rjmp .L204
 3003               	.LVL324:
 738:stk500boot.c  **** 							ii				=	0;
 3004               		.loc 1 738 0
 3005 0c12 1927      		eor r17,r25
 3006               	.LVL325:
 739:stk500boot.c  **** 						}
 3007               		.loc 1 739 0
 3008 0c14 212C      		mov r2,__zero_reg__
 3009 0c16 312C      		mov r3,__zero_reg__
 3010 0c18 00C0      		rjmp .L270
 3011               	.LVL326:
 3012               	.L211:
 689:stk500boot.c  **** 				}
 3013               		.loc 1 689 0
 3014 0c1a A12C      		mov r10,__zero_reg__
 3015 0c1c B12C      		mov r11,__zero_reg__
 3016               	.LVL327:
 3017               	.L152:
 748:stk500boot.c  **** 						checksum		^=	c;
 3018               		.loc 1 748 0
 3019 0c1e A101      		movw r20,r2
 3020 0c20 4F5F      		subi r20,-1
 3021 0c22 5F4F      		sbci r21,-1
 3022               	.LVL328:
 3023 0c24 E1E0      		ldi r30,lo8(1)
 3024 0c26 F0E0      		ldi r31,0
 3025 0c28 EC0F      		add r30,r28
 3026 0c2a FD1F      		adc r31,r29
 3027 0c2c E20D      		add r30,r2
 3028 0c2e F31D      		adc r31,r3
 3029 0c30 9083      		st Z,r25
 749:stk500boot.c  **** 						if (ii == msgLength )
 3030               		.loc 1 749 0
 3031 0c32 1927      		eor r17,r25
 3032               	.LVL329:
 750:stk500boot.c  **** 						{
 3033               		.loc 1 750 0
 3034 0c34 4217      		cp r20,r18
 3035 0c36 5307      		cpc r21,r19
 3036 0c38 01F0      		breq .+2
 3037 0c3a 00C0      		rjmp .L214
 3038 0c3c 1901      		movw r2,r18
 752:stk500boot.c  **** 						}
 3039               		.loc 1 752 0
 3040 0c3e 86E0      		ldi r24,lo8(6)
 3041               	.LVL330:
 3042 0c40 00C0      		rjmp .L157
 3043               	.LVL331:
 3044               	.L206:
 689:stk500boot.c  **** 				}
 3045               		.loc 1 689 0
 3046 0c42 A12C      		mov r10,__zero_reg__
 3047 0c44 B12C      		mov r11,__zero_reg__
 3048               	.LVL332:
 3049               	.L61:
 693:stk500boot.c  **** 				{
 3050               		.loc 1 693 0
 3051 0c46 8330      		cpi r24,lo8(3)
 3052 0c48 01F0      		breq .L147
 3053 0c4a 00F4      		brsh .+2
 3054 0c4c 00C0      		rjmp .L296
 3055 0c4e 8530      		cpi r24,lo8(5)
 3056 0c50 01F0      		breq .L152
 3057 0c52 00F4      		brsh .+2
 3058 0c54 00C0      		rjmp .L204
 3059 0c56 8630      		cpi r24,lo8(6)
 3060 0c58 01F4      		brne .L146
 3061               	.LVL333:
 3062               	.L154:
 757:stk500boot.c  **** 						{
 3063               		.loc 1 757 0
 3064 0c5a 9113      		cpse r25,r17
 3065 0c5c 00C0      		rjmp .L204
 3066 0c5e 00C0      		rjmp .L215
 3067               	.LVL334:
 3068               	.L295:
 689:stk500boot.c  **** 				}
 3069               		.loc 1 689 0
 3070 0c60 A12C      		mov r10,__zero_reg__
 3071 0c62 B12C      		mov r11,__zero_reg__
 3072               	.LVL335:
 3073               	.L146:
 658:stk500boot.c  **** 			{
 3074               		.loc 1 658 0
 3075 0c64 8730      		cpi r24,lo8(7)
 3076 0c66 01F0      		breq .+2
 3077 0c68 00C0      		rjmp .L157
 3078               	.LVL336:
 3079               	.L215:
 3080 0c6a 912C      		mov r9,__zero_reg__
 3081               	.LVL337:
 3082               	.L101:
 773:stk500boot.c  **** 			{
 3083               		.loc 1 773 0
 3084 0c6c 2981      		ldd r18,Y+1
 3085 0c6e 2331      		cpi r18,lo8(19)
 3086 0c70 01F4      		brne .+2
 3087 0c72 00C0      		rjmp .L159
 3088 0c74 00F4      		brsh .L160
 3089 0c76 2630      		cpi r18,lo8(6)
 3090 0c78 01F4      		brne .+2
 3091 0c7a 00C0      		rjmp .L161
 3092 0c7c 00F4      		brsh .L162
 3093 0c7e 2230      		cpi r18,lo8(2)
 3094 0c80 01F4      		brne .+2
 3095 0c82 00C0      		rjmp .L191
 3096 0c84 2330      		cpi r18,lo8(3)
 3097 0c86 01F4      		brne .+2
 3098 0c88 00C0      		rjmp .L164
 3099 0c8a 2130      		cpi r18,lo8(1)
 3100 0c8c 01F0      		breq .+2
 3101 0c8e 00C0      		rjmp .L158
 3102               	.LVL338:
 837:stk500boot.c  **** 					msgBuffer[2] 	=	8;
 3103               		.loc 1 837 0
 3104 0c90 1A82      		std Y+2,__zero_reg__
 838:stk500boot.c  **** 					msgBuffer[3] 	=	'A';
 3105               		.loc 1 838 0
 3106 0c92 88E0      		ldi r24,lo8(8)
 3107 0c94 8B83      		std Y+3,r24
 839:stk500boot.c  **** 					msgBuffer[4] 	=	'V';
 3108               		.loc 1 839 0
 3109 0c96 81E4      		ldi r24,lo8(65)
 3110 0c98 8C83      		std Y+4,r24
 840:stk500boot.c  **** 					msgBuffer[5] 	=	'R';
 3111               		.loc 1 840 0
 3112 0c9a 86E5      		ldi r24,lo8(86)
 3113 0c9c 8D83      		std Y+5,r24
 841:stk500boot.c  **** 					msgBuffer[6] 	=	'I';
 3114               		.loc 1 841 0
 3115 0c9e 82E5      		ldi r24,lo8(82)
 3116 0ca0 8E83      		std Y+6,r24
 842:stk500boot.c  **** 					msgBuffer[7] 	=	'S';
 3117               		.loc 1 842 0
 3118 0ca2 89E4      		ldi r24,lo8(73)
 3119 0ca4 8F83      		std Y+7,r24
 843:stk500boot.c  **** 					msgBuffer[8] 	=	'P';
 3120               		.loc 1 843 0
 3121 0ca6 83E5      		ldi r24,lo8(83)
 3122 0ca8 8887      		std Y+8,r24
 844:stk500boot.c  **** 					msgBuffer[9] 	=	'_';
 3123               		.loc 1 844 0
 3124 0caa 80E5      		ldi r24,lo8(80)
 3125 0cac 8987      		std Y+9,r24
 845:stk500boot.c  **** 					msgBuffer[10]	=	'2';
 3126               		.loc 1 845 0
 3127 0cae 8FE5      		ldi r24,lo8(95)
 3128 0cb0 8A87      		std Y+10,r24
 846:stk500boot.c  **** 					break;
 3129               		.loc 1 846 0
 3130 0cb2 82E3      		ldi r24,lo8(50)
 3131 0cb4 8B87      		std Y+11,r24
 836:stk500boot.c  **** 					msgBuffer[1] 	=	STATUS_CMD_OK;
 3132               		.loc 1 836 0
 3133 0cb6 0BE0      		ldi r16,lo8(11)
 3134 0cb8 10E0      		ldi r17,0
 847:stk500boot.c  **** 
 3135               		.loc 1 847 0
 3136 0cba 00C0      		rjmp .L178
 3137               	.LVL339:
 3138               	.L162:
 773:stk500boot.c  **** 			{
 3139               		.loc 1 773 0
 3140 0cbc 2131      		cpi r18,lo8(17)
 3141 0cbe 01F4      		brne .+2
 3142 0cc0 00C0      		rjmp .L166
 3143 0cc2 00F0      		brlo .+2
 3144 0cc4 00C0      		rjmp .L167
 3145 0cc6 2031      		cpi r18,lo8(16)
 3146 0cc8 01F4      		brne .+2
 3147 0cca 00C0      		rjmp .L191
 3148 0ccc 00C0      		rjmp .L158
 3149               	.L160:
 3150 0cce 2831      		cpi r18,lo8(24)
 3151 0cd0 01F4      		brne .+2
 3152 0cd2 00C0      		rjmp .L168
 3153 0cd4 00F4      		brsh .L169
 3154 0cd6 2531      		cpi r18,lo8(21)
 3155 0cd8 01F4      		brne .+2
 3156 0cda 00C0      		rjmp .L159
 3157 0cdc 00F4      		brsh .+2
 3158 0cde 00C0      		rjmp .L170
 3159 0ce0 2631      		cpi r18,lo8(22)
 3160 0ce2 01F4      		brne .+2
 3161 0ce4 00C0      		rjmp .L170
 3162 0ce6 00C0      		rjmp .L158
 3163               	.L169:
 3164 0ce8 2A31      		cpi r18,lo8(26)
 3165 0cea 01F4      		brne .+2
 3166 0cec 00C0      		rjmp .L171
 3167 0cee 00F4      		brsh .+2
 3168 0cf0 00C0      		rjmp .L172
 3169 0cf2 2B31      		cpi r18,lo8(27)
 3170 0cf4 01F4      		brne .+2
 3171 0cf6 00C0      		rjmp .L173
 3172 0cf8 2D31      		cpi r18,lo8(29)
 3173 0cfa 01F0      		breq .+2
 3174 0cfc 00C0      		rjmp .L158
 3175               	.LVL340:
 3176               	.LBB202:
 781:stk500boot.c  **** 						{
 3177               		.loc 1 781 0
 3178 0cfe 9D81      		ldd r25,Y+5
 3179 0d00 9033      		cpi r25,lo8(48)
 3180 0d02 01F4      		brne .L175
 3181               	.LBB203:
 783:stk500boot.c  **** 
 3182               		.loc 1 783 0
 3183 0d04 8F81      		ldd r24,Y+7
 3184               	.LVL341:
 785:stk500boot.c  **** 							{
 3185               		.loc 1 785 0
 3186 0d06 8823      		tst r24
 3187 0d08 01F0      		breq .L216
 789:stk500boot.c  **** 							{
 3188               		.loc 1 789 0
 3189 0d0a 8130      		cpi r24,lo8(1)
 3190 0d0c 01F0      		breq .L217
 795:stk500boot.c  **** 							}
 3191               		.loc 1 795 0
 3192 0d0e 81E0      		ldi r24,lo8(1)
 3193               	.LVL342:
 3194 0d10 00C0      		rjmp .L176
 3195               	.LVL343:
 3196               	.L175:
 3197               	.LBE203:
 798:stk500boot.c  **** 						{
 3198               		.loc 1 798 0
 3199 0d12 892F      		mov r24,r25
 3200 0d14 8075      		andi r24,lo8(80)
 3201 0d16 01F0      		breq .L219
 805:stk500boot.c  **** 							{
 3202               		.loc 1 805 0
 3203 0d18 9035      		cpi r25,lo8(80)
 3204 0d1a 01F4      		brne .L177
 3205               	.LBB204:
 807:stk500boot.c  **** 							}
 3206               		.loc 1 807 0
 3207 0d1c 89E0      		ldi r24,lo8(9)
 3208 0d1e E0E0      		ldi r30,0
 3209 0d20 F0E0      		ldi r31,0
 3210 0d22 00C0      		rjmp .L275
 3211               	.L177:
 3212               	.LBE204:
 809:stk500boot.c  **** 							{
 3213               		.loc 1 809 0
 3214 0d24 9835      		cpi r25,lo8(88)
 3215 0d26 01F4      		brne .L219
 3216               	.LBB205:
 811:stk500boot.c  **** 							}
 3217               		.loc 1 811 0
 3218 0d28 E3E0      		ldi r30,lo8(3)
 3219 0d2a F0E0      		ldi r31,0
 3220 0d2c 89E0      		ldi r24,lo8(9)
 3221               	.L275:
 3222               	/* #APP */
 3223               	 ;  811 "stk500boot.c" 1
 3224 0d2e 8093 5700 		sts 87, r24
 3225 0d32 8491      		lpm r24, Z
 3226               		
 3227               	 ;  0 "" 2
 3228               	.LVL344:
 3229               	/* #NOAPP */
 3230               	.LBE205:
 3231 0d34 00C0      		rjmp .L176
 3232               	.LVL345:
 3233               	.L216:
 3234               	.LBB206:
 787:stk500boot.c  **** 							}
 3235               		.loc 1 787 0
 3236 0d36 8EE1      		ldi r24,lo8(30)
 3237               	.LVL346:
 3238 0d38 00C0      		rjmp .L176
 3239               	.LVL347:
 3240               	.L217:
 791:stk500boot.c  **** 							}
 3241               		.loc 1 791 0
 3242 0d3a 88E9      		ldi r24,lo8(-104)
 3243               	.LVL348:
 3244 0d3c 00C0      		rjmp .L176
 3245               	.LVL349:
 3246               	.L219:
 3247               	.LBE206:
 820:stk500boot.c  **** 						}
 3248               		.loc 1 820 0
 3249 0d3e 80E0      		ldi r24,0
 3250               	.L176:
 3251               	.LVL350:
 825:stk500boot.c  **** 							msgBuffer[2]	=	0;
 3252               		.loc 1 825 0
 3253 0d40 1A82      		std Y+2,__zero_reg__
 826:stk500boot.c  **** 							msgBuffer[3]	=	msgBuffer[4];
 3254               		.loc 1 826 0
 3255 0d42 1B82      		std Y+3,__zero_reg__
 827:stk500boot.c  **** 							msgBuffer[4]	=	0;
 3256               		.loc 1 827 0
 3257 0d44 9C83      		std Y+4,r25
 828:stk500boot.c  **** 							msgBuffer[5]	=	answerByte;
 3258               		.loc 1 828 0
 3259 0d46 1D82      		std Y+5,__zero_reg__
 829:stk500boot.c  **** 							msgBuffer[6]	=	STATUS_CMD_OK;
 3260               		.loc 1 829 0
 3261 0d48 8E83      		std Y+6,r24
 830:stk500boot.c  **** 						}
 3262               		.loc 1 830 0
 3263 0d4a 1F82      		std Y+7,__zero_reg__
 824:stk500boot.c  **** 							msgBuffer[1]	=	STATUS_CMD_OK;
 3264               		.loc 1 824 0
 3265 0d4c 07E0      		ldi r16,lo8(7)
 3266 0d4e 10E0      		ldi r17,0
 3267 0d50 00C0      		rjmp .L178
 3268               	.LVL351:
 3269               	.L164:
 3270 0d52 EA81      		ldd r30,Y+2
 3271 0d54 E059      		subi r30,lo8(-(112))
 3272 0d56 E330      		cpi r30,lo8(3)
 3273 0d58 00F4      		brsh .L220
 3274 0d5a F0E0      		ldi r31,0
 3275 0d5c E050      		subi r30,lo8(-(CSWTCH.70))
 3276 0d5e F040      		sbci r31,hi8(-(CSWTCH.70))
 3277 0d60 8081      		ld r24,Z
 3278 0d62 00C0      		rjmp .L179
 3279               	.L220:
 3280               	.LBE202:
 3281               	.LBB207:
 853:stk500boot.c  **** 						{
 3282               		.loc 1 853 0
 3283 0d64 80E0      		ldi r24,0
 3284               	.L179:
 3285               	.LVL352:
 875:stk500boot.c  **** 						msgBuffer[2]	=	value;
 3286               		.loc 1 875 0
 3287 0d66 1A82      		std Y+2,__zero_reg__
 876:stk500boot.c  **** 					}
 3288               		.loc 1 876 0
 3289 0d68 8B83      		std Y+3,r24
 3290 0d6a 00C0      		rjmp .L278
 3291               	.LVL353:
 3292               	.L166:
 3293               	.LBE207:
 881:stk500boot.c  **** 					//*	fall thru
 3294               		.loc 1 881 0
 3295 0d6c 9924      		clr r9
 3296 0d6e 9394      		inc r9
 3297               	.LVL354:
 3298 0d70 00C0      		rjmp .L191
 3299               	.LVL355:
 3300               	.L173:
 3301               	.LBB208:
 892:stk500boot.c  **** 						unsigned char signature;
 3302               		.loc 1 892 0
 3303 0d72 8D81      		ldd r24,Y+5
 3304               	.LVL356:
 895:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >>16) & 0x000000FF;
 3305               		.loc 1 895 0
 3306 0d74 8823      		tst r24
 3307 0d76 01F0      		breq .L221
 897:stk500boot.c  **** 							signature	=	(SIGNATURE_BYTES >> 8) & 0x000000FF;
 3308               		.loc 1 897 0
 3309 0d78 8130      		cpi r24,lo8(1)
 3310 0d7a 01F0      		breq .L222
 900:stk500boot.c  **** 
 3311               		.loc 1 900 0
 3312 0d7c 81E0      		ldi r24,lo8(1)
 3313               	.LVL357:
 3314 0d7e 00C0      		rjmp .L281
 3315               	.LVL358:
 3316               	.L221:
 896:stk500boot.c  **** 						else if ( signatureIndex == 1 )
 3317               		.loc 1 896 0
 3318 0d80 8EE1      		ldi r24,lo8(30)
 3319               	.LVL359:
 3320 0d82 00C0      		rjmp .L281
 3321               	.LVL360:
 3322               	.L222:
 898:stk500boot.c  **** 						else
 3323               		.loc 1 898 0
 3324 0d84 88E9      		ldi r24,lo8(-104)
 3325               	.LVL361:
 3326 0d86 00C0      		rjmp .L281
 3327               	.LVL362:
 3328               	.L171:
 3329               	.LBE208:
 911:stk500boot.c  **** 					msgBuffer[2]	=	boot_lock_fuse_bits_get( GET_LOCK_BITS );
 3330               		.loc 1 911 0
 3331 0d88 1A82      		std Y+2,__zero_reg__
 3332               	.LBB209:
 912:stk500boot.c  **** 					msgBuffer[3]	=	STATUS_CMD_OK;
 3333               		.loc 1 912 0
 3334 0d8a E1E0      		ldi r30,lo8(1)
 3335 0d8c F0E0      		ldi r31,0
 3336 0d8e 89E0      		ldi r24,lo8(9)
 3337               	/* #APP */
 3338               	 ;  912 "stk500boot.c" 1
 3339 0d90 8093 5700 		sts 87, r24
 3340 0d94 8491      		lpm r24, Z
 3341               		
 3342               	 ;  0 "" 2
 3343               	/* #NOAPP */
 3344               	.L280:
 3345               	.LVL363:
 3346               	.LBE209:
 3347 0d96 8B83      		std Y+3,r24
 913:stk500boot.c  **** 					break;
 3348               		.loc 1 913 0
 3349 0d98 1C82      		std Y+4,__zero_reg__
 910:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_OK;
 3350               		.loc 1 910 0
 3351 0d9a 04E0      		ldi r16,lo8(4)
 3352 0d9c 10E0      		ldi r17,0
 914:stk500boot.c  **** 
 3353               		.loc 1 914 0
 3354 0d9e 00C0      		rjmp .L178
 3355               	.LVL364:
 3356               	.L168:
 3357               	.LBB210:
 920:stk500boot.c  **** 						{
 3358               		.loc 1 920 0
 3359 0da0 8B81      		ldd r24,Y+3
 3360 0da2 8035      		cpi r24,lo8(80)
 3361 0da4 01F4      		brne .L181
 922:stk500boot.c  **** 								fuseBits	=	boot_lock_fuse_bits_get( GET_EXTENDED_FUSE_BITS );
 3362               		.loc 1 922 0
 3363 0da6 8C81      		ldd r24,Y+4
 3364 0da8 8830      		cpi r24,lo8(8)
 3365 0daa 01F4      		brne .L182
 3366               	.LBB211:
 923:stk500boot.c  **** 							else
 3367               		.loc 1 923 0
 3368 0dac E2E0      		ldi r30,lo8(2)
 3369 0dae F0E0      		ldi r31,0
 3370 0db0 00C0      		rjmp .L276
 3371               	.L182:
 3372               	.LBE211:
 3373               	.LBB212:
 925:stk500boot.c  **** 						}
 3374               		.loc 1 925 0
 3375 0db2 89E0      		ldi r24,lo8(9)
 3376 0db4 E0E0      		ldi r30,0
 3377 0db6 F0E0      		ldi r31,0
 3378 0db8 00C0      		rjmp .L277
 3379               	.L181:
 3380               	.LBE212:
 3381               	.LBB213:
 929:stk500boot.c  **** 						}
 3382               		.loc 1 929 0
 3383 0dba E3E0      		ldi r30,lo8(3)
 3384 0dbc F0E0      		ldi r31,0
 3385               	.L276:
 3386 0dbe 89E0      		ldi r24,lo8(9)
 3387               	.L277:
 3388               	/* #APP */
 3389               	 ;  929 "stk500boot.c" 1
 3390 0dc0 8093 5700 		sts 87, r24
 3391 0dc4 8491      		lpm r24, Z
 3392               		
 3393               	 ;  0 "" 2
 3394               	.LVL365:
 3395               	/* #NOAPP */
 3396               	.L281:
 3397               	.LBE213:
 932:stk500boot.c  **** 						msgBuffer[2]	=	fuseBits;
 3398               		.loc 1 932 0
 3399 0dc6 1A82      		std Y+2,__zero_reg__
 3400 0dc8 00C0      		rjmp .L280
 3401               	.LVL366:
 3402               	.L172:
 3403               	.LBE210:
 3404               	.LBB214:
 943:stk500boot.c  **** 						boot_lock_bits_set(lockBits);		// and program it
 3405               		.loc 1 943 0
 3406 0dca 8D81      		ldd r24,Y+5
 3407               	.LVL367:
 3408               	.LBB215:
 944:stk500boot.c  **** 						boot_spm_busy_wait();
 3409               		.loc 1 944 0
 3410 0dcc 836C      		ori r24,lo8(-61)
 3411               	.LVL368:
 3412 0dce 99E0      		ldi r25,lo8(9)
 3413               	/* #APP */
 3414               	 ;  944 "stk500boot.c" 1
 3415 0dd0 E1E0      		ldi r30, 1
 3416 0dd2 F0E0      		ldi r31, 0
 3417 0dd4 082E      		mov r0, r24
 3418 0dd6 9093 5700 		sts 87, r25
 3419 0dda E895      		spm
 3420               		
 3421               	 ;  0 "" 2
 3422               	/* #NOAPP */
 3423               	.L184:
 3424               	.LBE215:
 945:stk500boot.c  **** 
 3425               		.loc 1 945 0 discriminator 1
 3426 0ddc 07B6      		in __tmp_reg__,0x37
 3427 0dde 00FC      		sbrc __tmp_reg__,0
 3428 0de0 00C0      		rjmp .L184
 3429               	.LVL369:
 948:stk500boot.c  **** 						msgBuffer[2]	=	STATUS_CMD_OK;
 3430               		.loc 1 948 0
 3431 0de2 1A82      		std Y+2,__zero_reg__
 949:stk500boot.c  **** 					}
 3432               		.loc 1 949 0
 3433 0de4 1B82      		std Y+3,__zero_reg__
 3434               	.LVL370:
 3435               	.L278:
 947:stk500boot.c  **** 						msgBuffer[1]	=	STATUS_CMD_OK;
 3436               		.loc 1 947 0
 3437 0de6 03E0      		ldi r16,lo8(3)
 3438 0de8 10E0      		ldi r17,0
 3439               	.LBE214:
 951:stk500boot.c  **** 	#endif
 3440               		.loc 1 951 0
 3441 0dea 00C0      		rjmp .L178
 3442               	.LVL371:
 3443               	.L167:
 957:stk500boot.c  **** 					break;
 3444               		.loc 1 957 0
 3445 0dec 80EC      		ldi r24,lo8(-64)
 3446 0dee 8A83      		std Y+2,r24
 955:stk500boot.c  **** 				//	msgBuffer[1]	=	STATUS_CMD_OK;
 3447               		.loc 1 955 0
 3448 0df0 02E0      		ldi r16,lo8(2)
 3449 0df2 10E0      		ldi r17,0
 954:stk500boot.c  **** 					msgLength		=	2;
 3450               		.loc 1 954 0
 3451 0df4 CA5D      		subi r28,lo8(-294)
 3452 0df6 DE4F      		sbci r29,hi8(-294)
 3453 0df8 1882      		st Y,__zero_reg__
 3454 0dfa 1982      		std Y+1,__zero_reg__
 3455 0dfc 1A82      		std Y+2,__zero_reg__
 3456 0dfe 1B82      		std Y+3,__zero_reg__
 3457 0e00 C652      		subi r28,lo8(294)
 3458 0e02 D140      		sbci r29,hi8(294)
 958:stk500boot.c  **** 
 3459               		.loc 1 958 0
 3460 0e04 00C0      		rjmp .L178
 3461               	.LVL372:
 3462               	.L161:
 962:stk500boot.c  **** 	#else
 3463               		.loc 1 962 0
 3464 0e06 8A81      		ldd r24,Y+2
 3465 0e08 CB80      		ldd r12,Y+3
 3466               	.LVL373:
 3467 0e0a D12C      		mov r13,__zero_reg__
 3468 0e0c E12C      		mov r14,__zero_reg__
 3469 0e0e F12C      		mov r15,__zero_reg__
 3470 0e10 7601      		movw r14,r12
 3471 0e12 DD24      		clr r13
 3472 0e14 CC24      		clr r12
 3473 0e16 F82A      		or r15,r24
 3474 0e18 8D81      		ldd r24,Y+5
 3475 0e1a C82A      		or r12,r24
 3476 0e1c 8C81      		ldd r24,Y+4
 3477 0e1e D82A      		or r13,r24
 3478 0e20 CC0C      		lsl r12
 3479 0e22 DD1C      		rol r13
 3480 0e24 EE1C      		rol r14
 3481 0e26 FF1C      		rol r15
 3482               	.LVL374:
 3483 0e28 00C0      		rjmp .L191
 3484               	.LVL375:
 3485               	.L159:
 3486               	.LBB216:
 973:stk500boot.c  **** 						unsigned char	*p	=	msgBuffer+10;
 3487               		.loc 1 973 0
 3488 0e2a 0A81      		ldd r16,Y+2
 3489 0e2c 10E0      		ldi r17,0
 3490 0e2e 102F      		mov r17,r16
 3491 0e30 0027      		clr r16
 3492 0e32 8B81      		ldd r24,Y+3
 3493 0e34 082B      		or r16,r24
 3494               	.LVL376:
 980:stk500boot.c  **** 						{
 3495               		.loc 1 980 0
 3496 0e36 2331      		cpi r18,lo8(19)
 3497 0e38 01F0      		breq .+2
 3498 0e3a 00C0      		rjmp .L185
 983:stk500boot.c  **** 							{
 3499               		.loc 1 983 0
 3500 0e3c CA5D      		subi r28,lo8(-294)
 3501 0e3e DE4F      		sbci r29,hi8(-294)
 3502 0e40 2881      		ld r18,Y
 3503 0e42 3981      		ldd r19,Y+1
 3504 0e44 4A81      		ldd r20,Y+2
 3505 0e46 5B81      		ldd r21,Y+3
 3506 0e48 C652      		subi r28,lo8(294)
 3507 0e4a D140      		sbci r29,hi8(294)
 3508 0e4c 2115      		cp r18,__zero_reg__
 3509 0e4e 80EC      		ldi r24,-64
 3510 0e50 3807      		cpc r19,r24
 3511 0e52 83E0      		ldi r24,3
 3512 0e54 4807      		cpc r20,r24
 3513 0e56 5105      		cpc r21,__zero_reg__
 3514 0e58 00F4      		brsh .L186
 985:stk500boot.c  **** 								boot_spm_busy_wait();		// Wait until the memory is erased.
 3515               		.loc 1 985 0
 3516 0e5a 83E0      		ldi r24,lo8(3)
 3517               	/* #APP */
 3518               	 ;  985 "stk500boot.c" 1
 3519 0e5c F901      		movw r30, r18
 3520 0e5e 4093 5B00 		sts  91, r20
 3521 0e62 8093 5700 		sts 87, r24
 3522 0e66 E895      		spm
 3523               		
 3524               	 ;  0 "" 2
 3525               	/* #NOAPP */
 3526               	.L187:
 986:stk500boot.c  **** 								eraseAddress += SPM_PAGESIZE;	// point to next page to be erase
 3527               		.loc 1 986 0 discriminator 1
 3528 0e68 07B6      		in __tmp_reg__,0x37
 3529 0e6a 00FC      		sbrc __tmp_reg__,0
 3530 0e6c 00C0      		rjmp .L187
 987:stk500boot.c  **** 							}
 3531               		.loc 1 987 0
 3532 0e6e CA5D      		subi r28,lo8(-294)
 3533 0e70 DE4F      		sbci r29,hi8(-294)
 3534 0e72 2881      		ld r18,Y
 3535 0e74 3981      		ldd r19,Y+1
 3536 0e76 4A81      		ldd r20,Y+2
 3537 0e78 5B81      		ldd r21,Y+3
 3538 0e7a C652      		subi r28,lo8(294)
 3539 0e7c D140      		sbci r29,hi8(294)
 3540 0e7e 3F5F      		subi r19,-1
 3541 0e80 4F4F      		sbci r20,-1
 3542 0e82 5F4F      		sbci r21,-1
 3543 0e84 CA5D      		subi r28,lo8(-294)
 3544 0e86 DE4F      		sbci r29,hi8(-294)
 3545 0e88 2883      		st Y,r18
 3546 0e8a 3983      		std Y+1,r19
 3547 0e8c 4A83      		std Y+2,r20
 3548 0e8e 5B83      		std Y+3,r21
 3549 0e90 C652      		subi r28,lo8(294)
 3550 0e92 D140      		sbci r29,hi8(294)
 3551               	.LVL377:
 3552               	.L186:
 3553 0e94 8B85      		ldd r24,Y+11
 3554               	.LBE216:
 3555               	.LBB218:
 900:stk500boot.c  **** 
 3556               		.loc 1 900 0 discriminator 1
 3557 0e96 B701      		movw r22,r14
 3558 0e98 A601      		movw r20,r12
 3559 0e9a DE01      		movw r26,r28
 3560 0e9c 1B96      		adiw r26,11
 3561               	.LBE218:
 3562               	.LBB219:
 996:stk500boot.c  **** 
 3563               		.loc 1 996 0 discriminator 1
 3564 0e9e 21E0      		ldi r18,lo8(1)
 3565               	.LVL378:
 3566               	.L189:
 3567 0ea0 1296      		adiw r26,2
 3568               	.LVL379:
 3569 0ea2 FD01      		movw r30,r26
 3570 0ea4 3197      		sbiw r30,1
 3571               	.LVL380:
 995:stk500boot.c  **** 								boot_page_fill(address,data);
 3572               		.loc 1 995 0 discriminator 1
 3573 0ea6 3081      		ld r19,Z
 3574 0ea8 90E0      		ldi r25,0
 3575 0eaa 932B      		or r25,r19
 996:stk500boot.c  **** 
 3576               		.loc 1 996 0 discriminator 1
 3577               	/* #APP */
 3578               	 ;  996 "stk500boot.c" 1
 3579 0eac 0C01      		movw  r0, r24
 3580 0eae FA01      		movw r30, r20
 3581 0eb0 6093 5B00 		sts 91, r22
 3582 0eb4 2093 5700 		sts 87, r18
 3583 0eb8 E895      		spm
 3584 0eba 1124      		clr  r1
 3585               		
 3586               	 ;  0 "" 2
 3587               	.LVL381:
 998:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3588               		.loc 1 998 0 discriminator 1
 3589               	/* #NOAPP */
 3590 0ebc 4E5F      		subi r20,-2
 3591 0ebe 5F4F      		sbci r21,-1
 3592 0ec0 6F4F      		sbci r22,-1
 3593 0ec2 7F4F      		sbci r23,-1
 3594               	.LVL382:
 999:stk500boot.c  **** 							} while (size);					// Loop until all bytes written
 3595               		.loc 1 999 0 discriminator 1
 3596 0ec4 0250      		subi r16,2
 3597 0ec6 1109      		sbc r17,__zero_reg__
 3598               	.LVL383:
1000:stk500boot.c  **** 
 3599               		.loc 1 1000 0 discriminator 1
 3600 0ec8 01F0      		breq .L188
 993:stk500boot.c  **** 
 3601               		.loc 1 993 0
 3602 0eca 8C91      		ld r24,X
 3603               	.LVL384:
 3604 0ecc 00C0      		rjmp .L189
 3605               	.LVL385:
 3606               	.L188:
1002:stk500boot.c  **** 							boot_spm_busy_wait();
 3607               		.loc 1 1002 0
 3608 0ece 85E0      		ldi r24,lo8(5)
 3609               	.LVL386:
 3610               	/* #APP */
 3611               	 ;  1002 "stk500boot.c" 1
 3612 0ed0 F601      		movw r30, r12
 3613 0ed2 E092 5B00 		sts 91, r14
 3614 0ed6 8093 5700 		sts 87, r24
 3615 0eda E895      		spm
 3616               		
 3617               	 ;  0 "" 2
 3618               	/* #NOAPP */
 3619               	.L190:
1003:stk500boot.c  **** 							boot_rww_enable();				// Re-enable the RWW section
 3620               		.loc 1 1003 0 discriminator 1
 3621 0edc 07B6      		in __tmp_reg__,0x37
 3622 0ede 00FC      		sbrc __tmp_reg__,0
 3623 0ee0 00C0      		rjmp .L190
1004:stk500boot.c  **** 						}
 3624               		.loc 1 1004 0
 3625 0ee2 81E1      		ldi r24,lo8(17)
 3626               	/* #APP */
 3627               	 ;  1004 "stk500boot.c" 1
 3628 0ee4 8093 5700 		sts 87, r24
 3629 0ee8 E895      		spm
 3630               		
 3631               	 ;  0 "" 2
 998:stk500boot.c  **** 								size	-=	2;				// Reduce number of bytes to write by two
 3632               		.loc 1 998 0
 3633               	/* #NOAPP */
 3634 0eea 6A01      		movw r12,r20
 3635 0eec 7B01      		movw r14,r22
 3636               	.LVL387:
 3637 0eee 00C0      		rjmp .L191
 3638               	.LVL388:
 3639               	.L185:
 3640               	.LBB217:
1009:stk500boot.c  **** 							/* write EEPROM */
 3641               		.loc 1 1009 0
 3642 0ef0 A701      		movw r20,r14
 3643 0ef2 9601      		movw r18,r12
 3644 0ef4 5695      		lsr r21
 3645 0ef6 4795      		ror r20
 3646 0ef8 3795      		ror r19
 3647 0efa 2795      		ror r18
 3648 0efc CE5D      		subi r28,lo8(-290)
 3649 0efe DE4F      		sbci r29,hi8(-290)
 3650 0f00 2883      		st Y,r18
 3651 0f02 3983      		std Y+1,r19
 3652 0f04 4A83      		std Y+2,r20
 3653 0f06 5B83      		std Y+3,r21
 3654 0f08 C252      		subi r28,lo8(290)
 3655 0f0a D140      		sbci r29,hi8(290)
 3656               	.LVL389:
 3657 0f0c 3E01      		movw r6,r28
 3658 0f0e 3BE0      		ldi r19,11
 3659 0f10 630E      		add r6,r19
 3660 0f12 711C      		adc r7,__zero_reg__
1011:stk500boot.c  **** 								eeprom_write_byte((uint8_t*)ii, *p++);
 3661               		.loc 1 1011 0
 3662 0f14 412C      		mov r4,__zero_reg__
 3663 0f16 512C      		mov r5,__zero_reg__
 3664               	.LVL390:
 3665               	.L192:
 3666 0f18 4016      		cp r4,r16
 3667 0f1a 5106      		cpc r5,r17
 3668 0f1c 01F0      		breq .L297
1012:stk500boot.c  **** 								address+=2;						// Select next EEPROM byte
 3669               		.loc 1 1012 0
 3670 0f1e D301      		movw r26,r6
 3671 0f20 6D91      		ld r22,X+
 3672 0f22 3D01      		movw r6,r26
 3673 0f24 CE5D      		subi r28,lo8(-290)
 3674 0f26 DE4F      		sbci r29,hi8(-290)
 3675 0f28 8881      		ld r24,Y
 3676 0f2a 9981      		ldd r25,Y+1
 3677 0f2c C252      		subi r28,lo8(290)
 3678 0f2e D140      		sbci r29,hi8(290)
 3679 0f30 840D      		add r24,r4
 3680 0f32 951D      		adc r25,r5
 3681               	.LVL391:
 3682 0f34 0E94 0000 		call eeprom_write_byte
 3683               	.LVL392:
 3684 0f38 BFEF      		ldi r27,-1
 3685 0f3a 4B1A      		sub r4,r27
 3686 0f3c 5B0A      		sbc r5,r27
 3687               	.LVL393:
 3688 0f3e 00C0      		rjmp .L192
 3689               	.L297:
 3690 0f40 612C      		mov r6,__zero_reg__
 3691 0f42 712C      		mov r7,__zero_reg__
 3692 0f44 440C      		lsl r4
 3693 0f46 551C      		rol r5
 3694 0f48 661C      		rol r6
 3695 0f4a 771C      		rol r7
 3696               	.LVL394:
 3697 0f4c C40C      		add r12,r4
 3698 0f4e D51C      		adc r13,r5
 3699 0f50 E61C      		adc r14,r6
 3700 0f52 F71C      		adc r15,r7
 3701               	.LVL395:
 3702               	.L191:
 3703               	.LBE217:
1019:stk500boot.c  **** 					}
 3704               		.loc 1 1019 0
 3705 0f54 1A82      		std Y+2,__zero_reg__
 3706 0f56 00C0      		rjmp .L279
 3707               	.LVL396:
 3708               	.L170:
 3709               	.LBE219:
 3710               	.LBB220:
1026:stk500boot.c  **** 						unsigned char	*p		=	msgBuffer+1;
 3711               		.loc 1 1026 0
 3712 0f58 8A81      		ldd r24,Y+2
 3713 0f5a 90E0      		ldi r25,0
 3714 0f5c 982F      		mov r25,r24
 3715 0f5e 8827      		clr r24
 3716 0f60 3B81      		ldd r19,Y+3
 3717 0f62 832B      		or r24,r19
 3718               	.LVL397:
1028:stk500boot.c  **** 
 3719               		.loc 1 1028 0
 3720 0f64 8C01      		movw r16,r24
 3721 0f66 0D5F      		subi r16,-3
 3722 0f68 1F4F      		sbci r17,-1
 3723               	.LVL398:
1030:stk500boot.c  **** 						if (msgBuffer[0] == CMD_READ_FLASH_ISP )
 3724               		.loc 1 1030 0
 3725 0f6a 1A82      		std Y+2,__zero_reg__
1031:stk500boot.c  **** 						{
 3726               		.loc 1 1031 0
 3727 0f6c 2431      		cpi r18,lo8(20)
 3728 0f6e 01F4      		brne .L194
1031:stk500boot.c  **** 						{
 3729               		.loc 1 1031 0 is_stmt 0 discriminator 1
 3730 0f70 DE01      		movw r26,r28
 3731 0f72 1396      		adiw r26,3
 3732               	.LVL399:
 3733               	.L195:
 3734               	.LBB221:
 3735               	.LBB222:
1039:stk500boot.c  **** 						#else
 3736               		.loc 1 1039 0 is_stmt 1 discriminator 1
 3737               	/* #APP */
 3738               	 ;  1039 "stk500boot.c" 1
 3739 0f74 EBBE      		out 59, r14
 3740 0f76 F601      		movw r30, r12
 3741 0f78 2791      		elpm r18, Z+
 3742 0f7a 3691      		elpm r19, Z
 3743               		
 3744               	 ;  0 "" 2
 3745               	.LVL400:
 3746               	/* #NOAPP */
 3747               	.LBE222:
1043:stk500boot.c  **** 								*p++	=	(unsigned char)(data >> 8);	//MSB
 3748               		.loc 1 1043 0 discriminator 1
 3749 0f7c 2C93      		st X,r18
 3750 0f7e 1296      		adiw r26,2
 3751               	.LVL401:
 3752 0f80 FD01      		movw r30,r26
 3753 0f82 3197      		sbiw r30,1
1044:stk500boot.c  **** 								address	+=	2;							// Select next word in memory
 3754               		.loc 1 1044 0 discriminator 1
 3755 0f84 3083      		st Z,r19
1045:stk500boot.c  **** 								size	-=	2;
 3756               		.loc 1 1045 0 discriminator 1
 3757 0f86 E2E0      		ldi r30,2
 3758 0f88 CE0E      		add r12,r30
 3759 0f8a D11C      		adc r13,__zero_reg__
 3760 0f8c E11C      		adc r14,__zero_reg__
 3761 0f8e F11C      		adc r15,__zero_reg__
 3762               	.LVL402:
1046:stk500boot.c  **** 							}while (size);
 3763               		.loc 1 1046 0 discriminator 1
 3764 0f90 0297      		sbiw r24,2
 3765               	.LVL403:
1047:stk500boot.c  **** 						}
 3766               		.loc 1 1047 0 discriminator 1
 3767 0f92 01F4      		brne .L195
 3768 0f94 00C0      		rjmp .L196
 3769               	.LVL404:
 3770               	.L194:
 3771 0f96 FE01      		movw r30,r28
 3772 0f98 3396      		adiw r30,3
 3773               	.LBE221:
1031:stk500boot.c  **** 						{
 3774               		.loc 1 1031 0
 3775 0f9a 9C01      		movw r18,r24
 3776 0f9c B701      		movw r22,r14
 3777 0f9e A601      		movw r20,r12
 3778               	.LVL405:
 3779               	.L197:
1053:stk500boot.c  **** 								EEARH	=	((address >> 8));
 3780               		.loc 1 1053 0 discriminator 1
 3781 0fa0 41BD      		out 0x21,r20
1054:stk500boot.c  **** 								address++;					// Select next EEPROM byte
 3782               		.loc 1 1054 0 discriminator 1
 3783 0fa2 452E      		mov r4,r21
 3784 0fa4 562E      		mov r5,r22
 3785 0fa6 672E      		mov r6,r23
 3786 0fa8 7724      		clr r7
 3787 0faa 42BC      		out 0x22,r4
1055:stk500boot.c  **** 								EECR	|=	(1<<EERE);			// Read EEPROM
 3788               		.loc 1 1055 0 discriminator 1
 3789 0fac 4F5F      		subi r20,-1
 3790 0fae 5F4F      		sbci r21,-1
 3791 0fb0 6F4F      		sbci r22,-1
 3792 0fb2 7F4F      		sbci r23,-1
 3793               	.LVL406:
1056:stk500boot.c  **** 								*p++	=	EEDR;				// Send EEPROM data
 3794               		.loc 1 1056 0 discriminator 1
 3795 0fb4 F89A      		sbi 0x1f,0
 3796               	.LVL407:
1057:stk500boot.c  **** 								size--;
 3797               		.loc 1 1057 0 discriminator 1
 3798 0fb6 A0B5      		in r26,0x20
 3799 0fb8 A193      		st Z+,r26
 3800               	.LVL408:
1058:stk500boot.c  **** 							} while (size);
 3801               		.loc 1 1058 0 discriminator 1
 3802 0fba 2150      		subi r18,1
 3803 0fbc 3109      		sbc r19,__zero_reg__
 3804               	.LVL409:
1059:stk500boot.c  **** 						}
 3805               		.loc 1 1059 0 discriminator 1
 3806 0fbe 01F4      		brne .L197
 3807 0fc0 AC01      		movw r20,r24
 3808               	.LVL410:
 3809 0fc2 4150      		subi r20,1
 3810 0fc4 5109      		sbc r21,__zero_reg__
 3811 0fc6 60E0      		ldi r22,0
 3812 0fc8 70E0      		ldi r23,0
 3813 0fca 4F5F      		subi r20,-1
 3814 0fcc 5F4F      		sbci r21,-1
 3815 0fce 6F4F      		sbci r22,-1
 3816 0fd0 7F4F      		sbci r23,-1
 3817 0fd2 C40E      		add r12,r20
 3818 0fd4 D51E      		adc r13,r21
 3819 0fd6 E61E      		adc r14,r22
 3820 0fd8 F71E      		adc r15,r23
 3821 0fda A3E0      		ldi r26,lo8(3)
 3822 0fdc B0E0      		ldi r27,0
 3823 0fde AC0F      		add r26,r28
 3824 0fe0 BD1F      		adc r27,r29
 3825 0fe2 A80F      		add r26,r24
 3826 0fe4 B91F      		adc r27,r25
 3827               	.LVL411:
 3828               	.L196:
1061:stk500boot.c  **** 					}
 3829               		.loc 1 1061 0
 3830 0fe6 1C92      		st X,__zero_reg__
 3831               	.LBE220:
1063:stk500boot.c  **** 
 3832               		.loc 1 1063 0
 3833 0fe8 00C0      		rjmp .L178
 3834               	.LVL412:
 3835               	.L158:
1067:stk500boot.c  **** 					break;
 3836               		.loc 1 1067 0
 3837 0fea 80EC      		ldi r24,lo8(-64)
 3838 0fec 8A83      		std Y+2,r24
 3839               	.L279:
1066:stk500boot.c  **** 					msgBuffer[1]	=	STATUS_CMD_FAILED;
 3840               		.loc 1 1066 0
 3841 0fee 02E0      		ldi r16,lo8(2)
 3842 0ff0 10E0      		ldi r17,0
 3843               	.LVL413:
 3844               	.L178:
1074:stk500boot.c  **** 			checksum	=	MESSAGE_START^0;
 3845               		.loc 1 1074 0
 3846 0ff2 8BE1      		ldi r24,lo8(27)
 3847 0ff4 0E94 0000 		call sendchar
 3848               	.LVL414:
1077:stk500boot.c  **** 			checksum	^=	seqNum;
 3849               		.loc 1 1077 0
 3850 0ff8 C65D      		subi r28,lo8(-298)
 3851 0ffa DE4F      		sbci r29,hi8(-298)
 3852 0ffc 8881      		ld r24,Y
 3853 0ffe CA52      		subi r28,lo8(298)
 3854 1000 D140      		sbci r29,hi8(298)
 3855 1002 0E94 0000 		call sendchar
 3856               	.LVL415:
1081:stk500boot.c  **** 			checksum	^=	c;
 3857               		.loc 1 1081 0
 3858 1006 812F      		mov r24,r17
 3859 1008 0E94 0000 		call sendchar
 3860               	.LVL416:
1085:stk500boot.c  **** 			checksum ^= c;
 3861               		.loc 1 1085 0
 3862 100c 802F      		mov r24,r16
 3863 100e 0E94 0000 		call sendchar
 3864               	.LVL417:
 3865 1012 85E1      		ldi r24,lo8(21)
 3866 1014 C65D      		subi r28,lo8(-298)
 3867 1016 DE4F      		sbci r29,hi8(-298)
 3868 1018 8880      		ld r8,Y
 3869 101a CA52      		subi r28,lo8(298)
 3870 101c D140      		sbci r29,hi8(298)
 3871 101e 8826      		eor r8,r24
 3872 1020 8026      		eor r8,r16
 3873               	.LVL418:
1088:stk500boot.c  **** 			checksum ^= TOKEN;
 3874               		.loc 1 1088 0
 3875 1022 8EE0      		ldi r24,lo8(14)
 3876 1024 0E94 0000 		call sendchar
 3877               	.LVL419:
1089:stk500boot.c  **** 
 3878               		.loc 1 1089 0
 3879 1028 8126      		eor r8,r17
 3880               	.LVL420:
 3881 102a 9E01      		movw r18,r28
 3882 102c 2F5F      		subi r18,-1
 3883 102e 3F4F      		sbci r19,-1
 3884 1030 3901      		movw r6,r18
 3885 1032 020F      		add r16,r18
 3886 1034 131F      		adc r17,r19
 3887               	.LVL421:
 3888               	.L198:
1092:stk500boot.c  **** 			{
 3889               		.loc 1 1092 0
 3890 1036 6016      		cp r6,r16
 3891 1038 7106      		cpc r7,r17
 3892 103a 01F0      		breq .L298
 3893               	.LVL422:
1094:stk500boot.c  **** 				sendchar(c);
 3894               		.loc 1 1094 0
 3895 103c D301      		movw r26,r6
 3896 103e 5D90      		ld r5,X+
 3897               	.LVL423:
 3898 1040 3D01      		movw r6,r26
 3899               	.LVL424:
1095:stk500boot.c  **** 				checksum ^=c;
 3900               		.loc 1 1095 0
 3901 1042 852D      		mov r24,r5
 3902 1044 0E94 0000 		call sendchar
 3903               	.LVL425:
1096:stk500boot.c  **** 				msgLength--;
 3904               		.loc 1 1096 0
 3905 1048 8524      		eor r8,r5
 3906               	.LVL426:
 3907 104a 00C0      		rjmp .L198
 3908               	.LVL427:
 3909               	.L298:
 3910 104c 182D      		mov r17,r8
1099:stk500boot.c  **** 			seqNum++;
 3911               		.loc 1 1099 0
 3912 104e 882D      		mov r24,r8
 3913 1050 0E94 0000 		call sendchar
 3914               	.LVL428:
1100:stk500boot.c  **** 
 3915               		.loc 1 1100 0
 3916 1054 C65D      		subi r28,lo8(-298)
 3917 1056 DE4F      		sbci r29,hi8(-298)
 3918 1058 2881      		ld r18,Y
 3919 105a CA52      		subi r28,lo8(298)
 3920 105c D140      		sbci r29,hi8(298)
 3921 105e 2F5F      		subi r18,lo8(-(1))
 3922 1060 C65D      		subi r28,lo8(-298)
 3923 1062 DE4F      		sbci r29,hi8(-298)
 3924 1064 2883      		st Y,r18
 3925 1066 CA52      		subi r28,lo8(298)
 3926 1068 D140      		sbci r29,hi8(298)
 3927               	.LVL429:
1104:stk500boot.c  **** 		#endif
 3928               		.loc 1 1104 0
 3929 106a 94B3      		in r25,0x14
 3930 106c 80E2      		ldi r24,lo8(32)
 3931 106e 8927      		eor r24,r25
 3932 1070 84BB      		out 0x14,r24
 3933               	.LVL430:
 3934 1072 40E0      		ldi r20,0
 3935 1074 50E0      		ldi r21,0
 652:stk500boot.c  **** 		{
 3936               		.loc 1 652 0
 3937 1076 9920      		tst r9
 3938 1078 01F4      		brne .+4
 3939 107a 0C94 0000 		jmp .L53
 3940               	.LVL431:
 3941               	.L54:
1139:stk500boot.c  **** 	PROGLED_PORT	&=	~(1<<PROGLED_PIN);	// active low LED OFF
 3942               		.loc 1 1139 0
 3943 107e 9D98      		cbi 0x13,5
1140:stk500boot.c  **** //	PROGLED_PORT	|=	(1<<PROGLED_PIN);	// active high LED OFf
 3944               		.loc 1 1140 0
 3945 1080 A598      		cbi 0x14,5
1142:stk500boot.c  **** #endif
 3946               		.loc 1 1142 0
 3947 1082 84E6      		ldi r24,lo8(100)
 3948 1084 90E0      		ldi r25,0
 3949 1086 0E94 0000 		call delay_ms
 3950               	.LVL432:
1146:stk500boot.c  **** 
 3951               		.loc 1 1146 0
 3952               	/* #APP */
 3953               	 ;  1146 "stk500boot.c" 1
 3954 108a 0000      		nop
 3955               	 ;  0 "" 2
1152:stk500boot.c  **** 	boot_rww_enable();				// enable application section
 3956               		.loc 1 1152 0
 3957               	/* #NOAPP */
 3958 108c 8091 C000 		lds r24,192
 3959 1090 8D7F      		andi r24,lo8(-3)
 3960 1092 8093 C000 		sts 192,r24
1153:stk500boot.c  **** 
 3961               		.loc 1 1153 0
 3962 1096 81E1      		ldi r24,lo8(17)
 3963               	/* #APP */
 3964               	 ;  1153 "stk500boot.c" 1
 3965 1098 8093 5700 		sts 87, r24
 3966 109c E895      		spm
 3967               		
 3968               	 ;  0 "" 2
1156:stk500boot.c  **** 			"clr	r30		\n\t"
 3969               		.loc 1 1156 0
 3970               	 ;  1156 "stk500boot.c" 1
 3971 109e EE27      		clr	r30		
 3972 10a0 FF27      		clr	r31		
 3973 10a2 0994      		ijmp	
 3974               		
 3975               	 ;  0 "" 2
 3976               	/* #NOAPP */
 3977               	.L201:
1171:stk500boot.c  **** }
 3978               		.loc 1 1171 0 discriminator 1
 3979 10a4 00C0      		rjmp .L201
 3980               	.LVL433:
 3981               	.L155:
 699:stk500boot.c  **** 						}
 3982               		.loc 1 699 0
 3983 10a6 1BE1      		ldi r17,lo8(27)
 3984               	.LVL434:
 698:stk500boot.c  **** 							checksum		=	MESSAGE_START^0;
 3985               		.loc 1 698 0
 3986 10a8 81E0      		ldi r24,lo8(1)
 3987               	.LVL435:
 3988 10aa 00C0      		rjmp .L157
 3989               	.LVL436:
 3990               	.L214:
 3991 10ac 1A01      		movw r2,r20
 3992               	.LVL437:
 3993               	.L270:
 3994 10ae 85E0      		ldi r24,lo8(5)
 3995               	.LVL438:
 3996 10b0 00C0      		rjmp .L157
 3997               	.LVL439:
 3998               	.L296:
 693:stk500boot.c  **** 				{
 3999               		.loc 1 693 0
 4000 10b2 8130      		cpi r24,lo8(1)
 4001 10b4 01F4      		brne .+2
 4002 10b6 00C0      		rjmp .L149
 4003 10b8 00F4      		brsh .+2
 4004 10ba 00C0      		rjmp .L157
 4005 10bc 00C0      		rjmp .L150
 4006               	.LVL440:
 4007               	.L204:
 743:stk500boot.c  **** 						}
 4008               		.loc 1 743 0
 4009 10be 80E0      		ldi r24,0
 4010               	.LVL441:
 4011 10c0 00C0      		rjmp .L157
 4012               		.cfi_endproc
 4013               	.LFE17:
 4015               		.section	.rodata
 4018               	CSWTCH.70:
 4019 0000 0F        		.byte	15
 4020 0001 02        		.byte	2
 4021 0002 0A        		.byte	10
 4022               	.global	gTextMsg_END
 4023               		.section	.progmem.data,"a",@progbits
 4026               	gTextMsg_END:
 4027 0000 2A00      		.string	"*"
 4028               	.global	gTextMsg_HELP_MSG_Y
 4031               	gTextMsg_HELP_MSG_Y:
 4032 0002 593D 506F 		.string	"Y=Port blink"
 4032      7274 2062 
 4032      6C69 6E6B 
 4032      00
 4033               	.global	gTextMsg_HELP_MSG_V
 4036               	gTextMsg_HELP_MSG_V:
 4037 000f 563D 7368 		.string	"V=show interrupt Vectors"
 4037      6F77 2069 
 4037      6E74 6572 
 4037      7275 7074 
 4037      2056 6563 
 4038               	.global	gTextMsg_HELP_MSG_R
 4041               	gTextMsg_HELP_MSG_R:
 4042 0028 523D 4475 		.string	"R=Dump RAM"
 4042      6D70 2052 
 4042      414D 00
 4043               	.global	gTextMsg_HELP_MSG_Q
 4046               	gTextMsg_HELP_MSG_Q:
 4047 0033 513D 5175 		.string	"Q=Quit"
 4047      6974 00
 4048               	.global	gTextMsg_HELP_MSG_L
 4051               	gTextMsg_HELP_MSG_L:
 4052 003a 4C3D 4C69 		.string	"L=List I/O Ports"
 4052      7374 2049 
 4052      2F4F 2050 
 4052      6F72 7473 
 4052      00
 4053               	.global	gTextMsg_HELP_MSG_H
 4056               	gTextMsg_HELP_MSG_H:
 4057 004b 483D 4865 		.string	"H=Help"
 4057      6C70 00
 4058               	.global	gTextMsg_HELP_MSG_F
 4061               	gTextMsg_HELP_MSG_F:
 4062 0052 463D 4475 		.string	"F=Dump FLASH"
 4062      6D70 2046 
 4062      4C41 5348 
 4062      00
 4063               	.global	gTextMsg_HELP_MSG_E
 4066               	gTextMsg_HELP_MSG_E:
 4067 005f 453D 4475 		.string	"E=Dump EEPROM"
 4067      6D70 2045 
 4067      4550 524F 
 4067      4D00 
 4068               	.global	gTextMsg_HELP_MSG_B
 4071               	gTextMsg_HELP_MSG_B:
 4072 006d 423D 426C 		.string	"B=Blink LED"
 4072      696E 6B20 
 4072      4C45 4400 
 4073               	.global	gTextMsg_HELP_MSG_AT
 4076               	gTextMsg_HELP_MSG_AT:
 4077 0079 403D 4545 		.string	"@=EEPROM test"
 4077      5052 4F4D 
 4077      2074 6573 
 4077      7400 
 4078               	.global	gTextMsg_HELP_MSG_QM
 4081               	gTextMsg_HELP_MSG_QM:
 4082 0087 3F3D 4350 		.string	"?=CPU stats"
 4082      5520 7374 
 4082      6174 7300 
 4083               	.global	gTextMsg_HELP_MSG_0
 4086               	gTextMsg_HELP_MSG_0:
 4087 0093 303D 5A65 		.string	"0=Zero addr"
 4087      726F 2061 
 4087      6464 7200 
 4088               	.global	gTextMsg_PORT
 4091               	gTextMsg_PORT:
 4092 009f 504F 5254 		.string	"PORT"
 4092      00
 4093               	.global	gTextMsg_EEPROMerrorCnt
 4096               	gTextMsg_EEPROMerrorCnt:
 4097 00a4 4545 2065 		.string	"EE err cnt="
 4097      7272 2063 
 4097      6E74 3D00 
 4098               	.global	gTextMsg_ReadingEEprom
 4101               	gTextMsg_ReadingEEprom:
 4102 00b0 5265 6164 		.string	"Reading EE"
 4102      696E 6720 
 4102      4545 00
 4103               	.global	gTextMsg_WriteToEEprom
 4106               	gTextMsg_WriteToEEprom:
 4107 00bb 5772 6974 		.string	"Writting EE"
 4107      7469 6E67 
 4107      2045 4500 
 4108               	.global	gTextMsg_SPACE
 4111               	gTextMsg_SPACE:
 4112 00c7 2000      		.string	" "
 4113               	.global	gTextMsg_MustBeLetter
 4116               	gTextMsg_MustBeLetter:
 4117 00c9 4D75 7374 		.string	"Must be a letter"
 4117      2062 6520 
 4117      6120 6C65 
 4117      7474 6572 
 4117      00
 4118               	.global	gTextMsg_PortNotSupported
 4121               	gTextMsg_PortNotSupported:
 4122 00da 506F 7274 		.string	"Port not supported"
 4122      206E 6F74 
 4122      2073 7570 
 4122      706F 7274 
 4122      6564 00
 4123               	.global	gTextMsg_WHAT_PORT
 4126               	gTextMsg_WHAT_PORT:
 4127 00ed 5768 6174 		.string	"What port:"
 4127      2070 6F72 
 4127      743A 00
 4128               	.global	gTextMsg_jmp
 4131               	gTextMsg_jmp:
 4132 00f8 6A6D 7020 		.string	"jmp "
 4132      00
 4133               	.global	gTextMsg_rjmp
 4136               	gTextMsg_rjmp:
 4137 00fd 726A 6D70 		.string	"rjmp  "
 4137      2020 00
 4138               	.global	gTextMsg_noVector
 4141               	gTextMsg_noVector:
 4142 0104 6E6F 2076 		.string	"no vector"
 4142      6563 746F 
 4142      7200 
 4143               	.global	gTextMsg_VECTOR_HEADER
 4146               	gTextMsg_VECTOR_HEADER:
 4147 010e 5623 2020 		.string	"V#   ADDR   op code     instruction addr   Interrupt"
 4147      2041 4444 
 4147      5220 2020 
 4147      6F70 2063 
 4147      6F64 6520 
 4148               	.global	gTextMsg_GCC_VERSION_STR
 4151               	gTextMsg_GCC_VERSION_STR:
 4152 0143 342E 392E 		.string	"4.9.2"
 4152      3200 
 4153               	.global	gTextMsg_AVR_LIBC_VER_STR
 4156               	gTextMsg_AVR_LIBC_VER_STR:
 4157 0149 322E 302E 		.string	"2.0.0"
 4157      3000 
 4158               	.global	gTextMsg_GCC_DATE_STR
 4161               	gTextMsg_GCC_DATE_STR:
 4162 014f 4D61 7220 		.string	"Mar  1 2018"
 4162      2031 2032 
 4162      3031 3800 
 4163               	.global	gTextMsg_FUSE_BYTE_LOCK
 4166               	gTextMsg_FUSE_BYTE_LOCK:
 4167 015b 4C6F 636B 		.string	"Lock fuse   = "
 4167      2066 7573 
 4167      6520 2020 
 4167      3D20 00
 4168               	.global	gTextMsg_FUSE_BYTE_EXT
 4171               	gTextMsg_FUSE_BYTE_EXT:
 4172 016a 4578 7420 		.string	"Ext fuse    = "
 4172      6675 7365 
 4172      2020 2020 
 4172      3D20 00
 4173               	.global	gTextMsg_FUSE_BYTE_HIGH
 4176               	gTextMsg_FUSE_BYTE_HIGH:
 4177 0179 4869 6768 		.string	"High fuse   = "
 4177      2066 7573 
 4177      6520 2020 
 4177      3D20 00
 4178               	.global	gTextMsg_FUSE_BYTE_LOW
 4181               	gTextMsg_FUSE_BYTE_LOW:
 4182 0188 4C6F 7720 		.string	"Low fuse    = "
 4182      6675 7365 
 4182      2020 2020 
 4182      3D20 00
 4183               	.global	gTextMsg_CPU_SIGNATURE
 4186               	gTextMsg_CPU_SIGNATURE:
 4187 0197 4350 5520 		.string	"CPU ID      = "
 4187      4944 2020 
 4187      2020 2020 
 4187      3D20 00
 4188               	.global	gTextMsg_GCC_VERSION
 4191               	gTextMsg_GCC_VERSION:
 4192 01a6 4743 4320 		.string	"GCC Version = "
 4192      5665 7273 
 4192      696F 6E20 
 4192      3D20 00
 4193               	.global	gTextMsg_AVR_LIBC
 4196               	gTextMsg_AVR_LIBC:
 4197 01b5 4156 5220 		.string	"AVR LibC Ver= "
 4197      4C69 6243 
 4197      2056 6572 
 4197      3D20 00
 4198               	.global	gTextMsg_AVR_ARCH
 4201               	gTextMsg_AVR_ARCH:
 4202 01c4 5F5F 4156 		.string	"__AVR_ARCH__= "
 4202      525F 4152 
 4202      4348 5F5F 
 4202      3D20 00
 4203               	.global	gTextMsg_CPU_Type
 4206               	gTextMsg_CPU_Type:
 4207 01d3 4350 5520 		.string	"CPU Type    = "
 4207      5479 7065 
 4207      2020 2020 
 4207      3D20 00
 4208               	.global	gTextMsg_COMPILED_ON
 4211               	gTextMsg_COMPILED_ON:
 4212 01e2 436F 6D70 		.string	"Compiled on = "
 4212      696C 6564 
 4212      206F 6E20 
 4212      3D20 00
 4213               	.global	gTextMsg_HUH
 4216               	gTextMsg_HUH:
 4217 01f1 4875 683F 		.string	"Huh?"
 4217      00
 4218               	.global	gTextMsg_Prompt
 4221               	gTextMsg_Prompt:
 4222 01f6 426F 6F74 		.string	"Bootloader>"
 4222      6C6F 6164 
 4222      6572 3E00 
 4223               	.global	gTextMsg_Explorer
 4226               	gTextMsg_Explorer:
 4227 0202 4172 6475 		.string	"Arduino explorer stk500V2 by MLS"
 4227      696E 6F20 
 4227      6578 706C 
 4227      6F72 6572 
 4227      2073 746B 
 4228               	.global	gTextMsg_CPU_Name
 4231               	gTextMsg_CPU_Name:
 4232 0223 4154 6D65 		.string	"ATmega2560"
 4232      6761 3235 
 4232      3630 00
 4233               		.comm	gEepromIndex,4,1
 4234               		.comm	gFlashIndex,4,1
 4235               		.comm	gRamIndex,4,1
 4236               		.text
 4237               	.Letext0:
 4238               		.file 3 "/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/stdint.h"
 4239               		.file 4 "/Users/djeasy84/Documents/GitHub/easyOS/Mac/AVR-GCC/avr/include/avr/eeprom.h"
DEFINED SYMBOLS
                            *ABS*:00000000 stk500boot.c
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:2      *ABS*:0000003e __SP_H__
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:3      *ABS*:0000003d __SP_L__
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4      *ABS*:0000003f __SREG__
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:5      *ABS*:0000003b __RAMPZ__
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:6      *ABS*:00000000 __tmp_reg__
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:7      *ABS*:00000001 __zero_reg__
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:12     .text:00000000 sendchar
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:41     .text.unlikely:00000000 recchar
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:64     .init9:00000000 __jumpMain
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:75     *ABS*:000021ff __stack
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:787    .text.startup:00000000 main
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:114    .text:00000018 delay_ms
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:160    .text:00000036 PrintFromPROGMEM
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:223    .text:0000005e PrintNewLine
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:244    .text.unlikely:0000000e PrintAvailablePort
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4091   .progmem.data:0000009f gTextMsg_PORT
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:282    .text:0000006a PrintFromPROGMEMln
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:302    .text:00000072 PrintString
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:345    .text:0000008a PrintHexByte
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:405    .text.unlikely:00000028 DumpHex.constprop.0
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:687    .text:000000b8 PrintDecInt
                            *COM*:00000004 gRamIndex
                            *COM*:00000004 gFlashIndex
                            *COM*:00000004 gEepromIndex
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4226   .progmem.data:00000202 gTextMsg_Explorer
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4221   .progmem.data:000001f6 gTextMsg_Prompt
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4081   .progmem.data:00000087 gTextMsg_HELP_MSG_QM
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4211   .progmem.data:000001e2 gTextMsg_COMPILED_ON
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4161   .progmem.data:0000014f gTextMsg_GCC_DATE_STR
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4206   .progmem.data:000001d3 gTextMsg_CPU_Type
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4231   .progmem.data:00000223 gTextMsg_CPU_Name
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4201   .progmem.data:000001c4 gTextMsg_AVR_ARCH
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4191   .progmem.data:000001a6 gTextMsg_GCC_VERSION
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4151   .progmem.data:00000143 gTextMsg_GCC_VERSION_STR
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4196   .progmem.data:000001b5 gTextMsg_AVR_LIBC
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4156   .progmem.data:00000149 gTextMsg_AVR_LIBC_VER_STR
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4186   .progmem.data:00000197 gTextMsg_CPU_SIGNATURE
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4181   .progmem.data:00000188 gTextMsg_FUSE_BYTE_LOW
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4176   .progmem.data:00000179 gTextMsg_FUSE_BYTE_HIGH
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4171   .progmem.data:0000016a gTextMsg_FUSE_BYTE_EXT
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4166   .progmem.data:0000015b gTextMsg_FUSE_BYTE_LOCK
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4051   .progmem.data:0000003a gTextMsg_HELP_MSG_L
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4041   .progmem.data:00000028 gTextMsg_HELP_MSG_R
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4086   .progmem.data:00000093 gTextMsg_HELP_MSG_0
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4076   .progmem.data:00000079 gTextMsg_HELP_MSG_AT
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4106   .progmem.data:000000bb gTextMsg_WriteToEEprom
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4101   .progmem.data:000000b0 gTextMsg_ReadingEEprom
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4111   .progmem.data:000000c7 gTextMsg_SPACE
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4096   .progmem.data:000000a4 gTextMsg_EEPROMerrorCnt
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4071   .progmem.data:0000006d gTextMsg_HELP_MSG_B
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4066   .progmem.data:0000005f gTextMsg_HELP_MSG_E
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4061   .progmem.data:00000052 gTextMsg_HELP_MSG_F
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4056   .progmem.data:0000004b gTextMsg_HELP_MSG_H
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4046   .progmem.data:00000033 gTextMsg_HELP_MSG_Q
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4036   .progmem.data:0000000f gTextMsg_HELP_MSG_V
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4031   .progmem.data:00000002 gTextMsg_HELP_MSG_Y
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4146   .progmem.data:0000010e gTextMsg_VECTOR_HEADER
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4141   .progmem.data:00000104 gTextMsg_noVector
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4136   .progmem.data:000000fd gTextMsg_rjmp
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4131   .progmem.data:000000f8 gTextMsg_jmp
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4126   .progmem.data:000000ed gTextMsg_WHAT_PORT
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4121   .progmem.data:000000da gTextMsg_PortNotSupported
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4116   .progmem.data:000000c9 gTextMsg_MustBeLetter
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4216   .progmem.data:000001f1 gTextMsg_HUH
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4018   .rodata:00000000 CSWTCH.70
/var/folders/rz/y6z0h14n4td6b7q9qq88grdh0000gn/T//cc52GpPQ.s:4026   .progmem.data:00000000 gTextMsg_END

UNDEFINED SYMBOLS
eeprom_read_byte
__divmodhi4
__udivmodsi4
eeprom_write_byte
__do_copy_data
__do_clear_bss
